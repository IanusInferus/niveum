//==========================================================================
//
//  Notice:      This file is automatically generated.
//               Please don't modify this file.
//
//==========================================================================

#pragma once

//Reference:

#include <cstdint>
#include <cwchar>
#include <climits>
#include <cstdlib>
#include <string>
#include <codecvt>
#include <locale>
#include <vector>
#include <queue>
#include <unordered_set>
#include <unordered_map>
#include <memory>
#include <functional>
#include <stdexcept>
typedef bool Boolean;
typedef std::wstring String;
typedef std::wstring Type;
typedef std::int32_t Int;
typedef double Real;
typedef std::uint8_t Byte;
typedef std::uint8_t UInt8;
typedef std::uint16_t UInt16;
typedef std::uint32_t UInt32;
typedef std::uint64_t UInt64;
typedef std::int8_t Int8;
typedef std::int16_t Int16;
typedef std::int32_t Int32;
typedef std::int64_t Int64;
typedef float Float32;
typedef double Float64;
#ifndef _OPTIONAL_TYPE_
    enum OptionalTag
    {
        OptionalTag_NotHasValue = 0,
        OptionalTag_HasValue = 1
    };
    /* TaggedUnion */
    template<typename T>
    class Optional /* final */
    {
    public:
        /* Tag */ OptionalTag _Tag;

        Unit NotHasValue;
        T HasValue;

        static Optional<T> CreateNotHasValue()
        {
            auto r = Optional<T>();
            r._Tag = OptionalTag_NotHasValue;
            r.NotHasValue = Unit();
            return r;
        }
        static Optional<T> CreateHasValue(T Value)
        {
            auto r = Optional<T>();
            r._Tag = OptionalTag_HasValue;
            r.HasValue = Value;
            return r;
        }

        Boolean OnNotHasValue() const
        {
            return _Tag == OptionalTag_NotHasValue;
        }
        Boolean OnHasValue() const
        {
            return _Tag == OptionalTag_HasValue;
        }

    	static Optional<T> Empty() { return CreateNotHasValue(); }
        Optional()
            : _Tag(OptionalTag_NotHasValue),
              NotHasValue(Unit()),
              HasValue(T())
        {
        }
        Optional(const T &v)
            : _Tag(OptionalTag_HasValue),
              NotHasValue(Unit()),
              HasValue(v)
        {
        }
        Optional(std::nullptr_t v)
            : _Tag(OptionalTag_NotHasValue),
              NotHasValue(Unit()),
              HasValue(T())
        {
        }
        /* explicit operator T() const
        {
            if (OnNotHasValue())
            {
                throw std::logic_error("InvalidOperationException");
            }
            return HasValue;
        } */
        Boolean operator ==(const Optional<T> &Right) const
        {
            return Equals(*this, Right);
        }
        Boolean operator !=(const Optional<T> &Right) const
        {
            return !Equals(*this, Right);
        }
        Boolean operator ==(const T &Right) const
        {
            return Equals(*this, static_cast<const Optional<T> &>(Right));
        }
        Boolean operator !=(const T &Right) const
        {
            return !Equals(*this, static_cast<const Optional<T> &>(Right));
        }
        Boolean operator ==(std::nullptr_t Right) const
        {
            return Equals(*this, Right);
        }
        Boolean operator !=(std::nullptr_t Right) const
        {
            return !Equals(*this, Right);
        }

    private:
        static Boolean Equals(const Optional<T> &Left, const Optional<T> &Right)
        {
            if (Left.OnNotHasValue() && Right.OnNotHasValue())
            {
                return true;
            }
            if (Left.OnNotHasValue() || Right.OnNotHasValue())
            {
                return false;
            }
            return Left.HasValue == Right.HasValue;
        }
        static Boolean Equals(const Optional<T> &Left, std::nullptr_t Right)
        {
            return Left.OnNotHasValue();
        }

    public:
        T Value() const
        {
            if (OnHasValue())
            {
                return HasValue;
            }
            else
            {
                throw std::logic_error("InvalidOperationException");
            }
        }
        T ValueOrDefault(T Default) const
        {
            if (OnHasValue())
            {
                return HasValue;
            }
            else
            {
                return Default;
            }
        }
    };

    namespace std
    {
        template <typename T>
        struct hash<Optional<T>>
        {
            size_t operator()(const Optional<T> &x) const
            {
                if (x.OnNotHasValue()) { return 0; }
                return hash<T>()(x.HasValue);
            }
        };
        template <typename T>
        struct less<Optional<T>>
        {
            bool operator()(const Optional<T> &x, const Optional<T> &y) const
            {
                if ((x == nullptr) && (y == nullptr)) { return false; }
                if (x == nullptr) { return true; }
                if (y == nullptr) { return false; }
                return x.HasValue < y.HasValue;
            }
        };
    }

    #define _OPTIONAL_TYPE_
#endif
namespace Yuki
{
    namespace ExpressionSchema
    {
        class IReadableStream
        {
        public:
            virtual std::uint8_t ReadByte() = 0;
            virtual std::shared_ptr<std::vector<std::uint8_t>> ReadBytes(std::size_t Size) = 0;

            Unit ReadUnit()
            {
                return Unit();
            }
            Boolean ReadBoolean()
            {
                return ReadByte() != 0;
            }

            std::uint8_t ReadUInt8()
            {
                return ReadByte();
            }
            std::uint16_t ReadUInt16()
            {
                std::uint16_t o;
                o = static_cast<std::uint16_t>(static_cast<std::uint16_t>(ReadByte()) & static_cast<std::uint16_t>(0xFF));
                o = static_cast<std::uint16_t>(o | ((static_cast<std::uint16_t>(ReadByte()) & 0xFF) << 8));
                return o;
            }
            std::uint32_t ReadUInt32()
            {
                std::uint32_t o;
                o = static_cast<std::uint32_t>(ReadByte()) & 0xFF;
                o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 8);
                o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 16);
                o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 24);
                return o;
            }
            std::uint64_t ReadUInt64()
            {
                std::uint64_t o;
                o = static_cast<std::uint64_t>(ReadByte()) & 0xFF;
                o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 8);
                o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 16);
                o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 24);
                o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 32);
                o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 40);
                o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 48);
                o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 56);
                return o;
            }
            std::int8_t ReadInt8()
            {
                return static_cast<std::int8_t>(ReadByte());
            }
            std::int16_t ReadInt16()
            {
                std::int16_t o;
                o = static_cast<std::int16_t>(static_cast<std::int16_t>(ReadByte()) & static_cast<std::int16_t>(0xFF));
                o = static_cast<std::int16_t>(o | ((static_cast<std::int16_t>(ReadByte()) & 0xFF) << 8));
                return o;
            }
            std::int32_t ReadInt32()
            {
                std::int32_t o;
                o = static_cast<std::int32_t>(ReadByte()) & 0xFF;
                o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 8);
                o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 16);
                o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 24);
                return o;
            }
            std::int64_t ReadInt64()
            {
                std::int64_t o;
                o = static_cast<std::int64_t>(ReadByte()) & 0xFF;
                o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 8);
                o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 16);
                o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 24);
                o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 32);
                o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 40);
                o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 48);
                o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 56);
                return o;
            }

            float ReadFloat32()
            {
                std::int32_t i = ReadInt32();
                return *reinterpret_cast<float *>(&i);
            }
            double ReadFloat64()
            {
                std::int64_t i = ReadInt64();
                return *reinterpret_cast<double *>(&i);
            }

            String ReadString()
            {
                std::int32_t Length = ReadInt32();
                int n = static_cast<int>(Length);
                std::vector<std::uint8_t> Bytes;
                for (int k = 0; k < n; k += 1)
                {
                    Bytes.push_back(ReadByte());
                }
                std::wstring_convert<std::codecvt_utf16<wchar_t, 0x10FFFF, std::little_endian>, wchar_t> conv;
                return conv.from_bytes(reinterpret_cast<const char *>(Bytes.data()), reinterpret_cast<const char *>(Bytes.data() + Bytes.size()));
            }

            virtual ~IReadableStream() {}
        };

        class IWritableStream
        {
        public:
            virtual void WriteByte(std::uint8_t b) = 0;
            virtual void WriteBytes(std::shared_ptr<std::vector<std::uint8_t>> l) = 0;

            void WriteUnit(Unit v)
            {
            }
            void WriteBoolean(Boolean v)
            {
                if (v)
                {
                    WriteByte(0xFF);
                }
                else
                {
                    WriteByte(0);
                }
            }

            void WriteUInt8(std::uint8_t v)
            {
                WriteByte(v);
            }
            void WriteUInt16(std::uint16_t v)
            {
                WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
            }
            void WriteUInt32(std::uint32_t v)
            {
                WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
            }
            void WriteUInt64(std::uint64_t v)
            {
                WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 32) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 40) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 48) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 56) & 0xFF));
            }
            void WriteInt8(std::int8_t v)
            {
                WriteByte(static_cast<std::uint8_t>(v));
            }
            void WriteInt16(std::int16_t v)
            {
                WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
            }
            void WriteInt32(std::int32_t v)
            {
                WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
            }
            void WriteInt64(std::int64_t v)
            {
                WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 32) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 40) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 48) & 0xFF));
                WriteByte(static_cast<std::uint8_t>((v >> 56) & 0xFF));
            }

            void WriteFloat32(float v)
            {
                WriteInt32(*reinterpret_cast<std::int32_t *>(&v));
            }
            void WriteFloat64(double v)
            {
                WriteInt64(*reinterpret_cast<std::int64_t *>(&v));
            }

            void WriteString(String v)
            {
                std::wstring_convert<std::codecvt_utf16<wchar_t, 0x10FFFF, std::little_endian>, wchar_t> conv;
                auto Bytes = conv.to_bytes(v);
                int n = static_cast<int>(Bytes.size());
                WriteInt32((std::int32_t)(n));
                for (int k = 0; k < n; k += 1)
                {
                    WriteByte(static_cast<std::uint8_t>(Bytes[k]));
                }
            }

            virtual ~IWritableStream() {}
        };

        class IReadableWritableStream : public IReadableStream, public IWritableStream
        {
        public:
            virtual ~IReadableWritableStream() {}
        };

        class ByteArrayStream : public IReadableWritableStream /* final */
        {
        private:
            std::vector<std::uint8_t> Buffer;
            std::size_t Position;
        public:
            ByteArrayStream() : Position(0)
            {
            }

            std::uint8_t ReadByte()
            {
                if (Position + 1 > Buffer.size()) { throw std::out_of_range(""); }
                std::uint8_t b = Buffer[Position];
                Position += 1;
                return b;
            }
            std::shared_ptr<std::vector<std::uint8_t>> ReadBytes(std::size_t Size)
            {
                if (Position + Size > Buffer.size()) { throw std::out_of_range(""); }
                auto l = std::make_shared<std::vector<std::uint8_t>>();
                l->resize(Size, 0);
                if (Size == 0) { return l; }
                std::copy(Buffer.data() + Position, Buffer.data() + Position + Size, l->data());
                Position += Size;
                return l;
            }

            void WriteByte(std::uint8_t b)
            {
                if (Position + 1 > Buffer.size()) { Buffer.resize(Position + 1, 0); }
                Buffer[Position] = b;
                Position += 1;
            }
            void WriteBytes(std::shared_ptr<std::vector<std::uint8_t>> l)
            {
                auto Size = l->size();
                if (Size == 0) { return; }
                if (Position + Size > Buffer.size()) { Buffer.resize(Position + Size, 0); }
                std::copy(l->data(), l->data() + Size, Buffer.data() + Position);
                Position += Size;
            }

            std::size_t GetPosition()
            {
                return Position;
            }

            void SetPosition(std::size_t Position)
            {
                this->Position = Position;
            }

            std::size_t GetLength()
            {
                return Buffer.size();
            }

            void SetLength(std::size_t Length)
            {
                Buffer.resize(Length, 0);
            }
        };

        class BinaryTranslator /* final */
        {
        public:
            static Unit UnitFromBinary(IReadableStream &s)
            {
                return s.ReadUnit();
            }
            static void UnitToBinary(IWritableStream &s, Unit v)
            {
                s.WriteUnit(v);
            }

            static Boolean BooleanFromBinary(IReadableStream &s)
            {
                return s.ReadBoolean();
            }
            static void BooleanToBinary(IWritableStream &s, Boolean v)
            {
                s.WriteBoolean(v);
            }

            static String StringFromBinary(IReadableStream &s)
            {
                return s.ReadString();
            }
            static void StringToBinary(IWritableStream &s, String v)
            {
                s.WriteString(v);
            }

            static Type TypeFromBinary(IReadableStream &s)
            {
                throw std::logic_error("NotSupported");
            }
            static void TypeToBinary(IWritableStream &s, Type v)
            {
                throw std::logic_error("NotSupported");
            }

            static Int IntFromBinary(IReadableStream &s)
            {
                return static_cast<Int>(s.ReadInt32());
            }
            static void IntToBinary(IWritableStream &s, Int v)
            {
                s.WriteInt32(static_cast<Int>(v));
            }

            static Real RealFromBinary(IReadableStream &s)
            {
                return s.ReadFloat64();
            }
            static void RealToBinary(IWritableStream &s, Real v)
            {
                s.WriteFloat64(v);
            }

            static Byte ByteFromBinary(IReadableStream &s)
            {
                return s.ReadByte();
            }
            static void ByteToBinary(IWritableStream &s, Byte v)
            {
                s.WriteByte(v);
            }

            static UInt8 UInt8FromBinary(IReadableStream &s)
            {
                return s.ReadUInt8();
            }
            static void UInt8ToBinary(IWritableStream &s, UInt8 v)
            {
                s.WriteUInt8(v);
            }

            static UInt16 UInt16FromBinary(IReadableStream &s)
            {
                return s.ReadUInt16();
            }
            static void UInt16ToBinary(IWritableStream &s, UInt16 v)
            {
                s.WriteUInt16(v);
            }

            static UInt32 UInt32FromBinary(IReadableStream &s)
            {
                return s.ReadUInt32();
            }
            static void UInt32ToBinary(IWritableStream &s, UInt32 v)
            {
                s.WriteUInt32(v);
            }

            static UInt64 UInt64FromBinary(IReadableStream &s)
            {
                return s.ReadUInt64();
            }
            static void UInt64ToBinary(IWritableStream &s, UInt64 v)
            {
                s.WriteUInt64(v);
            }

            static Int8 Int8FromBinary(IReadableStream &s)
            {
                return s.ReadInt8();
            }
            static void Int8ToBinary(IWritableStream &s, Int8 v)
            {
                s.WriteInt8(v);
            }

            static Int16 Int16FromBinary(IReadableStream &s)
            {
                return s.ReadInt16();
            }
            static void Int16ToBinary(IWritableStream &s, Int16 v)
            {
                s.WriteInt16(v);
            }

            static Int32 Int32FromBinary(IReadableStream &s)
            {
                return s.ReadInt32();
            }
            static void Int32ToBinary(IWritableStream &s, Int32 v)
            {
                s.WriteInt32(v);
            }

            static Int64 Int64FromBinary(IReadableStream &s)
            {
                return s.ReadInt64();
            }
            static void Int64ToBinary(IWritableStream &s, Int64 v)
            {
                s.WriteInt64(v);
            }

            static Float32 Float32FromBinary(IReadableStream &s)
            {
                return s.ReadFloat32();
            }
            static void Float32ToBinary(IWritableStream &s, Float32 v)
            {
                s.WriteFloat32(v);
            }

            static Float64 Float64FromBinary(IReadableStream &s)
            {
                return s.ReadFloat64();
            }
            static void Float64ToBinary(IWritableStream &s, Float64 v)
            {
                s.WriteFloat64(v);
            }

            static std::shared_ptr<class Schema> SchemaFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<Schema>();
                o->Modules = ListOfModuleDeclFromBinary(s);
                o->Imports = ListOfStringFromBinary(s);
                return o;
            }
            static void SchemaToBinary(IWritableStream &s, std::shared_ptr<class Schema> o)
            {
                ListOfModuleDeclToBinary(s, o->Modules);
                ListOfStringToBinary(s, o->Imports);
            }

            static std::shared_ptr<class ModuleDecl> ModuleDeclFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ModuleDecl>();
                o->Name = StringFromBinary(s);
                o->Description = StringFromBinary(s);
                o->Functions = ListOfFunctionDeclFromBinary(s);
                return o;
            }
            static void ModuleDeclToBinary(IWritableStream &s, std::shared_ptr<class ModuleDecl> o)
            {
                StringToBinary(s, o->Name);
                StringToBinary(s, o->Description);
                ListOfFunctionDeclToBinary(s, o->Functions);
            }

            static std::shared_ptr<class Assembly> AssemblyFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<Assembly>();
                o->Hash = UInt64FromBinary(s);
                o->Modules = ListOfModuleDefFromBinary(s);
                return o;
            }
            static void AssemblyToBinary(IWritableStream &s, std::shared_ptr<class Assembly> o)
            {
                UInt64ToBinary(s, o->Hash);
                ListOfModuleDefToBinary(s, o->Modules);
            }

            static std::shared_ptr<class ModuleDef> ModuleDefFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ModuleDef>();
                o->Name = StringFromBinary(s);
                o->Description = StringFromBinary(s);
                o->Functions = ListOfFunctionDefFromBinary(s);
                return o;
            }
            static void ModuleDefToBinary(IWritableStream &s, std::shared_ptr<class ModuleDef> o)
            {
                StringToBinary(s, o->Name);
                StringToBinary(s, o->Description);
                ListOfFunctionDefToBinary(s, o->Functions);
            }

            static std::shared_ptr<class FunctionDecl> FunctionDeclFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<FunctionDecl>();
                o->Name = StringFromBinary(s);
                o->Parameters = ListOfVariableDefFromBinary(s);
                o->ReturnValue = PrimitiveTypeFromBinary(s);
                return o;
            }
            static void FunctionDeclToBinary(IWritableStream &s, std::shared_ptr<class FunctionDecl> o)
            {
                StringToBinary(s, o->Name);
                ListOfVariableDefToBinary(s, o->Parameters);
                PrimitiveTypeToBinary(s, o->ReturnValue);
            }

            static std::shared_ptr<class FunctionDef> FunctionDefFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<FunctionDef>();
                o->Name = StringFromBinary(s);
                o->Parameters = ListOfVariableDefFromBinary(s);
                o->ReturnValue = PrimitiveTypeFromBinary(s);
                o->Body = ExprFromBinary(s);
                return o;
            }
            static void FunctionDefToBinary(IWritableStream &s, std::shared_ptr<class FunctionDef> o)
            {
                StringToBinary(s, o->Name);
                ListOfVariableDefToBinary(s, o->Parameters);
                PrimitiveTypeToBinary(s, o->ReturnValue);
                ExprToBinary(s, o->Body);
            }

            static std::shared_ptr<class VariableDef> VariableDefFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<VariableDef>();
                o->Name = StringFromBinary(s);
                o->Type = PrimitiveTypeFromBinary(s);
                return o;
            }
            static void VariableDefToBinary(IWritableStream &s, std::shared_ptr<class VariableDef> o)
            {
                StringToBinary(s, o->Name);
                PrimitiveTypeToBinary(s, o->Type);
            }

            static ExprTag ExprTagFromBinary(IReadableStream &s)
            {
                return static_cast<ExprTag>(IntFromBinary(s));
            }
            static void ExprTagToBinary(IWritableStream &s, ExprTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }
            static std::shared_ptr<class Expr> ExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<Expr>();
                o->_Tag = ExprTagFromBinary(s);
                if (o->_Tag == ExprTag_Literal)
                {
                    o->Literal = LiteralExprFromBinary(s);
                    return o;
                }
                if (o->_Tag == ExprTag_Variable)
                {
                    o->Variable = VariableExprFromBinary(s);
                    return o;
                }
                if (o->_Tag == ExprTag_Function)
                {
                    o->Function = FunctionExprFromBinary(s);
                    return o;
                }
                if (o->_Tag == ExprTag_If)
                {
                    o->If = IfExprFromBinary(s);
                    return o;
                }
                if (o->_Tag == ExprTag_AndAlso)
                {
                    o->AndAlso = AndAlsoExprFromBinary(s);
                    return o;
                }
                if (o->_Tag == ExprTag_OrElse)
                {
                    o->OrElse = OrElseExprFromBinary(s);
                    return o;
                }
                throw std::logic_error("InvalidOperation");
            }
            static void ExprToBinary(IWritableStream &s, std::shared_ptr<class Expr> o)
            {
                ExprTagToBinary(s, o->_Tag);
                if (o->_Tag == ExprTag_Literal)
                {
                    LiteralExprToBinary(s, o->Literal);
                    return;
                }
                if (o->_Tag == ExprTag_Variable)
                {
                    VariableExprToBinary(s, o->Variable);
                    return;
                }
                if (o->_Tag == ExprTag_Function)
                {
                    FunctionExprToBinary(s, o->Function);
                    return;
                }
                if (o->_Tag == ExprTag_If)
                {
                    IfExprToBinary(s, o->If);
                    return;
                }
                if (o->_Tag == ExprTag_AndAlso)
                {
                    AndAlsoExprToBinary(s, o->AndAlso);
                    return;
                }
                if (o->_Tag == ExprTag_OrElse)
                {
                    OrElseExprToBinary(s, o->OrElse);
                    return;
                }
                throw std::logic_error("InvalidOperation");
            }

            static LiteralExprTag LiteralExprTagFromBinary(IReadableStream &s)
            {
                return static_cast<LiteralExprTag>(IntFromBinary(s));
            }
            static void LiteralExprTagToBinary(IWritableStream &s, LiteralExprTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }
            static std::shared_ptr<class LiteralExpr> LiteralExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<LiteralExpr>();
                o->_Tag = LiteralExprTagFromBinary(s);
                if (o->_Tag == LiteralExprTag_BooleanValue)
                {
                    o->BooleanValue = BooleanFromBinary(s);
                    return o;
                }
                if (o->_Tag == LiteralExprTag_IntValue)
                {
                    o->IntValue = IntFromBinary(s);
                    return o;
                }
                if (o->_Tag == LiteralExprTag_RealValue)
                {
                    o->RealValue = RealFromBinary(s);
                    return o;
                }
                throw std::logic_error("InvalidOperation");
            }
            static void LiteralExprToBinary(IWritableStream &s, std::shared_ptr<class LiteralExpr> o)
            {
                LiteralExprTagToBinary(s, o->_Tag);
                if (o->_Tag == LiteralExprTag_BooleanValue)
                {
                    BooleanToBinary(s, o->BooleanValue);
                    return;
                }
                if (o->_Tag == LiteralExprTag_IntValue)
                {
                    IntToBinary(s, o->IntValue);
                    return;
                }
                if (o->_Tag == LiteralExprTag_RealValue)
                {
                    RealToBinary(s, o->RealValue);
                    return;
                }
                throw std::logic_error("InvalidOperation");
            }

            static std::shared_ptr<class VariableExpr> VariableExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<VariableExpr>();
                o->Name = StringFromBinary(s);
                return o;
            }
            static void VariableExprToBinary(IWritableStream &s, std::shared_ptr<class VariableExpr> o)
            {
                StringToBinary(s, o->Name);
            }

            static std::shared_ptr<class FunctionExpr> FunctionExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<FunctionExpr>();
                o->Name = StringFromBinary(s);
                o->Parameters = ListOfExprFromBinary(s);
                return o;
            }
            static void FunctionExprToBinary(IWritableStream &s, std::shared_ptr<class FunctionExpr> o)
            {
                StringToBinary(s, o->Name);
                ListOfExprToBinary(s, o->Parameters);
            }

            static std::shared_ptr<class IfExpr> IfExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<IfExpr>();
                o->Condition = ExprFromBinary(s);
                o->TruePart = ExprFromBinary(s);
                o->FalsePart = ExprFromBinary(s);
                return o;
            }
            static void IfExprToBinary(IWritableStream &s, std::shared_ptr<class IfExpr> o)
            {
                ExprToBinary(s, o->Condition);
                ExprToBinary(s, o->TruePart);
                ExprToBinary(s, o->FalsePart);
            }

            static std::shared_ptr<class AndAlsoExpr> AndAlsoExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<AndAlsoExpr>();
                o->Left = ExprFromBinary(s);
                o->Right = ExprFromBinary(s);
                return o;
            }
            static void AndAlsoExprToBinary(IWritableStream &s, std::shared_ptr<class AndAlsoExpr> o)
            {
                ExprToBinary(s, o->Left);
                ExprToBinary(s, o->Right);
            }

            static std::shared_ptr<class OrElseExpr> OrElseExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<OrElseExpr>();
                o->Left = ExprFromBinary(s);
                o->Right = ExprFromBinary(s);
                return o;
            }
            static void OrElseExprToBinary(IWritableStream &s, std::shared_ptr<class OrElseExpr> o)
            {
                ExprToBinary(s, o->Left);
                ExprToBinary(s, o->Right);
            }

            static PrimitiveType PrimitiveTypeFromBinary(IReadableStream &s)
            {
                return static_cast<PrimitiveType>(IntFromBinary(s));
            }
            static void PrimitiveTypeToBinary(IWritableStream &s, PrimitiveType o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }

            static TokenLiteralTag TokenLiteralTagFromBinary(IReadableStream &s)
            {
                return static_cast<TokenLiteralTag>(IntFromBinary(s));
            }
            static void TokenLiteralTagToBinary(IWritableStream &s, TokenLiteralTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }
            static std::shared_ptr<class TokenLiteral> TokenLiteralFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<TokenLiteral>();
                o->_Tag = TokenLiteralTagFromBinary(s);
                if (o->_Tag == TokenLiteralTag_BooleanValue)
                {
                    o->BooleanValue = BooleanFromBinary(s);
                    return o;
                }
                if (o->_Tag == TokenLiteralTag_IntValue)
                {
                    o->IntValue = IntFromBinary(s);
                    return o;
                }
                if (o->_Tag == TokenLiteralTag_RealValue)
                {
                    o->RealValue = RealFromBinary(s);
                    return o;
                }
                throw std::logic_error("InvalidOperation");
            }
            static void TokenLiteralToBinary(IWritableStream &s, std::shared_ptr<class TokenLiteral> o)
            {
                TokenLiteralTagToBinary(s, o->_Tag);
                if (o->_Tag == TokenLiteralTag_BooleanValue)
                {
                    BooleanToBinary(s, o->BooleanValue);
                    return;
                }
                if (o->_Tag == TokenLiteralTag_IntValue)
                {
                    IntToBinary(s, o->IntValue);
                    return;
                }
                if (o->_Tag == TokenLiteralTag_RealValue)
                {
                    RealToBinary(s, o->RealValue);
                    return;
                }
                throw std::logic_error("InvalidOperation");
            }

            static std::shared_ptr<class TokenIdentifier> TokenIdentifierFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<TokenIdentifier>();
                o->Name = StringFromBinary(s);
                return o;
            }
            static void TokenIdentifierToBinary(IWritableStream &s, std::shared_ptr<class TokenIdentifier> o)
            {
                StringToBinary(s, o->Name);
            }

            static std::shared_ptr<class TokenBinaryOperator> TokenBinaryOperatorFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<TokenBinaryOperator>();
                o->Name = StringFromBinary(s);
                return o;
            }
            static void TokenBinaryOperatorToBinary(IWritableStream &s, std::shared_ptr<class TokenBinaryOperator> o)
            {
                StringToBinary(s, o->Name);
            }

            static std::shared_ptr<class TokenUnaryOperator> TokenUnaryOperatorFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<TokenUnaryOperator>();
                o->Name = StringFromBinary(s);
                return o;
            }
            static void TokenUnaryOperatorToBinary(IWritableStream &s, std::shared_ptr<class TokenUnaryOperator> o)
            {
                StringToBinary(s, o->Name);
            }

            static std::shared_ptr<class TokenLeftParen> TokenLeftParenFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<TokenLeftParen>();
                return o;
            }
            static void TokenLeftParenToBinary(IWritableStream &s, std::shared_ptr<class TokenLeftParen> o)
            {
            }

            static std::shared_ptr<class TokenRightParen> TokenRightParenFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<TokenRightParen>();
                return o;
            }
            static void TokenRightParenToBinary(IWritableStream &s, std::shared_ptr<class TokenRightParen> o)
            {
            }

            static std::shared_ptr<class TokenComma> TokenCommaFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<TokenComma>();
                return o;
            }
            static void TokenCommaToBinary(IWritableStream &s, std::shared_ptr<class TokenComma> o)
            {
            }

            static SyntaxExprTag SyntaxExprTagFromBinary(IReadableStream &s)
            {
                return static_cast<SyntaxExprTag>(IntFromBinary(s));
            }
            static void SyntaxExprTagToBinary(IWritableStream &s, SyntaxExprTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }
            static std::shared_ptr<class SyntaxExpr> SyntaxExprFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<SyntaxExpr>();
                o->_Tag = SyntaxExprTagFromBinary(s);
                if (o->_Tag == SyntaxExprTag_Literal)
                {
                    o->Literal = ProductionLiteralFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxExprTag_Function)
                {
                    o->Function = ProductionFunctionFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxExprTag_Variable)
                {
                    o->Variable = ProductionVariableFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxExprTag_Paren)
                {
                    o->Paren = ProductionParenFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxExprTag_UnaryOperator)
                {
                    o->UnaryOperator = ProductionUnaryOperatorFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxExprTag_BinaryOperator)
                {
                    o->BinaryOperator = ProductionBinaryOperatorFromBinary(s);
                    return o;
                }
                throw std::logic_error("InvalidOperation");
            }
            static void SyntaxExprToBinary(IWritableStream &s, std::shared_ptr<class SyntaxExpr> o)
            {
                SyntaxExprTagToBinary(s, o->_Tag);
                if (o->_Tag == SyntaxExprTag_Literal)
                {
                    ProductionLiteralToBinary(s, o->Literal);
                    return;
                }
                if (o->_Tag == SyntaxExprTag_Function)
                {
                    ProductionFunctionToBinary(s, o->Function);
                    return;
                }
                if (o->_Tag == SyntaxExprTag_Variable)
                {
                    ProductionVariableToBinary(s, o->Variable);
                    return;
                }
                if (o->_Tag == SyntaxExprTag_Paren)
                {
                    ProductionParenToBinary(s, o->Paren);
                    return;
                }
                if (o->_Tag == SyntaxExprTag_UnaryOperator)
                {
                    ProductionUnaryOperatorToBinary(s, o->UnaryOperator);
                    return;
                }
                if (o->_Tag == SyntaxExprTag_BinaryOperator)
                {
                    ProductionBinaryOperatorToBinary(s, o->BinaryOperator);
                    return;
                }
                throw std::logic_error("InvalidOperation");
            }

            static SyntaxParameterListTag SyntaxParameterListTagFromBinary(IReadableStream &s)
            {
                return static_cast<SyntaxParameterListTag>(IntFromBinary(s));
            }
            static void SyntaxParameterListTagToBinary(IWritableStream &s, SyntaxParameterListTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }
            static std::shared_ptr<class SyntaxParameterList> SyntaxParameterListFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<SyntaxParameterList>();
                o->_Tag = SyntaxParameterListTagFromBinary(s);
                if (o->_Tag == SyntaxParameterListTag_Null)
                {
                    o->Null = ProductionNullParameterListFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxParameterListTag_Nonnull)
                {
                    o->Nonnull = ProductionNonnullParameterListFromBinary(s);
                    return o;
                }
                throw std::logic_error("InvalidOperation");
            }
            static void SyntaxParameterListToBinary(IWritableStream &s, std::shared_ptr<class SyntaxParameterList> o)
            {
                SyntaxParameterListTagToBinary(s, o->_Tag);
                if (o->_Tag == SyntaxParameterListTag_Null)
                {
                    ProductionNullParameterListToBinary(s, o->Null);
                    return;
                }
                if (o->_Tag == SyntaxParameterListTag_Nonnull)
                {
                    ProductionNonnullParameterListToBinary(s, o->Nonnull);
                    return;
                }
                throw std::logic_error("InvalidOperation");
            }

            static SyntaxNonnullParameterListTag SyntaxNonnullParameterListTagFromBinary(IReadableStream &s)
            {
                return static_cast<SyntaxNonnullParameterListTag>(IntFromBinary(s));
            }
            static void SyntaxNonnullParameterListTagToBinary(IWritableStream &s, SyntaxNonnullParameterListTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }
            static std::shared_ptr<class SyntaxNonnullParameterList> SyntaxNonnullParameterListFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<SyntaxNonnullParameterList>();
                o->_Tag = SyntaxNonnullParameterListTagFromBinary(s);
                if (o->_Tag == SyntaxNonnullParameterListTag_Single)
                {
                    o->Single = ProductionSingleParameterListFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxNonnullParameterListTag_Multiple)
                {
                    o->Multiple = ProductionMultipleParameterListFromBinary(s);
                    return o;
                }
                throw std::logic_error("InvalidOperation");
            }
            static void SyntaxNonnullParameterListToBinary(IWritableStream &s, std::shared_ptr<class SyntaxNonnullParameterList> o)
            {
                SyntaxNonnullParameterListTagToBinary(s, o->_Tag);
                if (o->_Tag == SyntaxNonnullParameterListTag_Single)
                {
                    ProductionSingleParameterListToBinary(s, o->Single);
                    return;
                }
                if (o->_Tag == SyntaxNonnullParameterListTag_Multiple)
                {
                    ProductionMultipleParameterListToBinary(s, o->Multiple);
                    return;
                }
                throw std::logic_error("InvalidOperation");
            }

            static std::shared_ptr<class ProductionLiteral> ProductionLiteralFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionLiteral>();
                o->Literal = TokenLiteralFromBinary(s);
                return o;
            }
            static void ProductionLiteralToBinary(IWritableStream &s, std::shared_ptr<class ProductionLiteral> o)
            {
                TokenLiteralToBinary(s, o->Literal);
            }

            static std::shared_ptr<class ProductionFunction> ProductionFunctionFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionFunction>();
                o->Identifier = TokenIdentifierFromBinary(s);
                o->ParameterList = SyntaxParameterListFromBinary(s);
                return o;
            }
            static void ProductionFunctionToBinary(IWritableStream &s, std::shared_ptr<class ProductionFunction> o)
            {
                TokenIdentifierToBinary(s, o->Identifier);
                SyntaxParameterListToBinary(s, o->ParameterList);
            }

            static std::shared_ptr<class ProductionVariable> ProductionVariableFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionVariable>();
                o->Identifier = TokenIdentifierFromBinary(s);
                return o;
            }
            static void ProductionVariableToBinary(IWritableStream &s, std::shared_ptr<class ProductionVariable> o)
            {
                TokenIdentifierToBinary(s, o->Identifier);
            }

            static std::shared_ptr<class ProductionParen> ProductionParenFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionParen>();
                o->Expr = SyntaxExprFromBinary(s);
                return o;
            }
            static void ProductionParenToBinary(IWritableStream &s, std::shared_ptr<class ProductionParen> o)
            {
                SyntaxExprToBinary(s, o->Expr);
            }

            static std::shared_ptr<class ProductionUnaryOperator> ProductionUnaryOperatorFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionUnaryOperator>();
                o->UnaryOperator = TokenUnaryOperatorFromBinary(s);
                o->Expr = SyntaxExprFromBinary(s);
                return o;
            }
            static void ProductionUnaryOperatorToBinary(IWritableStream &s, std::shared_ptr<class ProductionUnaryOperator> o)
            {
                TokenUnaryOperatorToBinary(s, o->UnaryOperator);
                SyntaxExprToBinary(s, o->Expr);
            }

            static std::shared_ptr<class ProductionBinaryOperator> ProductionBinaryOperatorFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionBinaryOperator>();
                o->BinaryOperator = TokenBinaryOperatorFromBinary(s);
                o->Left = SyntaxExprFromBinary(s);
                o->Right = SyntaxExprFromBinary(s);
                return o;
            }
            static void ProductionBinaryOperatorToBinary(IWritableStream &s, std::shared_ptr<class ProductionBinaryOperator> o)
            {
                TokenBinaryOperatorToBinary(s, o->BinaryOperator);
                SyntaxExprToBinary(s, o->Left);
                SyntaxExprToBinary(s, o->Right);
            }

            static std::shared_ptr<class ProductionNullParameterList> ProductionNullParameterListFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionNullParameterList>();
                return o;
            }
            static void ProductionNullParameterListToBinary(IWritableStream &s, std::shared_ptr<class ProductionNullParameterList> o)
            {
            }

            static std::shared_ptr<class ProductionNonnullParameterList> ProductionNonnullParameterListFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionNonnullParameterList>();
                o->NonnullParameterList = SyntaxNonnullParameterListFromBinary(s);
                return o;
            }
            static void ProductionNonnullParameterListToBinary(IWritableStream &s, std::shared_ptr<class ProductionNonnullParameterList> o)
            {
                SyntaxNonnullParameterListToBinary(s, o->NonnullParameterList);
            }

            static std::shared_ptr<class ProductionSingleParameterList> ProductionSingleParameterListFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionSingleParameterList>();
                o->Expr = SyntaxExprFromBinary(s);
                return o;
            }
            static void ProductionSingleParameterListToBinary(IWritableStream &s, std::shared_ptr<class ProductionSingleParameterList> o)
            {
                SyntaxExprToBinary(s, o->Expr);
            }

            static std::shared_ptr<class ProductionMultipleParameterList> ProductionMultipleParameterListFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<ProductionMultipleParameterList>();
                o->NonnullParameterList = SyntaxNonnullParameterListFromBinary(s);
                o->Expr = SyntaxExprFromBinary(s);
                return o;
            }
            static void ProductionMultipleParameterListToBinary(IWritableStream &s, std::shared_ptr<class ProductionMultipleParameterList> o)
            {
                SyntaxNonnullParameterListToBinary(s, o->NonnullParameterList);
                SyntaxExprToBinary(s, o->Expr);
            }

            static SyntaxRuleTag SyntaxRuleTagFromBinary(IReadableStream &s)
            {
                return static_cast<SyntaxRuleTag>(IntFromBinary(s));
            }
            static void SyntaxRuleTagToBinary(IWritableStream &s, SyntaxRuleTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }
            static std::shared_ptr<class SyntaxRule> SyntaxRuleFromBinary(IReadableStream &s)
            {
                auto o = std::make_shared<SyntaxRule>();
                o->_Tag = SyntaxRuleTagFromBinary(s);
                if (o->_Tag == SyntaxRuleTag_Literal)
                {
                    o->Literal = TokenLiteralFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_Identifier)
                {
                    o->Identifier = TokenIdentifierFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_BinaryOperator)
                {
                    o->BinaryOperator = TokenBinaryOperatorFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_UnaryOperator)
                {
                    o->UnaryOperator = TokenUnaryOperatorFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_LeftParen)
                {
                    o->LeftParen = TokenLeftParenFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_RightParen)
                {
                    o->RightParen = TokenRightParenFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_Comma)
                {
                    o->Comma = TokenCommaFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_Expr)
                {
                    o->Expr = SyntaxExprFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_ParameterList)
                {
                    o->ParameterList = SyntaxParameterListFromBinary(s);
                    return o;
                }
                if (o->_Tag == SyntaxRuleTag_NonnullParameterList)
                {
                    o->NonnullParameterList = SyntaxNonnullParameterListFromBinary(s);
                    return o;
                }
                throw std::logic_error("InvalidOperation");
            }
            static void SyntaxRuleToBinary(IWritableStream &s, std::shared_ptr<class SyntaxRule> o)
            {
                SyntaxRuleTagToBinary(s, o->_Tag);
                if (o->_Tag == SyntaxRuleTag_Literal)
                {
                    TokenLiteralToBinary(s, o->Literal);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_Identifier)
                {
                    TokenIdentifierToBinary(s, o->Identifier);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_BinaryOperator)
                {
                    TokenBinaryOperatorToBinary(s, o->BinaryOperator);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_UnaryOperator)
                {
                    TokenUnaryOperatorToBinary(s, o->UnaryOperator);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_LeftParen)
                {
                    TokenLeftParenToBinary(s, o->LeftParen);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_RightParen)
                {
                    TokenRightParenToBinary(s, o->RightParen);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_Comma)
                {
                    TokenCommaToBinary(s, o->Comma);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_Expr)
                {
                    SyntaxExprToBinary(s, o->Expr);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_ParameterList)
                {
                    SyntaxParameterListToBinary(s, o->ParameterList);
                    return;
                }
                if (o->_Tag == SyntaxRuleTag_NonnullParameterList)
                {
                    SyntaxNonnullParameterListToBinary(s, o->NonnullParameterList);
                    return;
                }
                throw std::logic_error("InvalidOperation");
            }

            static OptionalTag OptionalTagFromBinary(IReadableStream &s)
            {
                return static_cast<OptionalTag>(IntFromBinary(s));
            }
            static void OptionalTagToBinary(IWritableStream &s, OptionalTag o)
            {
                IntToBinary(s, static_cast<Int>(o));
            }

            static std::shared_ptr<class std::vector<std::shared_ptr<class VariableDef>>> ListOfVariableDefFromBinary(IReadableStream &s)
            {
                auto l = std::make_shared<std::vector<std::shared_ptr<class VariableDef>>>();
                int Length = static_cast<int>(IntFromBinary(s));
                for (int k = 0; k < Length; k += 1)
                {
                    l->push_back(VariableDefFromBinary(s));
                }
                return l;
            }
            static void ListOfVariableDefToBinary(IWritableStream &s, std::shared_ptr<class std::vector<std::shared_ptr<class VariableDef>>> l)
            {
                int Length = static_cast<int>(l->size());
                IntToBinary(s, static_cast<Int>(Length));
                for (int k = 0; k < Length; k += 1)
                {
                    VariableDefToBinary(s, (*l)[k]);
                }
            }

            static std::shared_ptr<class std::vector<std::shared_ptr<class FunctionDecl>>> ListOfFunctionDeclFromBinary(IReadableStream &s)
            {
                auto l = std::make_shared<std::vector<std::shared_ptr<class FunctionDecl>>>();
                int Length = static_cast<int>(IntFromBinary(s));
                for (int k = 0; k < Length; k += 1)
                {
                    l->push_back(FunctionDeclFromBinary(s));
                }
                return l;
            }
            static void ListOfFunctionDeclToBinary(IWritableStream &s, std::shared_ptr<class std::vector<std::shared_ptr<class FunctionDecl>>> l)
            {
                int Length = static_cast<int>(l->size());
                IntToBinary(s, static_cast<Int>(Length));
                for (int k = 0; k < Length; k += 1)
                {
                    FunctionDeclToBinary(s, (*l)[k]);
                }
            }

            static std::shared_ptr<class std::vector<std::shared_ptr<class ModuleDecl>>> ListOfModuleDeclFromBinary(IReadableStream &s)
            {
                auto l = std::make_shared<std::vector<std::shared_ptr<class ModuleDecl>>>();
                int Length = static_cast<int>(IntFromBinary(s));
                for (int k = 0; k < Length; k += 1)
                {
                    l->push_back(ModuleDeclFromBinary(s));
                }
                return l;
            }
            static void ListOfModuleDeclToBinary(IWritableStream &s, std::shared_ptr<class std::vector<std::shared_ptr<class ModuleDecl>>> l)
            {
                int Length = static_cast<int>(l->size());
                IntToBinary(s, static_cast<Int>(Length));
                for (int k = 0; k < Length; k += 1)
                {
                    ModuleDeclToBinary(s, (*l)[k]);
                }
            }

            static std::shared_ptr<class std::vector<String>> ListOfStringFromBinary(IReadableStream &s)
            {
                auto l = std::make_shared<std::vector<String>>();
                int Length = static_cast<int>(IntFromBinary(s));
                for (int k = 0; k < Length; k += 1)
                {
                    l->push_back(StringFromBinary(s));
                }
                return l;
            }
            static void ListOfStringToBinary(IWritableStream &s, std::shared_ptr<class std::vector<String>> l)
            {
                int Length = static_cast<int>(l->size());
                IntToBinary(s, static_cast<Int>(Length));
                for (int k = 0; k < Length; k += 1)
                {
                    StringToBinary(s, (*l)[k]);
                }
            }

            static std::shared_ptr<class std::vector<std::shared_ptr<class Expr>>> ListOfExprFromBinary(IReadableStream &s)
            {
                auto l = std::make_shared<std::vector<std::shared_ptr<class Expr>>>();
                int Length = static_cast<int>(IntFromBinary(s));
                for (int k = 0; k < Length; k += 1)
                {
                    l->push_back(ExprFromBinary(s));
                }
                return l;
            }
            static void ListOfExprToBinary(IWritableStream &s, std::shared_ptr<class std::vector<std::shared_ptr<class Expr>>> l)
            {
                int Length = static_cast<int>(l->size());
                IntToBinary(s, static_cast<Int>(Length));
                for (int k = 0; k < Length; k += 1)
                {
                    ExprToBinary(s, (*l)[k]);
                }
            }

            static std::shared_ptr<class std::vector<std::shared_ptr<class FunctionDef>>> ListOfFunctionDefFromBinary(IReadableStream &s)
            {
                auto l = std::make_shared<std::vector<std::shared_ptr<class FunctionDef>>>();
                int Length = static_cast<int>(IntFromBinary(s));
                for (int k = 0; k < Length; k += 1)
                {
                    l->push_back(FunctionDefFromBinary(s));
                }
                return l;
            }
            static void ListOfFunctionDefToBinary(IWritableStream &s, std::shared_ptr<class std::vector<std::shared_ptr<class FunctionDef>>> l)
            {
                int Length = static_cast<int>(l->size());
                IntToBinary(s, static_cast<Int>(Length));
                for (int k = 0; k < Length; k += 1)
                {
                    FunctionDefToBinary(s, (*l)[k]);
                }
            }

            static std::shared_ptr<class std::vector<std::shared_ptr<class ModuleDef>>> ListOfModuleDefFromBinary(IReadableStream &s)
            {
                auto l = std::make_shared<std::vector<std::shared_ptr<class ModuleDef>>>();
                int Length = static_cast<int>(IntFromBinary(s));
                for (int k = 0; k < Length; k += 1)
                {
                    l->push_back(ModuleDefFromBinary(s));
                }
                return l;
            }
            static void ListOfModuleDefToBinary(IWritableStream &s, std::shared_ptr<class std::vector<std::shared_ptr<class ModuleDef>>> l)
            {
                int Length = static_cast<int>(l->size());
                IntToBinary(s, static_cast<Int>(Length));
                for (int k = 0; k < Length; k += 1)
                {
                    ModuleDefToBinary(s, (*l)[k]);
                }
            }
        };
    }
}
