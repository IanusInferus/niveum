//==========================================================================
//
//  Notice:      This file is automatically generated.
//               Please don't modify this file.
//
//==========================================================================

#pragma once

//Reference:

#include <cstddef>
#include <cstdint>
#include <string>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <memory>
#include <functional>
#include <stdexcept>
#ifndef _UNIT_TYPE_
    typedef struct {} Unit;
    #define _UNIT_TYPE_
#endif
typedef bool Boolean;
typedef std::wstring String;
typedef std::wstring Type;
typedef std::int32_t Int;
typedef double Real;
typedef std::uint8_t Byte;
typedef std::uint8_t UInt8;
typedef std::uint16_t UInt16;
typedef std::uint32_t UInt32;
typedef std::uint64_t UInt64;
typedef std::int8_t Int8;
typedef std::int16_t Int16;
typedef std::int32_t Int32;
typedef std::int64_t Int64;
typedef float Float32;
typedef double Float64;
#ifndef _OPTIONAL_TYPE_
    enum OptionalTag
    {
        OptionalTag_NotHasValue = 0,
        OptionalTag_HasValue = 1
    };
    /* TaggedUnion */
    template<typename T>
    class Optional /* final */
    {
    public:
        /* Tag */ OptionalTag _Tag;

        Unit NotHasValue;
        T HasValue;

        static Optional<T> CreateNotHasValue()
        {
            auto r = Optional<T>();
            r._Tag = OptionalTag_NotHasValue;
            r.NotHasValue = Unit();
            return r;
        }
        static Optional<T> CreateHasValue(T Value)
        {
            auto r = Optional<T>();
            r._Tag = OptionalTag_HasValue;
            r.HasValue = Value;
            return r;
        }

        Boolean OnNotHasValue() const
        {
            return _Tag == OptionalTag_NotHasValue;
        }
        Boolean OnHasValue() const
        {
            return _Tag == OptionalTag_HasValue;
        }

    	static Optional<T> Empty() { return CreateNotHasValue(); }
        Optional()
            : _Tag(OptionalTag_NotHasValue),
              NotHasValue(Unit()),
              HasValue(T())
        {
        }
        Optional(const T &v)
            : _Tag(OptionalTag_HasValue),
              NotHasValue(Unit()),
              HasValue(v)
        {
        }
        Optional(std::nullptr_t v)
            : _Tag(OptionalTag_NotHasValue),
              NotHasValue(Unit()),
              HasValue(T())
        {
        }
        /* explicit operator T() const
        {
            if (OnNotHasValue())
            {
                throw std::logic_error("InvalidOperationException");
            }
            return HasValue;
        } */
        Boolean operator ==(const Optional<T> &Right) const
        {
            return Equals(*this, Right);
        }
        Boolean operator !=(const Optional<T> &Right) const
        {
            return !Equals(*this, Right);
        }
        Boolean operator ==(const T &Right) const
        {
            return Equals(*this, static_cast<const Optional<T> &>(Right));
        }
        Boolean operator !=(const T &Right) const
        {
            return !Equals(*this, static_cast<const Optional<T> &>(Right));
        }
        Boolean operator ==(std::nullptr_t Right) const
        {
            return Equals(*this, Right);
        }
        Boolean operator !=(std::nullptr_t Right) const
        {
            return !Equals(*this, Right);
        }

    private:
        static Boolean Equals(const Optional<T> &Left, const Optional<T> &Right)
        {
            if (Left.OnNotHasValue() && Right.OnNotHasValue())
            {
                return true;
            }
            if (Left.OnNotHasValue() || Right.OnNotHasValue())
            {
                return false;
            }
            return Left.HasValue == Right.HasValue;
        }
        static Boolean Equals(const Optional<T> &Left, std::nullptr_t Right)
        {
            return Left.OnNotHasValue();
        }

    public:
        T Value() const
        {
            if (OnHasValue())
            {
                return HasValue;
            }
            else
            {
                throw std::logic_error("InvalidOperationException");
            }
        }
        T ValueOrDefault(T Default) const
        {
            if (OnHasValue())
            {
                return HasValue;
            }
            else
            {
                return Default;
            }
        }
    };

    namespace std
    {
        template <typename T>
        struct hash<Optional<T>>
        {
            size_t operator()(const Optional<T> &x) const
            {
                if (x.OnNotHasValue()) { return 0; }
                return hash<T>()(x.HasValue);
            }
        };
        template <typename T>
        struct less<Optional<T>>
        {
            bool operator()(const Optional<T> &x, const Optional<T> &y) const
            {
                if ((x == nullptr) && (y == nullptr)) { return false; }
                if (x == nullptr) { return true; }
                if (y == nullptr) { return false; }
                return x.HasValue < y.HasValue;
            }
        };
    }

    #define _OPTIONAL_TYPE_
#endif
namespace Yuki
{
    namespace ExpressionSchema
    {
        /// <summary>基元类型</summary>
        enum PrimitiveType : Int
        {
            /// <summary>布尔类型</summary>
            PrimitiveType_Boolean = 0,
            /// <summary>整数类型</summary>
            PrimitiveType_Int = 1,
            /// <summary>实数类型</summary>
            PrimitiveType_Real = 2
        };

        class Schema;
        class ModuleDecl;
        class Assembly;
        class ModuleDef;
        class FunctionDecl;
        class FunctionDef;
        class VariableDef;
        class Expr;
        class LiteralExpr;
        class VariableExpr;
        class FunctionExpr;
        class IfExpr;
        class AndAlsoExpr;
        class OrElseExpr;
        class TokenLiteral;
        class TokenIdentifier;
        class TokenBinaryOperator;
        class TokenUnaryOperator;
        class TokenLeftParen;
        class TokenRightParen;
        class TokenComma;
        class SyntaxExpr;
        class SyntaxParameterList;
        class SyntaxNonnullParameterList;
        class ProductionLiteral;
        class ProductionFunction;
        class ProductionVariable;
        class ProductionParen;
        class ProductionUnaryOperator;
        class ProductionBinaryOperator;
        class ProductionNullParameterList;
        class ProductionNonnullParameterList;
        class ProductionSingleParameterList;
        class ProductionMultipleParameterList;
        class SyntaxRule;
    }
}
namespace std
{
    template <>
    struct hash<Yuki::ExpressionSchema::PrimitiveType>
    {
        size_t operator()(const Yuki::ExpressionSchema::PrimitiveType &x) const
        {
            return hash<Int>()(x);
        }
    };
    template <>
    struct less<Yuki::ExpressionSchema::PrimitiveType>
    {
        bool operator()(const Yuki::ExpressionSchema::PrimitiveType &x, const Yuki::ExpressionSchema::PrimitiveType &y) const
        {
            return less<Int>()(x, y);
        }
    };
}
namespace Yuki
{
    namespace ExpressionSchema
    {
        /// <summary>表达式结构</summary>
        /* Record */
        class Schema /* final */
        {
        public:
            /// <summary>模块声明</summary>
            std::shared_ptr<class std::vector<std::shared_ptr<class ModuleDecl>>> Modules;
            /// <summary>命名空间导入</summary>
            std::shared_ptr<class std::vector<String>> Imports;
        };

        /// <summary>模块声明</summary>
        /* Record */
        class ModuleDecl /* final */
        {
        public:
            /// <summary>名称</summary>
            String Name;
            /// <summary>描述</summary>
            String Description;
            /// <summary>函数声明</summary>
            std::shared_ptr<class std::vector<std::shared_ptr<class FunctionDecl>>> Functions;
        };

        /// <summary>函数集</summary>
        /* Record */
        class Assembly /* final */
        {
        public:
            /// <summary>散列</summary>
            UInt64 Hash;
            /// <summary>函数定义</summary>
            std::shared_ptr<class std::vector<std::shared_ptr<class ModuleDef>>> Modules;
        };

        /// <summary>模块定义</summary>
        /* Record */
        class ModuleDef /* final */
        {
        public:
            /// <summary>名称</summary>
            String Name;
            /// <summary>描述</summary>
            String Description;
            /// <summary>函数定义</summary>
            std::shared_ptr<class std::vector<std::shared_ptr<class FunctionDef>>> Functions;
        };

        /// <summary>函数声明</summary>
        /* Record */
        class FunctionDecl /* final */
        {
        public:
            /// <summary>函数名</summary>
            String Name;
            /// <summary>参数</summary>
            std::shared_ptr<class std::vector<std::shared_ptr<class VariableDef>>> Parameters;
            /// <summary>返回值类型</summary>
            enum PrimitiveType ReturnValue;
        };

        /// <summary>函数定义</summary>
        /* Record */
        class FunctionDef /* final */
        {
        public:
            /// <summary>函数名</summary>
            String Name;
            /// <summary>参数</summary>
            std::shared_ptr<class std::vector<std::shared_ptr<class VariableDef>>> Parameters;
            /// <summary>返回值类型</summary>
            enum PrimitiveType ReturnValue;
            /// <summary>函数体</summary>
            std::shared_ptr<class Expr> Body;
        };

        /// <summary>变量</summary>
        /* Record */
        class VariableDef /* final */
        {
        public:
            /// <summary>变量名</summary>
            String Name;
            /// <summary>类型</summary>
            enum PrimitiveType Type;
        };

        enum ExprTag
        {
            /// <summary>字面量表达式</summary>
            ExprTag_Literal = 0,
            /// <summary>变量表达式</summary>
            ExprTag_Variable = 1,
            /// <summary>函数表达式</summary>
            ExprTag_Function = 2,
            /// <summary>if伪函数表达式</summary>
            ExprTag_If = 3,
            /// <summary>&amp;&amp;运算符表达式</summary>
            ExprTag_AndAlso = 4,
            /// <summary>||运算符表达式</summary>
            ExprTag_OrElse = 5
        };
        /// <summary>表达式</summary>
        /* TaggedUnion */
        class Expr /* final */
        {
        public:
            /* Tag */ ExprTag _Tag;

            /// <summary>字面量表达式</summary>
            std::shared_ptr<class LiteralExpr> Literal;
            /// <summary>变量表达式</summary>
            std::shared_ptr<class VariableExpr> Variable;
            /// <summary>函数表达式</summary>
            std::shared_ptr<class FunctionExpr> Function;
            /// <summary>if伪函数表达式</summary>
            std::shared_ptr<class IfExpr> If;
            /// <summary>&amp;&amp;运算符表达式</summary>
            std::shared_ptr<class AndAlsoExpr> AndAlso;
            /// <summary>||运算符表达式</summary>
            std::shared_ptr<class OrElseExpr> OrElse;

            /// <summary>字面量表达式</summary>
            static std::shared_ptr<class Expr> CreateLiteral(std::shared_ptr<class LiteralExpr> Value)
            {
                auto r = std::make_shared<Expr>();
                r->_Tag = ExprTag_Literal;
                r->Literal = Value;
                return r;
            }
            /// <summary>变量表达式</summary>
            static std::shared_ptr<class Expr> CreateVariable(std::shared_ptr<class VariableExpr> Value)
            {
                auto r = std::make_shared<Expr>();
                r->_Tag = ExprTag_Variable;
                r->Variable = Value;
                return r;
            }
            /// <summary>函数表达式</summary>
            static std::shared_ptr<class Expr> CreateFunction(std::shared_ptr<class FunctionExpr> Value)
            {
                auto r = std::make_shared<Expr>();
                r->_Tag = ExprTag_Function;
                r->Function = Value;
                return r;
            }
            /// <summary>if伪函数表达式</summary>
            static std::shared_ptr<class Expr> CreateIf(std::shared_ptr<class IfExpr> Value)
            {
                auto r = std::make_shared<Expr>();
                r->_Tag = ExprTag_If;
                r->If = Value;
                return r;
            }
            /// <summary>&amp;&amp;运算符表达式</summary>
            static std::shared_ptr<class Expr> CreateAndAlso(std::shared_ptr<class AndAlsoExpr> Value)
            {
                auto r = std::make_shared<Expr>();
                r->_Tag = ExprTag_AndAlso;
                r->AndAlso = Value;
                return r;
            }
            /// <summary>||运算符表达式</summary>
            static std::shared_ptr<class Expr> CreateOrElse(std::shared_ptr<class OrElseExpr> Value)
            {
                auto r = std::make_shared<Expr>();
                r->_Tag = ExprTag_OrElse;
                r->OrElse = Value;
                return r;
            }

            /// <summary>字面量表达式</summary>
            Boolean OnLiteral() const
            {
                return _Tag == ExprTag_Literal;
            }
            /// <summary>变量表达式</summary>
            Boolean OnVariable() const
            {
                return _Tag == ExprTag_Variable;
            }
            /// <summary>函数表达式</summary>
            Boolean OnFunction() const
            {
                return _Tag == ExprTag_Function;
            }
            /// <summary>if伪函数表达式</summary>
            Boolean OnIf() const
            {
                return _Tag == ExprTag_If;
            }
            /// <summary>&amp;&amp;运算符表达式</summary>
            Boolean OnAndAlso() const
            {
                return _Tag == ExprTag_AndAlso;
            }
            /// <summary>||运算符表达式</summary>
            Boolean OnOrElse() const
            {
                return _Tag == ExprTag_OrElse;
            }
        };

        enum LiteralExprTag
        {
            /// <summary>布尔字面量</summary>
            LiteralExprTag_BooleanValue = 0,
            /// <summary>整数字面量</summary>
            LiteralExprTag_IntValue = 1,
            /// <summary>实数字面量</summary>
            LiteralExprTag_RealValue = 2
        };
        /// <summary>字面量表示式</summary>
        /* TaggedUnion */
        class LiteralExpr /* final */
        {
        public:
            /* Tag */ LiteralExprTag _Tag;

            /// <summary>布尔字面量</summary>
            Boolean BooleanValue;
            /// <summary>整数字面量</summary>
            Int IntValue;
            /// <summary>实数字面量</summary>
            Real RealValue;

            /// <summary>布尔字面量</summary>
            static std::shared_ptr<class LiteralExpr> CreateBooleanValue(Boolean Value)
            {
                auto r = std::make_shared<LiteralExpr>();
                r->_Tag = LiteralExprTag_BooleanValue;
                r->BooleanValue = Value;
                return r;
            }
            /// <summary>整数字面量</summary>
            static std::shared_ptr<class LiteralExpr> CreateIntValue(Int Value)
            {
                auto r = std::make_shared<LiteralExpr>();
                r->_Tag = LiteralExprTag_IntValue;
                r->IntValue = Value;
                return r;
            }
            /// <summary>实数字面量</summary>
            static std::shared_ptr<class LiteralExpr> CreateRealValue(Real Value)
            {
                auto r = std::make_shared<LiteralExpr>();
                r->_Tag = LiteralExprTag_RealValue;
                r->RealValue = Value;
                return r;
            }

            /// <summary>布尔字面量</summary>
            Boolean OnBooleanValue() const
            {
                return _Tag == LiteralExprTag_BooleanValue;
            }
            /// <summary>整数字面量</summary>
            Boolean OnIntValue() const
            {
                return _Tag == LiteralExprTag_IntValue;
            }
            /// <summary>实数字面量</summary>
            Boolean OnRealValue() const
            {
                return _Tag == LiteralExprTag_RealValue;
            }
        };

        /// <summary>变量表达式</summary>
        /* Record */
        class VariableExpr /* final */
        {
        public:
            /// <summary>名称</summary>
            String Name;
        };

        /// <summary>函数表达式</summary>
        /* Record */
        class FunctionExpr /* final */
        {
        public:
            /// <summary>名称</summary>
            String Name;
            /// <summary>实参</summary>
            std::shared_ptr<class std::vector<std::shared_ptr<class Expr>>> Parameters;
        };

        /// <summary>if伪函数表达式</summary>
        /* Record */
        class IfExpr /* final */
        {
        public:
            /// <summary>条件</summary>
            std::shared_ptr<class Expr> Condition;
            /// <summary>条件为真时的值</summary>
            std::shared_ptr<class Expr> TruePart;
            /// <summary>条件为假时的值</summary>
            std::shared_ptr<class Expr> FalsePart;
        };

        /// <summary>&amp;&amp;运算符表达式</summary>
        /* Record */
        class AndAlsoExpr /* final */
        {
        public:
            /// <summary>左部表达式</summary>
            std::shared_ptr<class Expr> Left;
            /// <summary>右部表达式</summary>
            std::shared_ptr<class Expr> Right;
        };

        /// <summary>||运算符表达式</summary>
        /* Record */
        class OrElseExpr /* final */
        {
        public:
            /// <summary>左部表达式</summary>
            std::shared_ptr<class Expr> Left;
            /// <summary>右部表达式</summary>
            std::shared_ptr<class Expr> Right;
        };

        enum TokenLiteralTag
        {
            /// <summary>布尔类型</summary>
            TokenLiteralTag_BooleanValue = 0,
            /// <summary>整数类型</summary>
            TokenLiteralTag_IntValue = 1,
            /// <summary>实数类型</summary>
            TokenLiteralTag_RealValue = 2
        };
        /// <summary>字面量</summary>
        /* TaggedUnion */
        class TokenLiteral /* final */
        {
        public:
            /* Tag */ TokenLiteralTag _Tag;

            /// <summary>布尔类型</summary>
            Boolean BooleanValue;
            /// <summary>整数类型</summary>
            Int IntValue;
            /// <summary>实数类型</summary>
            Real RealValue;

            /// <summary>布尔类型</summary>
            static std::shared_ptr<class TokenLiteral> CreateBooleanValue(Boolean Value)
            {
                auto r = std::make_shared<TokenLiteral>();
                r->_Tag = TokenLiteralTag_BooleanValue;
                r->BooleanValue = Value;
                return r;
            }
            /// <summary>整数类型</summary>
            static std::shared_ptr<class TokenLiteral> CreateIntValue(Int Value)
            {
                auto r = std::make_shared<TokenLiteral>();
                r->_Tag = TokenLiteralTag_IntValue;
                r->IntValue = Value;
                return r;
            }
            /// <summary>实数类型</summary>
            static std::shared_ptr<class TokenLiteral> CreateRealValue(Real Value)
            {
                auto r = std::make_shared<TokenLiteral>();
                r->_Tag = TokenLiteralTag_RealValue;
                r->RealValue = Value;
                return r;
            }

            /// <summary>布尔类型</summary>
            Boolean OnBooleanValue() const
            {
                return _Tag == TokenLiteralTag_BooleanValue;
            }
            /// <summary>整数类型</summary>
            Boolean OnIntValue() const
            {
                return _Tag == TokenLiteralTag_IntValue;
            }
            /// <summary>实数类型</summary>
            Boolean OnRealValue() const
            {
                return _Tag == TokenLiteralTag_RealValue;
            }
        };

        /// <summary>标识符</summary>
        /* Record */
        class TokenIdentifier /* final */
        {
        public:
            /// <summary>名称</summary>
            String Name;
        };

        /// <summary>二目运算符</summary>
        /* Record */
        class TokenBinaryOperator /* final */
        {
        public:
            /// <summary>名称</summary>
            String Name;
        };

        /// <summary>单目运算符</summary>
        /* Record */
        class TokenUnaryOperator /* final */
        {
        public:
            /// <summary>名称</summary>
            String Name;
        };

        /// <summary>左小括号</summary>
        /* Record */
        class TokenLeftParen /* final */
        {
        public:
        };

        /// <summary>右小括号</summary>
        /* Record */
        class TokenRightParen /* final */
        {
        public:
        };

        /// <summary>逗号</summary>
        /* Record */
        class TokenComma /* final */
        {
        public:
        };

        enum SyntaxExprTag
        {
            /// <summary>字面量</summary>
            SyntaxExprTag_Literal = 0,
            /// <summary>函数</summary>
            SyntaxExprTag_Function = 1,
            /// <summary>单个变量</summary>
            SyntaxExprTag_Variable = 2,
            /// <summary>括号</summary>
            SyntaxExprTag_Paren = 3,
            /// <summary>前缀单目运算</summary>
            SyntaxExprTag_UnaryOperator = 4,
            /// <summary>中缀二目运算</summary>
            SyntaxExprTag_BinaryOperator = 5
        };
        /// <summary>表达式</summary>
        /* TaggedUnion */
        class SyntaxExpr /* final */
        {
        public:
            /* Tag */ SyntaxExprTag _Tag;

            /// <summary>字面量</summary>
            std::shared_ptr<class ProductionLiteral> Literal;
            /// <summary>函数</summary>
            std::shared_ptr<class ProductionFunction> Function;
            /// <summary>单个变量</summary>
            std::shared_ptr<class ProductionVariable> Variable;
            /// <summary>括号</summary>
            std::shared_ptr<class ProductionParen> Paren;
            /// <summary>前缀单目运算</summary>
            std::shared_ptr<class ProductionUnaryOperator> UnaryOperator;
            /// <summary>中缀二目运算</summary>
            std::shared_ptr<class ProductionBinaryOperator> BinaryOperator;

            /// <summary>字面量</summary>
            static std::shared_ptr<class SyntaxExpr> CreateLiteral(std::shared_ptr<class ProductionLiteral> Value)
            {
                auto r = std::make_shared<SyntaxExpr>();
                r->_Tag = SyntaxExprTag_Literal;
                r->Literal = Value;
                return r;
            }
            /// <summary>函数</summary>
            static std::shared_ptr<class SyntaxExpr> CreateFunction(std::shared_ptr<class ProductionFunction> Value)
            {
                auto r = std::make_shared<SyntaxExpr>();
                r->_Tag = SyntaxExprTag_Function;
                r->Function = Value;
                return r;
            }
            /// <summary>单个变量</summary>
            static std::shared_ptr<class SyntaxExpr> CreateVariable(std::shared_ptr<class ProductionVariable> Value)
            {
                auto r = std::make_shared<SyntaxExpr>();
                r->_Tag = SyntaxExprTag_Variable;
                r->Variable = Value;
                return r;
            }
            /// <summary>括号</summary>
            static std::shared_ptr<class SyntaxExpr> CreateParen(std::shared_ptr<class ProductionParen> Value)
            {
                auto r = std::make_shared<SyntaxExpr>();
                r->_Tag = SyntaxExprTag_Paren;
                r->Paren = Value;
                return r;
            }
            /// <summary>前缀单目运算</summary>
            static std::shared_ptr<class SyntaxExpr> CreateUnaryOperator(std::shared_ptr<class ProductionUnaryOperator> Value)
            {
                auto r = std::make_shared<SyntaxExpr>();
                r->_Tag = SyntaxExprTag_UnaryOperator;
                r->UnaryOperator = Value;
                return r;
            }
            /// <summary>中缀二目运算</summary>
            static std::shared_ptr<class SyntaxExpr> CreateBinaryOperator(std::shared_ptr<class ProductionBinaryOperator> Value)
            {
                auto r = std::make_shared<SyntaxExpr>();
                r->_Tag = SyntaxExprTag_BinaryOperator;
                r->BinaryOperator = Value;
                return r;
            }

            /// <summary>字面量</summary>
            Boolean OnLiteral() const
            {
                return _Tag == SyntaxExprTag_Literal;
            }
            /// <summary>函数</summary>
            Boolean OnFunction() const
            {
                return _Tag == SyntaxExprTag_Function;
            }
            /// <summary>单个变量</summary>
            Boolean OnVariable() const
            {
                return _Tag == SyntaxExprTag_Variable;
            }
            /// <summary>括号</summary>
            Boolean OnParen() const
            {
                return _Tag == SyntaxExprTag_Paren;
            }
            /// <summary>前缀单目运算</summary>
            Boolean OnUnaryOperator() const
            {
                return _Tag == SyntaxExprTag_UnaryOperator;
            }
            /// <summary>中缀二目运算</summary>
            Boolean OnBinaryOperator() const
            {
                return _Tag == SyntaxExprTag_BinaryOperator;
            }
        };

        enum SyntaxParameterListTag
        {
            /// <summary>空参数列表</summary>
            SyntaxParameterListTag_Null = 0,
            /// <summary>非空参数列表</summary>
            SyntaxParameterListTag_Nonnull = 1
        };
        /// <summary>参数列表</summary>
        /* TaggedUnion */
        class SyntaxParameterList /* final */
        {
        public:
            /* Tag */ SyntaxParameterListTag _Tag;

            /// <summary>空参数列表</summary>
            std::shared_ptr<class ProductionNullParameterList> Null;
            /// <summary>非空参数列表</summary>
            std::shared_ptr<class ProductionNonnullParameterList> Nonnull;

            /// <summary>空参数列表</summary>
            static std::shared_ptr<class SyntaxParameterList> CreateNull(std::shared_ptr<class ProductionNullParameterList> Value)
            {
                auto r = std::make_shared<SyntaxParameterList>();
                r->_Tag = SyntaxParameterListTag_Null;
                r->Null = Value;
                return r;
            }
            /// <summary>非空参数列表</summary>
            static std::shared_ptr<class SyntaxParameterList> CreateNonnull(std::shared_ptr<class ProductionNonnullParameterList> Value)
            {
                auto r = std::make_shared<SyntaxParameterList>();
                r->_Tag = SyntaxParameterListTag_Nonnull;
                r->Nonnull = Value;
                return r;
            }

            /// <summary>空参数列表</summary>
            Boolean OnNull() const
            {
                return _Tag == SyntaxParameterListTag_Null;
            }
            /// <summary>非空参数列表</summary>
            Boolean OnNonnull() const
            {
                return _Tag == SyntaxParameterListTag_Nonnull;
            }
        };

        enum SyntaxNonnullParameterListTag
        {
            /// <summary>单个参数列表</summary>
            SyntaxNonnullParameterListTag_Single = 0,
            /// <summary>多个参数列表</summary>
            SyntaxNonnullParameterListTag_Multiple = 1
        };
        /// <summary>非空参数列表</summary>
        /* TaggedUnion */
        class SyntaxNonnullParameterList /* final */
        {
        public:
            /* Tag */ SyntaxNonnullParameterListTag _Tag;

            /// <summary>单个参数列表</summary>
            std::shared_ptr<class ProductionSingleParameterList> Single;
            /// <summary>多个参数列表</summary>
            std::shared_ptr<class ProductionMultipleParameterList> Multiple;

            /// <summary>单个参数列表</summary>
            static std::shared_ptr<class SyntaxNonnullParameterList> CreateSingle(std::shared_ptr<class ProductionSingleParameterList> Value)
            {
                auto r = std::make_shared<SyntaxNonnullParameterList>();
                r->_Tag = SyntaxNonnullParameterListTag_Single;
                r->Single = Value;
                return r;
            }
            /// <summary>多个参数列表</summary>
            static std::shared_ptr<class SyntaxNonnullParameterList> CreateMultiple(std::shared_ptr<class ProductionMultipleParameterList> Value)
            {
                auto r = std::make_shared<SyntaxNonnullParameterList>();
                r->_Tag = SyntaxNonnullParameterListTag_Multiple;
                r->Multiple = Value;
                return r;
            }

            /// <summary>单个参数列表</summary>
            Boolean OnSingle() const
            {
                return _Tag == SyntaxNonnullParameterListTag_Single;
            }
            /// <summary>多个参数列表</summary>
            Boolean OnMultiple() const
            {
                return _Tag == SyntaxNonnullParameterListTag_Multiple;
            }
        };

        /// <summary>字面量</summary>
        /* Record */
        class ProductionLiteral /* final */
        {
        public:
            /// <summary>字面量</summary>
            std::shared_ptr<class TokenLiteral> Literal;
        };

        /// <summary>函数</summary>
        /* Record */
        class ProductionFunction /* final */
        {
        public:
            /// <summary>标识符</summary>
            std::shared_ptr<class TokenIdentifier> Identifier;
            /// <summary>参数列表</summary>
            std::shared_ptr<class SyntaxParameterList> ParameterList;
        };

        /// <summary>单个变量</summary>
        /* Record */
        class ProductionVariable /* final */
        {
        public:
            /// <summary>标识符</summary>
            std::shared_ptr<class TokenIdentifier> Identifier;
        };

        /// <summary>括号</summary>
        /* Record */
        class ProductionParen /* final */
        {
        public:
            /// <summary>表达式</summary>
            std::shared_ptr<class SyntaxExpr> Expr;
        };

        /// <summary>前缀单目运算</summary>
        /* Record */
        class ProductionUnaryOperator /* final */
        {
        public:
            /// <summary>单目运算符</summary>
            std::shared_ptr<class TokenUnaryOperator> UnaryOperator;
            /// <summary>表达式</summary>
            std::shared_ptr<class SyntaxExpr> Expr;
        };

        /// <summary>中缀二目运算</summary>
        /* Record */
        class ProductionBinaryOperator /* final */
        {
        public:
            /// <summary>二目运算符</summary>
            std::shared_ptr<class TokenBinaryOperator> BinaryOperator;
            /// <summary>表达式</summary>
            std::shared_ptr<class SyntaxExpr> Left;
            /// <summary>表达式</summary>
            std::shared_ptr<class SyntaxExpr> Right;
        };

        /// <summary>空参数列表</summary>
        /* Record */
        class ProductionNullParameterList /* final */
        {
        public:
        };

        /// <summary>非空参数列表</summary>
        /* Record */
        class ProductionNonnullParameterList /* final */
        {
        public:
            /// <summary>非空参数列表</summary>
            std::shared_ptr<class SyntaxNonnullParameterList> NonnullParameterList;
        };

        /// <summary>单个参数列表</summary>
        /* Record */
        class ProductionSingleParameterList /* final */
        {
        public:
            /// <summary>表达式</summary>
            std::shared_ptr<class SyntaxExpr> Expr;
        };

        /// <summary>多个参数列表</summary>
        /* Record */
        class ProductionMultipleParameterList /* final */
        {
        public:
            /// <summary>非空参数列表</summary>
            std::shared_ptr<class SyntaxNonnullParameterList> NonnullParameterList;
            /// <summary>表达式</summary>
            std::shared_ptr<class SyntaxExpr> Expr;
        };

        enum SyntaxRuleTag
        {
            /// <summary>字面量</summary>
            SyntaxRuleTag_Literal = 0,
            /// <summary>标识符</summary>
            SyntaxRuleTag_Identifier = 1,
            /// <summary>二目运算符</summary>
            SyntaxRuleTag_BinaryOperator = 2,
            /// <summary>单目运算符</summary>
            SyntaxRuleTag_UnaryOperator = 3,
            /// <summary>左小括号</summary>
            SyntaxRuleTag_LeftParen = 4,
            /// <summary>右小括号</summary>
            SyntaxRuleTag_RightParen = 5,
            /// <summary>逗号</summary>
            SyntaxRuleTag_Comma = 6,
            /// <summary>表达式</summary>
            SyntaxRuleTag_Expr = 7,
            /// <summary>参数列表</summary>
            SyntaxRuleTag_ParameterList = 8,
            /// <summary>非空参数列表</summary>
            SyntaxRuleTag_NonnullParameterList = 9
        };
        /// <summary>句法规则</summary>
        /* TaggedUnion */
        class SyntaxRule /* final */
        {
        public:
            /* Tag */ SyntaxRuleTag _Tag;

            /// <summary>字面量</summary>
            std::shared_ptr<class TokenLiteral> Literal;
            /// <summary>标识符</summary>
            std::shared_ptr<class TokenIdentifier> Identifier;
            /// <summary>二目运算符</summary>
            std::shared_ptr<class TokenBinaryOperator> BinaryOperator;
            /// <summary>单目运算符</summary>
            std::shared_ptr<class TokenUnaryOperator> UnaryOperator;
            /// <summary>左小括号</summary>
            std::shared_ptr<class TokenLeftParen> LeftParen;
            /// <summary>右小括号</summary>
            std::shared_ptr<class TokenRightParen> RightParen;
            /// <summary>逗号</summary>
            std::shared_ptr<class TokenComma> Comma;
            /// <summary>表达式</summary>
            std::shared_ptr<class SyntaxExpr> Expr;
            /// <summary>参数列表</summary>
            std::shared_ptr<class SyntaxParameterList> ParameterList;
            /// <summary>非空参数列表</summary>
            std::shared_ptr<class SyntaxNonnullParameterList> NonnullParameterList;

            /// <summary>字面量</summary>
            static std::shared_ptr<class SyntaxRule> CreateLiteral(std::shared_ptr<class TokenLiteral> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_Literal;
                r->Literal = Value;
                return r;
            }
            /// <summary>标识符</summary>
            static std::shared_ptr<class SyntaxRule> CreateIdentifier(std::shared_ptr<class TokenIdentifier> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_Identifier;
                r->Identifier = Value;
                return r;
            }
            /// <summary>二目运算符</summary>
            static std::shared_ptr<class SyntaxRule> CreateBinaryOperator(std::shared_ptr<class TokenBinaryOperator> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_BinaryOperator;
                r->BinaryOperator = Value;
                return r;
            }
            /// <summary>单目运算符</summary>
            static std::shared_ptr<class SyntaxRule> CreateUnaryOperator(std::shared_ptr<class TokenUnaryOperator> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_UnaryOperator;
                r->UnaryOperator = Value;
                return r;
            }
            /// <summary>左小括号</summary>
            static std::shared_ptr<class SyntaxRule> CreateLeftParen(std::shared_ptr<class TokenLeftParen> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_LeftParen;
                r->LeftParen = Value;
                return r;
            }
            /// <summary>右小括号</summary>
            static std::shared_ptr<class SyntaxRule> CreateRightParen(std::shared_ptr<class TokenRightParen> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_RightParen;
                r->RightParen = Value;
                return r;
            }
            /// <summary>逗号</summary>
            static std::shared_ptr<class SyntaxRule> CreateComma(std::shared_ptr<class TokenComma> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_Comma;
                r->Comma = Value;
                return r;
            }
            /// <summary>表达式</summary>
            static std::shared_ptr<class SyntaxRule> CreateExpr(std::shared_ptr<class SyntaxExpr> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_Expr;
                r->Expr = Value;
                return r;
            }
            /// <summary>参数列表</summary>
            static std::shared_ptr<class SyntaxRule> CreateParameterList(std::shared_ptr<class SyntaxParameterList> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_ParameterList;
                r->ParameterList = Value;
                return r;
            }
            /// <summary>非空参数列表</summary>
            static std::shared_ptr<class SyntaxRule> CreateNonnullParameterList(std::shared_ptr<class SyntaxNonnullParameterList> Value)
            {
                auto r = std::make_shared<SyntaxRule>();
                r->_Tag = SyntaxRuleTag_NonnullParameterList;
                r->NonnullParameterList = Value;
                return r;
            }

            /// <summary>字面量</summary>
            Boolean OnLiteral() const
            {
                return _Tag == SyntaxRuleTag_Literal;
            }
            /// <summary>标识符</summary>
            Boolean OnIdentifier() const
            {
                return _Tag == SyntaxRuleTag_Identifier;
            }
            /// <summary>二目运算符</summary>
            Boolean OnBinaryOperator() const
            {
                return _Tag == SyntaxRuleTag_BinaryOperator;
            }
            /// <summary>单目运算符</summary>
            Boolean OnUnaryOperator() const
            {
                return _Tag == SyntaxRuleTag_UnaryOperator;
            }
            /// <summary>左小括号</summary>
            Boolean OnLeftParen() const
            {
                return _Tag == SyntaxRuleTag_LeftParen;
            }
            /// <summary>右小括号</summary>
            Boolean OnRightParen() const
            {
                return _Tag == SyntaxRuleTag_RightParen;
            }
            /// <summary>逗号</summary>
            Boolean OnComma() const
            {
                return _Tag == SyntaxRuleTag_Comma;
            }
            /// <summary>表达式</summary>
            Boolean OnExpr() const
            {
                return _Tag == SyntaxRuleTag_Expr;
            }
            /// <summary>参数列表</summary>
            Boolean OnParameterList() const
            {
                return _Tag == SyntaxRuleTag_ParameterList;
            }
            /// <summary>非空参数列表</summary>
            Boolean OnNonnullParameterList() const
            {
                return _Tag == SyntaxRuleTag_NonnullParameterList;
            }
        };
    }
}
