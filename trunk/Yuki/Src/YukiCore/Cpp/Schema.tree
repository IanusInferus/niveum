$Comment
    ==========================================================================

      File:        Schema.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C++模板数据
      Version:     2015.02.06.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
        $List String
            __abstract
            __alignof
            __asm
            __assume
            __based
            __box
            __cdecl
            __declspec
            __delegate
            __event
            __except
            __fastcall
            __finally
            __forceinline
            __gc
            __hook
            __identifier
            __if_exists
            __if_not_exists
            __inline
            __int16
            __int32
            __int64
            __int8
            __interface
            __leave
            __m128
            __m128d
            __m128i
            __m64
            __multiple_inheritance
            __nogc
            __noop
            __pin
            __property
            __raise
            __sealed
            __single_inheritance
            __stdcall
            __super
            __thiscall
            __try
            __except
            __finally
            __try_cast
            __unaligned
            __unhook
            __uuidof
            __value
            __virtual_inheritance
            __w64
            __wchar_t
            wchar_t
            abstract
            array
            auto
            bool
            break
            case
            catch
            char
            class
            const
            const_cast
            continue
            decltype
            default
            delegate
            delete
            deprecated
            dllexport
            dllimport
            do
            double
            dynamic_cast
            else
            enum
            event
            explicit
            extern
            false
            finally
            float
            for
            each
            in
            friend
            friend_as
            gcnew
            generic
            goto
            if
            initonly
            inline
            int
            interface
            interior_ptr
            literal
            long
            mutable
            naked
            namespace
            new
            noinline
            noreturn
            nothrow
            novtable
            nullptr
            operator
            private
            property
            protected
            public
            ref
            register
            reinterpret_cast
            return
            safecast
            sealed
            selectany
            short
            signed
            sizeof
            static
            static_assert
            static_cast
            struct
            switch
            template
            this
            thread
            throw
            true
            try
            typedef
            typeid
            typename
            union
            unsigned
            using
            uuid
            value
            virtual
            void
            volatile
            while
    PrimitiveMappings
        PrimitiveMapping
            Name Unit
            PlatformName Unit
        PrimitiveMapping
            Name Boolean
            PlatformName bool
        PrimitiveMapping
            Name String
            PlatformName std::wstring
        PrimitiveMapping
            Name Int
            PlatformName std::int32_t
        PrimitiveMapping
            Name Real
            PlatformName double
        PrimitiveMapping
            Name Byte
            PlatformName std::uint8_t
        PrimitiveMapping
            Name UInt8
            PlatformName std::uint8_t
        PrimitiveMapping
            Name UInt16
            PlatformName std::uint16_t
        PrimitiveMapping
            Name UInt32
            PlatformName std::uint32_t
        PrimitiveMapping
            Name UInt64
            PlatformName std::uint64_t
        PrimitiveMapping
            Name Int8
            PlatformName std::int8_t
        PrimitiveMapping
            Name Int16
            PlatformName std::int16_t
        PrimitiveMapping
            Name Int32
            PlatformName std::int32_t
        PrimitiveMapping
            Name Int64
            PlatformName std::int64_t
        PrimitiveMapping
            Name Float32
            PlatformName float
        PrimitiveMapping
            Name Float64
            PlatformName double
        PrimitiveMapping
            Name Type
            PlatformName std::wstring
        PrimitiveMapping
            Name Optional
            PlatformName Optional
        PrimitiveMapping
            Name List
            PlatformName std::vector
        PrimitiveMapping
            Name Set
            PlatformName std::unordered_set
        PrimitiveMapping
            Name Map
            PlatformName std::unordered_map
    Templates
        Template
            Name Main
            //Parameters: ${Header}, ${Includes}, ${Primitives}, ${SimpleTypes}, ${EnumFunctors}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    #include ${Includes}
                    ${Primitives}
                    ${SimpleTypes}
                    ${EnumFunctors}
                    ${ComplexTypes}

                $End
        Template
            Name Namespace
            //Parameters: ${NamespaceName}, ${ComplexTypes}
            Value
                $String
                    namespace [[${NamespaceName}]]
                    {
                        ${Contents}
                    }
        Template
            Name PredefinedTypes
            Value
                $String
                    #ifndef _UNIT_TYPE_
                        typedef struct {} Unit;
                        #define _UNIT_TYPE_
                    #endif
        Template
            Name PredefinedType_Optional
            //Parameters:
            Value
                $String
                    #ifndef _OPTIONAL_TYPE_
                        enum OptionalTag
                        {
                            OptionalTag_NotHasValue = 0,
                            OptionalTag_HasValue = 1
                        };
                        /* TaggedUnion */
                        template<typename T>
                        class Optional /* final */
                        {
                        public:
                            /* Tag */ OptionalTag _Tag;

                            Unit NotHasValue;
                            T HasValue;

                            static Optional<T> CreateNotHasValue()
                            {
                                auto r = Optional<T>();
                                r._Tag = OptionalTag_NotHasValue;
                                r.NotHasValue = Unit();
                                return r;
                            }
                            static Optional<T> CreateHasValue(T Value)
                            {
                                auto r = Optional<T>();
                                r._Tag = OptionalTag_HasValue;
                                r.HasValue = Value;
                                return r;
                            }

                            Boolean OnNotHasValue() const
                            {
                                return _Tag == OptionalTag_NotHasValue;
                            }
                            Boolean OnHasValue() const
                            {
                                return _Tag == OptionalTag_HasValue;
                            }

                        	static Optional<T> Empty() { return CreateNotHasValue(); }
                            Optional()
                                : _Tag(OptionalTag_NotHasValue),
                                  NotHasValue(Unit()),
                                  HasValue(T())
                            {
                            }
                            Optional(const T &v)
                                : _Tag(OptionalTag_HasValue),
                                  NotHasValue(Unit()),
                                  HasValue(v)
                            {
                            }
                            Optional(std::nullptr_t v)
                                : _Tag(OptionalTag_NotHasValue),
                                  NotHasValue(Unit()),
                                  HasValue(T())
                            {
                            }
                            /* explicit operator T() const
                            {
                                if (OnNotHasValue())
                                {
                                    throw std::logic_error("InvalidOperationException");
                                }
                                return HasValue;
                            } */
                            Boolean operator ==(const Optional<T> &Right) const
                            {
                                return Equals(*this, Right);
                            }
                            Boolean operator !=(const Optional<T> &Right) const
                            {
                                return !Equals(*this, Right);
                            }
                            Boolean operator ==(const T &Right) const
                            {
                                return Equals(*this, static_cast<const Optional<T> &>(Right));
                            }
                            Boolean operator !=(const T &Right) const
                            {
                                return !Equals(*this, static_cast<const Optional<T> &>(Right));
                            }
                            Boolean operator ==(std::nullptr_t Right) const
                            {
                                return Equals(*this, Right);
                            }
                            Boolean operator !=(std::nullptr_t Right) const
                            {
                                return !Equals(*this, Right);
                            }

                        private:
                            static Boolean Equals(const Optional<T> &Left, const Optional<T> &Right)
                            {
                                if (Left.OnNotHasValue() && Right.OnNotHasValue())
                                {
                                    return true;
                                }
                                if (Left.OnNotHasValue() || Right.OnNotHasValue())
                                {
                                    return false;
                                }
                                return Left.HasValue == Right.HasValue;
                            }
                            static Boolean Equals(const Optional<T> &Left, std::nullptr_t Right)
                            {
                                return Left.OnNotHasValue();
                            }

                        public:
                            T Value() const
                            {
                                if (OnHasValue())
                                {
                                    return HasValue;
                                }
                                else
                                {
                                    throw std::logic_error("InvalidOperationException");
                                }
                            }
                            T ValueOrDefault(T Default) const
                            {
                                if (OnHasValue())
                                {
                                    return HasValue;
                                }
                                else
                                {
                                    return Default;
                                }
                            }
                        };

                        namespace std
                        {
                            template <typename T>
                            struct hash<Optional<T>>
                            {
                                size_t operator()(const Optional<T> &x) const
                                {
                                    if (x.OnNotHasValue()) { return 0; }
                                    return hash<T>()(x.HasValue);
                                }
                            };
                            template <typename T>
                            struct less<Optional<T>>
                            {
                                bool operator()(const Optional<T> &x, const Optional<T> &y) const
                                {
                                    if ((x == nullptr) && (y == nullptr)) { return false; }
                                    if (x == nullptr) { return true; }
                                    if (y == nullptr) { return false; }
                                    return x.HasValue < y.HasValue;
                                }
                            };
                        }

                        #define _OPTIONAL_TYPE_
                    #endif
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    #pragma once

                    //Reference:

                    #include <cstddef>
                    #include <cstdint>
                    #include <string>
                    #include <vector>
                    #include <unordered_set>
                    #include <unordered_map>
                    #include <memory>
                    #include <functional>
                    #include <stdexcept>
        Template
            Name Primitive
            //Parameters: ${Name}, ${PlatformName}
            Value
                $String
                    typedef ${PlatformName} [[${Name}]];
        Template
            Name TypePredefinition
            //Parameters: ${Name}, ${MetaType}, ${GenericParameterLine}
            Value
                $String
                    ${GenericParameterLine}
                    ${MetaType} [[${Name}]];
        Template
            Name Alias
            //Parameters: ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    /* Alias */
                    class [[${Name}]] /* final */
                    {
                    public:
                        [[${Type}]] Value;
                    };
        Template
            Name TupleElement
            //Parameters: ${NameIndex}, ${Type}
            Value
                $String
                    [[${Type}]] [[Item${NameIndex}]];
        Template
            Name Tuple
            //Parameters: ${Name}, ${TupleElements}
            Value
                $String
                    /* Tuple */
                    class [[${Name}]] /* final */
                    {
                    public:
                        ${TupleElements}
                    };
        Template
            Name Field
            //Parameters: ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [[${Type}]] [[${Name}]];
        Template
            Name Record
            //Parameters: ${Name}, ${Fields}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    /* Record */
                    class [[${Name}]] /* final */
                    {
                    public:
                        ${Fields}
                    };
        Template
            Name Alternative
            //Parameters: ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [[${Type}]] [[${Name}]];
        Template
            Name AlternativeCreate
            //Parameters: ${TaggedUnionName}, ${TaggedUnionTagName}, ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    static std::shared_ptr<class [[${TaggedUnionName}]]> [[Create${Name}]]([[${Type}]] Value)
                    {
                        auto r = std::make_shared<[[${TaggedUnionName}]]>();
                        r->_Tag = [[${TaggedUnionTagName}_${Name}]];
                        r->[[${Name}]] = Value;
                        return r;
                    }
        Template
            Name AlternativeCreateUnit
            //Parameters: ${TaggedUnionName}, ${TaggedUnionTagName}, ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    static std::shared_ptr<class [[${TaggedUnionName}]]> [[Create${Name}]]()
                    {
                        auto r = std::make_shared<[[${TaggedUnionName}]]>();
                        r->_Tag = [[${TaggedUnionTagName}_${Name}]];
                        r->[[${Name}]] = Unit();
                        return r;
                    }
        Template
            Name AlternativePredicate
            //Parameters: ${TaggedUnionName}, ${TaggedUnionTagName}, ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    Boolean [[On${Name}]]() const
                    {
                        return _Tag == [[${TaggedUnionTagName}_${Name}]];
                    }
        Template
            Name TaggedUnion
            //Parameters: ${Name}, ${GenericParameterLine}, ${TagName}, ${AlternativeLiterals}, ${Alternatives}, ${AlternativeCreates}, ${AlternativePredicates}, ${XmlComment}
            Value
                $String
                    enum [[${TagName}]]
                    {
                        ${AlternativeLiterals}
                    };
                    ${XmlComment}
                    /* TaggedUnion */
                    ${GenericParameterLine}
                    class [[${Name}]] /* final */
                    {
                    public:
                        /* Tag */ [[${TagName}]] _Tag;

                        ${Alternatives}

                        ${AlternativeCreates}

                        ${AlternativePredicates}
                    };
        Template
            Name Literal
            //Parameters: ${Name}, ${Value}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [[${Name}]] = ${Value},
        Template
            Name LastLiteral
            //Parameters: ${Name}, ${Value}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [[${Name}]] = ${Value}
        Template
            Name Enum
            //Parameters: ${Name}, ${UnderlyingType}, ${Literals}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    enum [[${Name}]] : ${UnderlyingType}
                    {
                        ${Literals}
                    };
        Template
            Name EnumFunctor
            //Parameters: ${Name}, ${UnderlyingType}
            Value
                $String
                    template <>
                    struct hash<[[${Name}]]>
                    {
                        size_t operator()(const [[${Name}]] &x) const
                        {
                            return hash<${UnderlyingType}>()(x);
                        }
                    };
                    template <>
                    struct less<[[${Name}]]>
                    {
                        bool operator()(const [[${Name}]] &x, const [[${Name}]] &y) const
                        {
                            return less<${UnderlyingType}>()(x, y);
                        }
                    };
        Template
            Name MultiLineXmlComment
            //Parameters: ${Description}
            Value
                $String
                    /// <summary>
                    /// ${Description}
                    /// </summary>
        Template
            Name SingleLineXmlComment
            //Parameters: ${Description}
            Value
                $String
                    /// <summary>${Description}</summary>
        Template
            Name IApplicationServer
            //Parameters: ${Commands}
            Value
                $String
                    class IApplicationServer
                    {
                    public:
                        ${Commands}

                        virtual ~IApplicationServer() {}
                    };
        Template
            Name IApplicationServer_ClientCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    virtual std::shared_ptr<class [[${Name}Reply]]> [[${Name}]](std::shared_ptr<class [[${Name}Request]]> r) = 0;
        Template
            Name IApplicationServer_ServerCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    std::function<void(std::shared_ptr<class [[${Name}Event]]>)> [[${Name}]];
        Template
            Name IApplicationClient
            //Parameters: ${Commands}
            Value
                $String
                    class IApplicationClient
                    {
                    public:
                        virtual std::uint64_t Hash() = 0;
                        virtual void DequeueCallback(std::wstring CommandName) = 0;

                        ${Commands}

                        virtual ~IApplicationClient() {}
                    };
        Template
            Name IApplicationClient_ClientCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    virtual void [[${Name}]](std::shared_ptr<class [[${Name}Request]]> r, std::function<void(std::shared_ptr<class [[${Name}Reply]]>)> Callback) = 0;
        Template
            Name IApplicationClient_ServerCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    std::function<void(std::shared_ptr<class [[${Name}Event]]>)> [[${Name}]];
