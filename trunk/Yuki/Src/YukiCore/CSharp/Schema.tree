$Comment
    ==========================================================================

      File:        Schema.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C#模板数据
      Version:     2014.01.09.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
        $List String
            abstract
            event
            new
            struct
            as
            explicit
            null
            switch
            base
            extern
            object
            this
            bool
            false
            operator
            throw
            break
            finally
            out
            true
            byte
            fixed
            override
            try
            case
            float
            params
            typeof
            catch
            for
            private
            uint
            char
            foreach
            protected
            ulong
            checked
            goto
            public
            unchecked
            class
            if
            readonly
            unsafe
            const
            implicit
            ref
            ushort
            continue
            in
            return
            using
            decimal
            int
            sbyte
            virtual
            default
            interface
            sealed
            volatile
            delegate
            internal
            short
            void
            do
            is
            sizeof
            while
            double
            lock
            stackalloc
            else
            long
            static
            enum
            namespace
            string
            get
            partial
            set
            value
            where
            yield
    PrimitiveMappings
        PrimitiveMapping
            Name Unit
            PlatformName Unit
        PrimitiveMapping
            Name Boolean
            PlatformName System.Boolean
        PrimitiveMapping
            Name String
            PlatformName System.String
        PrimitiveMapping
            Name Int
            PlatformName System.Int32
        PrimitiveMapping
            Name Real
            PlatformName System.Double
        PrimitiveMapping
            Name Byte
            PlatformName System.Byte
        PrimitiveMapping
            Name UInt8
            PlatformName System.Byte
        PrimitiveMapping
            Name UInt16
            PlatformName System.UInt16
        PrimitiveMapping
            Name UInt32
            PlatformName System.UInt32
        PrimitiveMapping
            Name UInt64
            PlatformName System.UInt64
        PrimitiveMapping
            Name Int8
            PlatformName System.SByte
        PrimitiveMapping
            Name Int16
            PlatformName System.Int16
        PrimitiveMapping
            Name Int32
            PlatformName System.Int32
        PrimitiveMapping
            Name Int64
            PlatformName System.Int64
        PrimitiveMapping
            Name Float32
            PlatformName System.Single
        PrimitiveMapping
            Name Float64
            PlatformName System.Double
        PrimitiveMapping
            Name Type
            PlatformName System.Type
        PrimitiveMapping
            Name Optional
            PlatformName Optional
        PrimitiveMapping
            Name List
            PlatformName System.Collections.Generic.List
        PrimitiveMapping
            Name Set
            PlatformName System.Collections.Generic.HashSet
        PrimitiveMapping
            Name Map
            PlatformName System.Collections.Generic.Dictionary
    Templates
        Template
            Name MainWithNamespace
            //Parameters: ${Header}, ${NamespaceName}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    namespace [[${NamespaceName}]]
                    {
                        ${ComplexTypes}
                    }

                $End
        Template
            Name MainWithoutNamespace
            //Parameters: ${Header}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    ${ComplexTypes}

                $End
        Template
            Name PredefinedTypes
            //Parameters:
            Value
                $String
                    [Record]
                    public struct Unit
                    {
                    }

                    public class RecordAttribute : Attribute
                    {
                    }

                    public class AliasAttribute : Attribute
                    {
                    }

                    public class TaggedUnionAttribute : Attribute
                    {
                    }

                    public class TagAttribute : Attribute
                    {
                    }

                    public class TupleAttribute : Attribute
                    {
                    }

                $End
        Template
            Name PredefinedTypes_WithFirefly
            //Parameters:
            Value
                $String
                    [Record]
                    public struct Unit
                    {
                    }

                    public class RecordAttribute : Firefly.Mapping.MetaSchema.RecordAttribute
                    {
                    }

                    public class AliasAttribute : Firefly.Mapping.MetaSchema.AliasAttribute
                    {
                    }

                    public class TaggedUnionAttribute : Firefly.Mapping.MetaSchema.TaggedUnionAttribute
                    {
                    }

                    public class TagAttribute : Firefly.Mapping.MetaSchema.TagAttribute
                    {
                    }

                    public class TupleAttribute : Firefly.Mapping.MetaSchema.TupleAttribute
                    {
                    }

                $End
        Template
            Name PredefinedType_Optional
            //Parameters:
            Value
                $String
                    public enum OptionalTag
                    {
                        NotHasValue = 0,
                        HasValue = 1
                    }
                    [TaggedUnion]
                    public struct Optional<T>
                    {
                        [Tag] public OptionalTag _Tag { get; set; }

                        public Unit NotHasValue { get; set; }
                        public T HasValue { get; set; }

                        public static Optional<T> CreateNotHasValue() { return new Optional<T> { _Tag = OptionalTag.NotHasValue, NotHasValue = new Unit() }; }
                        public static Optional<T> CreateHasValue(T Value) { return new Optional<T> { _Tag = OptionalTag.HasValue, HasValue = Value }; }

                        public Boolean OnNotHasValue { get { return _Tag == OptionalTag.NotHasValue; } }
                        public Boolean OnHasValue { get { return _Tag == OptionalTag.HasValue; } }

                        public static Optional<T> Empty { get { return CreateNotHasValue(); } }
                        public static implicit operator Optional<T>(T v)
                        {
                            if (v == null)
                            {
                                return CreateNotHasValue();
                            }
                            else
                            {
                                return CreateHasValue(v);
                            }
                        }
                        public static explicit operator T(Optional<T> v)
                        {
                            if (v.OnNotHasValue)
                            {
                                throw new InvalidOperationException();
                            }
                            return v.HasValue;
                        }
                        public static Boolean operator ==(Optional<T> Left, Optional<T> Right)
                        {
                            return Equals(Left, Right);
                        }
                        public static Boolean operator !=(Optional<T> Left, Optional<T> Right)
                        {
                            return !Equals(Left, Right);
                        }
                        public static Boolean operator ==(Optional<T>? Left, Optional<T>? Right)
                        {
                            return Equals(Left, Right);
                        }
                        public static Boolean operator !=(Optional<T>? Left, Optional<T>? Right)
                        {
                            return !Equals(Left, Right);
                        }
                        public override Boolean Equals(Object obj)
                        {
                            if (obj == null) { return Equals(this, null); }
                            if (obj.GetType() != typeof(Optional<T>)) { return false; }
                            var o = (Optional<T>)(obj);
                            return Equals(this, o);
                        }
                        public override Int32 GetHashCode()
                        {
                            if (OnNotHasValue) { return 0; }
                            return HasValue.GetHashCode();
                        }

                        private static Boolean Equals(Optional<T> Left, Optional<T> Right)
                        {
                            if (Left.OnNotHasValue && Right.OnNotHasValue)
                            {
                                return true;
                            }
                            if (Left.OnNotHasValue || Right.OnNotHasValue)
                            {
                                return false;
                            }
                            return Left.HasValue.Equals(Right.HasValue);
                        }
                        private static Boolean Equals(Optional<T>? Left, Optional<T>? Right)
                        {
                            if ((!Left.HasValue || Left.Value.OnNotHasValue) && (!Right.HasValue || Right.Value.OnNotHasValue))
                            {
                                return true;
                            }
                            if (!Left.HasValue || Left.Value.OnNotHasValue || !Right.HasValue || Right.Value.OnNotHasValue)
                            {
                                return false;
                            }
                            return Equals(Left.Value, Right.Value);
                        }

                        public T Value
                        {
                            get
                            {
                                if (OnHasValue)
                                {
                                    return HasValue;
                                }
                                else
                                {
                                    throw new InvalidOperationException();
                                }
                            }
                        }
                        public T ValueOrDefault(T Default)
                        {
                            if (OnHasValue)
                            {
                                return HasValue;
                            }
                            else
                            {
                                return Default;
                            }
                        }

                        public override String ToString()
                        {
                            if (OnHasValue)
                            {
                                return HasValue.ToString();
                            }
                            else
                            {
                                return "-";
                            }
                        }
                    }
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    //Reference:

                    using System;
                    using System.Collections.Generic;
        Template
            Name Primitive
            //Parameters: ${Name}, ${PlatformName}
            Value
                $String
                    using [[${Name}]] = ${PlatformName};
        Template
            Name Alias
            //Parameters: ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [Alias]
                    public sealed class [[${Name}]]
                    {
                        public [[${Type}]] Value { get; set; }

                        public static implicit operator [[${Name}]]([[${Type}]] o)
                        {
                            return new [[${Name}]] {Value = o};
                        }
                        public static implicit operator [[${Type}]]([[${Name}]] c)
                        {
                            return c.Value;
                        }
                    }
        Template
            Name TupleElement
            //Parameters: ${NameIndex}, ${Type}
            Value
                $String
                    public [[${Type}]] [[Item${NameIndex}]] { get; set; }
        Template
            Name Tuple
            //Parameters: ${Name}, ${TupleElements}
            Value
                $String
                    [Tuple]
                    public sealed class [[${Name}]]
                    {
                        ${TupleElements}
                    }
        Template
            Name Field
            //Parameters: ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public [[${Type}]] [[${Name}]] { get; set; }
        Template
            Name Record
            //Parameters: ${Name}, ${Fields}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [Record]
                    public sealed class [[${Name}]]
                    {
                        ${Fields}
                    }
        Template
            Name Alternative
            //Parameters: ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public [[${Type}]] [[${Name}]] { get; set; }
        Template
            Name AlternativeCreate
            //Parameters: ${TaggedUnionName}, ${TaggedUnionTagName}, ${Name}, ${Type}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public static [[${TaggedUnionName}]] [[Create${Name}]]([[${Type}]] Value) { return new [[${TaggedUnionName}]] { _Tag = [[${TaggedUnionTagName}.${Name}]], [[${Name}]] = Value }; }
        Template
            Name AlternativeCreateUnit
            //Parameters: ${TaggedUnionName}, ${TaggedUnionTagName}, ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public static [[${TaggedUnionName}]] [[Create${Name}]]() { return new [[${TaggedUnionName}]] { _Tag = [[${TaggedUnionTagName}.${Name}]], [[${Name}]] = new Unit() }; }
        Template
            Name AlternativePredicate
            //Parameters: ${TaggedUnionName}, ${TaggedUnionTagName}, ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public Boolean [[On${Name}]] { get { return _Tag == [[${TaggedUnionTagName}.${Name}]]; } }
        Template
            Name TaggedUnion
            //Parameters: ${Name}, ${TagName}, ${AlternativeLiterals}, ${Alternatives}, ${AlternativeCreates}, ${AlternativePredicates}, ${XmlComment}
            Value
                $String
                    public enum [[${TagName}]]
                    {
                        ${AlternativeLiterals}
                    }
                    ${XmlComment}
                    [TaggedUnion]
                    public sealed class [[${Name}]]
                    {
                        [Tag] public [[${TagName}]] _Tag { get; set; }

                        ${Alternatives}

                        ${AlternativeCreates}

                        ${AlternativePredicates}
                    }
        Template
            Name Literal
            //Parameters: ${Name}, ${Value}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [[${Name}]] = ${Value},
        Template
            Name LastLiteral
            //Parameters: ${Name}, ${Value}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [[${Name}]] = ${Value}
        Template
            Name Enum
            //Parameters: ${Name}, ${UnderlyingType}, ${Literals}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public enum [[${Name}]] : ${UnderlyingType}
                    {
                        ${Literals}
                    }
        Template
            Name EnumParser
            //Parameters: ${Name}, ${LiteralAdds}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public static class [[${Name}Parser]]
                    {
                        private static Dictionary<String, [[${Name}]]> d = new Dictionary<String, [[${Name}]]>(StringComparer.OrdinalIgnoreCase);
                        static [[${Name}Parser]]()
                        {
                            ${LiteralAdds}
                        }
                        public static [[${Name}]]? TryParse(String Value)
                        {
                            if (d.ContainsKey(Value)) { return d[Value]; }
                            return null;
                        }
                    }
        Template
            Name LiteralAdd
            //Parameters: ${EnumName}, ${LiteralName}, ${NameOrDescription}
            Value
                $String
                    d.Add("${NameOrDescription}", [[${EnumName}.${LiteralName}]]);
        Template
            Name EnumWriter
            //Parameters: ${Name}, ${LiteralAddWriters}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public static class [[${Name}Writer]]
                    {
                        private static Dictionary<[[${Name}]], String> d = new Dictionary<[[${Name}]], String>();
                        static [[${Name}Writer]]()
                        {
                            ${LiteralAddWriters}
                        }
                        public static String GetDescription([[${Name}]] Value)
                        {
                            return d[Value];
                        }
                    }
        Template
            Name LiteralAddWriter
            //Parameters: ${EnumName}, ${LiteralName}, ${Description}
            Value
                $String
                    if (!d.ContainsKey([[${EnumName}.${LiteralName}]])) { d.Add([[${EnumName}.${LiteralName}]], "${Description}"); }
        Template
            Name MultiLineXmlComment
            //Parameters: ${Description}
            Value
                $String
                    /// <summary>
                    /// ${Description}
                    /// </summary>
        Template
            Name SingleLineXmlComment
            //Parameters: ${Description}
            Value
                $String
                    /// <summary>${Description}</summary>
        Template
            Name IApplicationServer
            //Parameters: ${Commands}
            Value
                $String
                    public interface IApplicationServer
                    {
                        ${Commands}
                    }
        Template
            Name IApplicationServer_ClientCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    [[${Name}Reply]] [[${Name}]]([[${Name}Request]] r);
        Template
            Name IApplicationServer_ServerCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    event Action<[[${Name}Event]]> [[${Name}]];
        Template
            Name IApplicationClient
            //Parameters: ${Hash}, ${Commands}
            Value
                $String
                    public interface IApplicationClient
                    {
                        UInt64 Hash { get; }
                        void DequeueCallback(String CommandName);

                        ${Commands}
                    }
        Template
            Name IApplicationClient_ClientCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    void [[${Name}]]([[${Name}Request]] r, Action<[[${Name}Reply]]> Callback);
        Template
            Name IApplicationClient_ServerCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    event Action<[[${Name}Event]]> [[${Name}]];
        Template
            Name IEventPump
            //Parameters: ${Commands}
            Value
                $String
                    public interface IEventPump
                    {
                        ${Commands}
                    }
        Template
            Name IEventPump_ServerCommand
            //Parameters: ${Name}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    Action<[[${Name}Event]]> [[${Name}]] { get; }
