$Comment
    ==========================================================================

      File:        CSharpBinary.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C++二进制通讯模板
      Version:     2016.10.04.
      Copyright(C) F.R.C.

    ==========================================================================

#Option
    EnableEmbeddedExpr True

#Namespace Yuki.ObjectSchema.CppBinary

#Import
    System
    System.Collections.Generic
    System.Linq
    Firefly

#Template BinarySerializationServer Hash:UInt64 Commands:List<TypeDef> SchemaClosureGenerator:ISchemaClosureGenerator
    class BinarySerializationServer final
    {
    private:
        struct Hash
        {
            std::size_t operator() (const std::pair<std::wstring, std::uint32_t> &p) const
            {
                return std::hash<std::wstring>()(std::get<0>(p)) ^ std::get<1>(p);
            }
        };
        std::unordered_map<std::pair<std::wstring, std::uint32_t>, std::function<std::shared_ptr<std::vector<std::uint8_t>>(std::shared_ptr<IApplicationServer>, std::shared_ptr<std::vector<std::uint8_t>>)>, Hash> ClientCommands;
        std::unordered_map<std::pair<std::wstring, std::uint32_t>, std::function<void(std::shared_ptr<IApplicationServer>, std::shared_ptr<std::vector<std::uint8_t>>, std::function<void(std::shared_ptr<std::vector<std::uint8_t>>)>, std::function<void(const std::exception &)>)>, Hash> AsyncClientCommands;

    public:
        BinarySerializationServer()
        {
            $$
                foreach (var c in Commands)
                {
                    if (c.OnClientCommand)
                    {
                        var CommandName = c.ClientCommand.Name;
                        var Name = c.ClientCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        if (c.ClientCommand.Attributes.Any(a => a.Key == "Async"))
                        {
                            ##
                                AsyncClientCommands[std::pair<std::wstring, std::uint32_t>(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash})] = [](std::shared_ptr<IApplicationServer> s, std::shared_ptr<std::vector<std::uint8_t>> p, std::function<void(std::shared_ptr<std::vector<std::uint8_t>>)> Callback, std::function<void(const std::exception &)> OnFailure) -> void
                                {
                                    ByteArrayStream bas;
                                    bas.WriteBytes(p);
                                    bas.SetPosition(0);
                                    auto Request = BinaryTranslator::[[${Name}RequestFromBinary]](bas);
                                    s->[[${Name}]](Request, [=](std::shared_ptr<class [[${Name}Reply]]> Reply)
                                    {
                                        ByteArrayStream bas;
                                        bas.SetPosition(0);
                                        bas.SetLength(0);
                                        BinaryTranslator::[[${Name}ReplyToBinary]](bas, Reply);
                                        bas.SetPosition(0);
                                        Callback(bas.ReadBytes(bas.GetLength()));
                                    }, OnFailure);
                                };
                        }
                        else
                        {
                            ##
                                ClientCommands[std::pair<std::wstring, std::uint32_t>(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash})] = [](std::shared_ptr<IApplicationServer> s, std::shared_ptr<std::vector<std::uint8_t>> p) -> std::shared_ptr<std::vector<std::uint8_t>>
                                {
                                    ByteArrayStream bas;
                                    bas.WriteBytes(p);
                                    bas.SetPosition(0);
                                    auto Request = BinaryTranslator::[[${Name}RequestFromBinary]](bas);
                                    auto Reply = s->[[${Name}]](Request);
                                    bas.SetPosition(0);
                                    bas.SetLength(0);
                                    BinaryTranslator::[[${Name}ReplyToBinary]](bas, Reply);
                                    bas.SetPosition(0);
                                    return bas.ReadBytes(bas.GetLength());
                                };
                        }
                    }
                }
        }

        std::uint64_t Hash()
        {
            return 0x${Hash.ToString("X16", System.Globalization.CultureInfo.InvariantCulture)};
        }

        Boolean HasCommand(std::wstring CommandName, std::uint32_t CommandHash)
        {
            return ClientCommands.count(std::pair<String, std::uint32_t>(CommandName, CommandHash)) > 0;
        }
        Boolean HasCommandAsync(std::wstring CommandName, std::uint32_t CommandHash)
        {
            return AsyncClientCommands.count(std::pair<String, std::uint32_t>(CommandName, CommandHash)) > 0;
        }

        std::shared_ptr<std::vector<std::uint8_t>> ExecuteCommand(std::shared_ptr<IApplicationServer> s, std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters)
        {
            auto cmd = ClientCommands[std::pair<std::wstring, std::uint32_t>(CommandName, CommandHash)];
            return cmd(s, Parameters);
        }
        void ExecuteCommandAsync(std::shared_ptr<IApplicationServer> s, std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters, std::function<void(std::shared_ptr<std::vector<std::uint8_t>>)> Callback, std::function<void(const std::exception &)> OnFailure)
        {
            auto cmd = AsyncClientCommands[std::pair<std::wstring, std::uint32_t>(CommandName, CommandHash)];
            cmd(s, Parameters, Callback, OnFailure);
        }
    };
    class BinarySerializationServerEventDispatcher final
    {
    public:
        BinarySerializationServerEventDispatcher(std::shared_ptr<IApplicationServer> s)
        {
            $$
                foreach (var c in Commands)
                {
                    if (c.OnServerCommand)
                    {
                        var CommandName = c.ServerCommand.Name;
                        var Name = c.ServerCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            s->${Name} = [=](std::shared_ptr<class [[${Name}Event]]> e)
                            {
                                ByteArrayStream bas;
                                BinaryTranslator::[[${Name}EventToBinary]](bas, e);
                                bas.SetPosition(0);
                                if (ServerEvent != nullptr) { ServerEvent(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}, bas.ReadBytes(bas.GetLength())); }
                            };
                    }
                }
        }

        /// (std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters) -> void
        typedef std::function<void(std::wstring, std::uint32_t, std::shared_ptr<std::vector<std::uint8_t>>)> ServerEventDelegate;
        ServerEventDelegate ServerEvent;
    };

#Template IBinarySender
    class IBinarySender
    {
    public:
        virtual ~IBinarySender() {}

        virtual void Send(std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters) = 0;
    };

#Template BinarySerializationClient Hash:UInt64 Commands:List<TypeDef> SchemaClosureGenerator:ISchemaClosureGenerator
    class BinarySerializationClient final
    {
    private:
        struct Hash
        {
            std::size_t operator() (const std::pair<std::wstring, std::uint32_t> &p) const
            {
                return std::hash<std::wstring>()(std::get<0>(p)) ^ std::get<1>(p);
            }
        };
        typedef std::function<void(std::shared_ptr<std::vector<std::uint8_t>>)> ClientCommandCallback;
        typedef std::function<void(std::shared_ptr<std::vector<std::uint8_t>>)> ServerCommandCallback;

        class ApplicationClient : public IApplicationClient
        {
        public:
            std::shared_ptr<IBinarySender> s;
            std::unordered_map<std::wstring, std::shared_ptr<std::queue<std::pair<std::uint32_t, ClientCommandCallback>>>> ClientCommandCallbacks;

            std::uint64_t Hash()
            {
                return 0x${Hash.ToString("X16", System.Globalization.CultureInfo.InvariantCulture)};
            }

            void DequeueCallback(std::wstring CommandName)
            {
                ClientCommandCallbacks[CommandName]->pop();
            }

        private:
            void AddCallback(std::wstring CommandName, std::uint32_t CommandHash, ClientCommandCallback Callback)
            {
                if (ClientCommandCallbacks.count(CommandName) > 0)
                {
                    ClientCommandCallbacks[CommandName]->push(std::pair<std::uint32_t, ClientCommandCallback>(CommandHash, Callback));
                }
                else
                {
                    auto q = std::make_shared<std::queue<std::pair<std::uint32_t, ClientCommandCallback>>>();
                    q->push(std::pair<std::uint32_t, ClientCommandCallback>(CommandHash, Callback));
                    ClientCommandCallbacks[CommandName] = q;
                }
            }

        public:
            $$
                foreach (var c in Commands)
                {
                    if (c.OnClientCommand)
                    {
                        var CommandName = c.ClientCommand.Name;
                        var Name = c.ClientCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            void [[${Name}]](std::shared_ptr<class [[${Name}Request]]> r, std::function<void(std::shared_ptr<class [[${Name}Reply]]>)> Callback)
                            {
                                ByteArrayStream bas;
                                BinaryTranslator::[[${Name}RequestToBinary]](bas, r);
                                bas.SetPosition(0);
                                auto Request = bas.ReadBytes(bas.GetLength());
                                AddCallback(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}, [=](std::shared_ptr<std::vector<std::uint8_t>> Parameters)
                                {
                                    ByteArrayStream bas;
                                    bas.WriteBytes(Parameters);
                                    bas.SetPosition(0);
                                    auto Reply = BinaryTranslator::[[${Name}ReplyFromBinary]](bas);
                                    Callback(Reply);
                                });
                                s->Send(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}, Request);
                            }
                    }
                }
        };

        std::shared_ptr<ApplicationClient> c;
        std::unordered_map<std::pair<std::wstring, std::uint32_t>, ServerCommandCallback, Hash> ServerCommands;

    private:
        std::string w2s(std::wstring ws)
        {
            std::size_t n = std::wcstombs(nullptr, ws.c_str(), std::numeric_limits<std::size_t>::max());
            if (n == static_cast<std::size_t>(-1)) { throw std::logic_error("InvalidOperation"); }
            std::string s(n, 0);
            if (n == 0) { return s; }
            std::wcstombs(&s[0], ws.c_str(), n);
            return s;
        }

    public:
        BinarySerializationClient(std::shared_ptr<IBinarySender> s)
        {
            c = std::make_shared<ApplicationClient>();
            c->s = s;
            $$
                foreach (var c in Commands)
                {
                    if (c.OnServerCommand)
                    {
                        var CommandName = c.ServerCommand.Name;
                        var Name = c.ServerCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            ServerCommands[std::pair<String, std::uint32_t>(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash})] = [&](std::shared_ptr<std::vector<std::uint8_t>> Parameters)
                            {
                                ByteArrayStream bas;
                                bas.WriteBytes(Parameters);
                                bas.SetPosition(0);
                                auto e = BinaryTranslator::[[${Name}EventFromBinary]](bas);
                                if (c->[[${Name}]] != nullptr)
                                {
                                    c->[[${Name}]](e);
                                }
                            };
                    }
                }
        }

        std::shared_ptr<IApplicationClient> GetApplicationClient()
        {
            return c;
        }

        void HandleResult(std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters)
        {
            if (c->ClientCommandCallbacks.count(CommandName) > 0)
            {
                auto q = c->ClientCommandCallbacks[CommandName];
                if (q->size() == 0)
                {
                    throw std::logic_error("InvalidOperation: " + w2s(CommandName));
                }
                auto CallbackPair = q->front();
                if (std::get<0>(CallbackPair) != CommandHash)
                {
                    throw std::logic_error("InvalidOperation: " + w2s(CommandName));
                }
                q->pop();
                auto Callback = std::get<1>(CallbackPair);
                Callback(Parameters);
                return;
            }

            auto p = std::pair<std::wstring, std::uint32_t>(CommandName, CommandHash);
            if (ServerCommands.count(p) > 0)
            {
                auto a = ServerCommands[p];
                a(Parameters);
                return;
            }

            throw std::logic_error("InvalidOperation: " + w2s(CommandName));
        }
    };

#Template Streams
    class IReadableStream
    {
    public:
        virtual std::uint8_t ReadByte() = 0;
        virtual std::shared_ptr<std::vector<std::uint8_t>> ReadBytes(std::size_t Size) = 0;

        Unit ReadUnit()
        {
            return Unit();
        }
        Boolean ReadBoolean()
        {
            return ReadByte() != 0;
        }

        std::uint8_t ReadUInt8()
        {
            return ReadByte();
        }
        std::uint16_t ReadUInt16()
        {
            std::uint16_t o;
            o = static_cast<std::uint16_t>(static_cast<std::uint16_t>(ReadByte()) & static_cast<std::uint16_t>(0xFF));
            o = static_cast<std::uint16_t>(o | ((static_cast<std::uint16_t>(ReadByte()) & 0xFF) << 8));
            return o;
        }
        std::uint32_t ReadUInt32()
        {
            std::uint32_t o;
            o = static_cast<std::uint32_t>(ReadByte()) & 0xFF;
            o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 8);
            o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 16);
            o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 24);
            return o;
        }
        std::uint64_t ReadUInt64()
        {
            std::uint64_t o;
            o = static_cast<std::uint64_t>(ReadByte()) & 0xFF;
            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 8);
            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 16);
            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 24);
            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 32);
            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 40);
            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 48);
            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 56);
            return o;
        }
        std::int8_t ReadInt8()
        {
            return static_cast<std::int8_t>(ReadByte());
        }
        std::int16_t ReadInt16()
        {
            std::int16_t o;
            o = static_cast<std::int16_t>(static_cast<std::int16_t>(ReadByte()) & static_cast<std::int16_t>(0xFF));
            o = static_cast<std::int16_t>(o | ((static_cast<std::int16_t>(ReadByte()) & 0xFF) << 8));
            return o;
        }
        std::int32_t ReadInt32()
        {
            std::int32_t o;
            o = static_cast<std::int32_t>(ReadByte()) & 0xFF;
            o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 8);
            o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 16);
            o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 24);
            return o;
        }
        std::int64_t ReadInt64()
        {
            std::int64_t o;
            o = static_cast<std::int64_t>(ReadByte()) & 0xFF;
            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 8);
            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 16);
            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 24);
            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 32);
            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 40);
            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 48);
            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 56);
            return o;
        }

        float ReadFloat32()
        {
            std::int32_t i = ReadInt32();
            return *reinterpret_cast<float *>(&i);
        }
        double ReadFloat64()
        {
            std::int64_t i = ReadInt64();
            return *reinterpret_cast<double *>(&i);
        }

        String ReadString()
        {
            std::int32_t Length = ReadInt32();
            int n = static_cast<int>(Length);
            std::vector<std::uint8_t> Bytes;
            for (int k = 0; k < n; k += 1)
            {
                Bytes.push_back(ReadByte());
            }
            std::wstring_convert<std::codecvt_utf16<wchar_t, 0x10FFFF, std::little_endian>, wchar_t> conv;
            return conv.from_bytes(reinterpret_cast<const char *>(Bytes.data()), reinterpret_cast<const char *>(Bytes.data() + Bytes.size()));
        }

        virtual ~IReadableStream() {}
    };

    class IWritableStream
    {
    public:
        virtual void WriteByte(std::uint8_t b) = 0;
        virtual void WriteBytes(std::shared_ptr<std::vector<std::uint8_t>> l) = 0;

        void WriteUnit(Unit v)
        {
        }
        void WriteBoolean(Boolean v)
        {
            if (v)
            {
                WriteByte(0xFF);
            }
            else
            {
                WriteByte(0);
            }
        }

        void WriteUInt8(std::uint8_t v)
        {
            WriteByte(v);
        }
        void WriteUInt16(std::uint16_t v)
        {
            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
        }
        void WriteUInt32(std::uint32_t v)
        {
            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
        }
        void WriteUInt64(std::uint64_t v)
        {
            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 32) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 40) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 48) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 56) & 0xFF));
        }
        void WriteInt8(std::int8_t v)
        {
            WriteByte(static_cast<std::uint8_t>(v));
        }
        void WriteInt16(std::int16_t v)
        {
            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
        }
        void WriteInt32(std::int32_t v)
        {
            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
        }
        void WriteInt64(std::int64_t v)
        {
            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 32) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 40) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 48) & 0xFF));
            WriteByte(static_cast<std::uint8_t>((v >> 56) & 0xFF));
        }

        void WriteFloat32(float v)
        {
            WriteInt32(*reinterpret_cast<std::int32_t *>(&v));
        }
        void WriteFloat64(double v)
        {
            WriteInt64(*reinterpret_cast<std::int64_t *>(&v));
        }

        void WriteString(String v)
        {
            std::wstring_convert<std::codecvt_utf16<wchar_t, 0x10FFFF, std::little_endian>, wchar_t> conv;
            auto Bytes = conv.to_bytes(v);
            int n = static_cast<int>(Bytes.size());
            WriteInt32((std::int32_t)(n));
            for (int k = 0; k < n; k += 1)
            {
                WriteByte(static_cast<std::uint8_t>(Bytes[k]));
            }
        }

        virtual ~IWritableStream() {}
    };

    class IReadableWritableStream : public IReadableStream, public IWritableStream
    {
    public:
        virtual ~IReadableWritableStream() {}
    };

    class ByteArrayStream final : public IReadableWritableStream
    {
    private:
        std::vector<std::uint8_t> Buffer;
        std::size_t Position;
    public:
        ByteArrayStream() : Position(0)
        {
        }

        std::uint8_t ReadByte()
        {
            if (Position + 1 > Buffer.size()) { throw std::out_of_range(""); }
            std::uint8_t b = Buffer[Position];
            Position += 1;
            return b;
        }
        std::shared_ptr<std::vector<std::uint8_t>> ReadBytes(std::size_t Size)
        {
            if (Position + Size > Buffer.size()) { throw std::out_of_range(""); }
            auto l = std::make_shared<std::vector<std::uint8_t>>();
            l->resize(Size, 0);
            if (Size == 0) { return l; }
            std::copy(Buffer.data() + Position, Buffer.data() + Position + Size, l->data());
            Position += Size;
            return l;
        }

        void WriteByte(std::uint8_t b)
        {
            if (Position + 1 > Buffer.size()) { Buffer.resize(Position + 1, 0); }
            Buffer[Position] = b;
            Position += 1;
        }
        void WriteBytes(std::shared_ptr<std::vector<std::uint8_t>> l)
        {
            auto Size = l->size();
            if (Size == 0) { return; }
            if (Position + Size > Buffer.size()) { Buffer.resize(Position + Size, 0); }
            std::copy(l->data(), l->data() + Size, Buffer.data() + Position);
            Position += Size;
        }

        std::size_t GetPosition()
        {
            return Position;
        }

        void SetPosition(std::size_t Position)
        {
            this->Position = Position;
        }

        std::size_t GetLength()
        {
            return Buffer.size();
        }

        void SetLength(std::size_t Length)
        {
            Buffer.resize(Length, 0);
        }
    };

#Template BinaryTranslator Schema:Schema
    class BinaryTranslator final
    {
    public:
        ${GetBinaryTranslatorSerializers(Schema)}
    };

#Template BinaryTranslator_Primitive_Unit
    static Unit UnitFromBinary(IReadableStream &s)
    {
        return s.ReadUnit();
    }
    static void UnitToBinary(IWritableStream &s, Unit v)
    {
        s.WriteUnit(v);
    }

#Template BinaryTranslator_Primitive_Boolean
    static Boolean BooleanFromBinary(IReadableStream &s)
    {
        return s.ReadBoolean();
    }
    static void BooleanToBinary(IWritableStream &s, Boolean v)
    {
        s.WriteBoolean(v);
    }

#Template BinaryTranslator_Primitive_String
    static String StringFromBinary(IReadableStream &s)
    {
        return s.ReadString();
    }
    static void StringToBinary(IWritableStream &s, String v)
    {
        s.WriteString(v);
    }

#Template BinaryTranslator_Primitive_Int
    static Int IntFromBinary(IReadableStream &s)
    {
        return static_cast<Int>(s.ReadInt32());
    }
    static void IntToBinary(IWritableStream &s, Int v)
    {
        s.WriteInt32(static_cast<Int>(v));
    }

#Template BinaryTranslator_Primitive_Real
    static Real RealFromBinary(IReadableStream &s)
    {
        return s.ReadFloat64();
    }
    static void RealToBinary(IWritableStream &s, Real v)
    {
        s.WriteFloat64(v);
    }

#Template BinaryTranslator_Primitive_Byte
    static Byte ByteFromBinary(IReadableStream &s)
    {
        return s.ReadByte();
    }
    static void ByteToBinary(IWritableStream &s, Byte v)
    {
        s.WriteByte(v);
    }

#Template BinaryTranslator_Primitive_UInt8
    static UInt8 UInt8FromBinary(IReadableStream &s)
    {
        return s.ReadUInt8();
    }
    static void UInt8ToBinary(IWritableStream &s, UInt8 v)
    {
        s.WriteUInt8(v);
    }

#Template BinaryTranslator_Primitive_UInt16
    static UInt16 UInt16FromBinary(IReadableStream &s)
    {
        return s.ReadUInt16();
    }
    static void UInt16ToBinary(IWritableStream &s, UInt16 v)
    {
        s.WriteUInt16(v);
    }

#Template BinaryTranslator_Primitive_UInt32
    static UInt32 UInt32FromBinary(IReadableStream &s)
    {
        return s.ReadUInt32();
    }
    static void UInt32ToBinary(IWritableStream &s, UInt32 v)
    {
        s.WriteUInt32(v);
    }

#Template BinaryTranslator_Primitive_UInt64
    static UInt64 UInt64FromBinary(IReadableStream &s)
    {
        return s.ReadUInt64();
    }
    static void UInt64ToBinary(IWritableStream &s, UInt64 v)
    {
        s.WriteUInt64(v);
    }

#Template BinaryTranslator_Primitive_Int8
    static Int8 Int8FromBinary(IReadableStream &s)
    {
        return s.ReadInt8();
    }
    static void Int8ToBinary(IWritableStream &s, Int8 v)
    {
        s.WriteInt8(v);
    }

#Template BinaryTranslator_Primitive_Int16
    static Int16 Int16FromBinary(IReadableStream &s)
    {
        return s.ReadInt16();
    }
    static void Int16ToBinary(IWritableStream &s, Int16 v)
    {
        s.WriteInt16(v);
    }

#Template BinaryTranslator_Primitive_Int32
    static Int32 Int32FromBinary(IReadableStream &s)
    {
        return s.ReadInt32();
    }
    static void Int32ToBinary(IWritableStream &s, Int32 v)
    {
        s.WriteInt32(v);
    }

#Template BinaryTranslator_Primitive_Int64
    static Int64 Int64FromBinary(IReadableStream &s)
    {
        return s.ReadInt64();
    }
    static void Int64ToBinary(IWritableStream &s, Int64 v)
    {
        s.WriteInt64(v);
    }

#Template BinaryTranslator_Primitive_Float32
    static Float32 Float32FromBinary(IReadableStream &s)
    {
        return s.ReadFloat32();
    }
    static void Float32ToBinary(IWritableStream &s, Float32 v)
    {
        s.WriteFloat32(v);
    }

#Template BinaryTranslator_Primitive_Float64
    static Float64 Float64FromBinary(IReadableStream &s)
    {
        return s.ReadFloat64();
    }
    static void Float64ToBinary(IWritableStream &s, Float64 v)
    {
        s.WriteFloat64(v);
    }

#Template BinaryTranslator_Primitive_Type
    static Type TypeFromBinary(IReadableStream &s)
    {
        throw std::logic_error("NotSupported");
    }
    static void TypeToBinary(IWritableStream &s, Type v)
    {
        throw std::logic_error("NotSupported");
    }

#Template BinaryTranslator_Alias a:AliasDef
    $$
        var Name = a.TypeFriendlyName();
        var ValueTypeFriendlyName = a.Type.TypeFriendlyName();
    static std::shared_ptr<class [[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
    {
        auto o = std::make_shared<[[${Name}]]>();
        o->Value = [[${ValueTypeFriendlyName}FromBinary]](s);
        return o;
    }
    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<class [[${Name}]]> o)
    {
        [[${ValueTypeFriendlyName}ToBinary]](s, o->Value);
    }

#Template BinaryTranslator_Record r:RecordDef
    ${BinaryTranslator_Record(r.TypeFriendlyName(), r.Fields)}

#Template BinaryTranslator_Record Name:String Fields:List<VariableDef>
    static std::shared_ptr<class [[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
    {
        auto o = std::make_shared<[[${Name}]]>();
        $$
            foreach (var a in Fields)
            {
                ##
                    o->[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromBinary]](s);
            }
        return o;
    }
    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<class [[${Name}]]> o)
    {
        $$
            foreach (var a in Fields)
            {
                ##
                    [[${a.Type.TypeFriendlyName()}ToBinary]](s, o->[[${a.Name}]]);
            }
    }

#Template BinaryTranslator_TaggedUnion tu:TaggedUnionDef
    ${BinaryTranslator_TaggedUnion(tu.TypeFriendlyName(), tu.Alternatives)}

#Template BinaryTranslator_TaggedUnion Name:String Alternatives:List<VariableDef>
    ${BinaryTranslator_Enum(Name + "Tag", "Int", "Int")}
    static std::shared_ptr<class [[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
    {
        auto o = std::make_shared<[[${Name}]]>();
        o->_Tag = [[${Name}TagFromBinary]](s);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o->_Tag == [[${Name}Tag::${a.Name}]])
                    {
                        o->[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromBinary]](s);
                        return o;
                    }
            }
        throw std::logic_error("InvalidOperation");
    }
    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<class [[${Name}]]> o)
    {
        [[${Name}TagToBinary]](s, o->_Tag);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o->_Tag == [[${Name}Tag::${a.Name}]])
                    {
                        [[${a.Type.TypeFriendlyName()}ToBinary]](s, o->[[${a.Name}]]);
                        return;
                    }
            }
        throw std::logic_error("InvalidOperation");
    }

#Template BinaryTranslator_Enum e:EnumDef
    ${BinaryTranslator_Enum(e.TypeFriendlyName(), e.UnderlyingType.TypeFriendlyName(), GetTypeString(e.UnderlyingType))}

#Template BinaryTranslator_Enum Name:String UnderlyingTypeFriendlyName:String UnderlyingType:String
    static [[${Name}]] [[${Name}FromBinary]](IReadableStream &s)
    {
        return static_cast<[[${Name}]]>([[${UnderlyingTypeFriendlyName}FromBinary]](s));
    }
    static void [[${Name}ToBinary]](IWritableStream &s, [[${Name}]] o)
    {
        [[${UnderlyingTypeFriendlyName}ToBinary]](s, static_cast<${UnderlyingType}>(o));
    }

#Template BinaryTranslator_ClientCommand c:ClientCommandDef
    ${BinaryTranslator_Record(c.TypeFriendlyName() + "Request", c.OutParameters)}
    ${BinaryTranslator_TaggedUnion(c.TypeFriendlyName() + "Reply", c.InParameters)}

#Template BinaryTranslator_ServerCommand c:ServerCommandDef
    ${BinaryTranslator_Record(c.TypeFriendlyName() + "Event", c.OutParameters)}

#Template BinaryTranslator_Tuple tp:TypeSpec
    $$
        var TypeFriendlyName = tp.TypeFriendlyName();
        var TypeString = GetTypeString(tp);
    static [[${TypeString}]] [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
    {
        $$
            var ItemNames = new List<String>{};
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        auto [[Item${k}]] = [[${t.TypeFriendlyName()}FromBinary]](s);
                    ItemNames.Add("Item" + (k).ToString(System.Globalization.CultureInfo.InvariantCulture));
                    k += 1;
                }
            }
        return std::make_tuple(${String.Join(", ", ItemNames)});
    }
    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, [[${TypeString}]] t)
    {
        $$
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        [[${t.TypeFriendlyName()}ToBinary]](s, std::get<${k}>(t));
                    k += 1;
                }
            }
    }

#Template BinaryTranslator_Optional o:TypeSpec GenericOptionalType:TaggedUnionDef
    $$
        var ElementType = o.GenericTypeSpec.ParameterValues.Single();
        var Alternatives = GenericOptionalType.Alternatives.Select(a => new VariableDef { Name = a.Name, Type = a.Type.OnGenericParameterRef ? ElementType : a.Type, Attributes = a.Attributes, Description = a.Description }).ToList();
        var TypeFriendlyName = o.TypeFriendlyName();
        var TypeString = GetTypeString(o);
        var Name = "Optional";
    static [[${TypeString}]] [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
    {
        auto o = [[${TypeString}]]();
        o._Tag = OptionalTagFromBinary(s);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag::${a.Name}]])
                    {
                        o.[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromBinary]](s);
                        return o;
                    }
            }
        throw std::logic_error("InvalidOperation");
    }
    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, [[${TypeString}]] o)
    {
        OptionalTagToBinary(s, o._Tag);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag::${a.Name}]])
                    {
                        [[${a.Type.TypeFriendlyName()}ToBinary]](s, o.[[${a.Name}]]);
                        return;
                    }
            }
        throw std::logic_error("InvalidOperation");
    }

#Template BinaryTranslator_List l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l, true);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
    static std::shared_ptr<class [[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
    {
        auto l = std::make_shared<[[${TypeString}]]>();
        int Length = static_cast<int>(IntFromBinary(s));
        for (int k = 0; k < Length; k += 1)
        {
            l->push_back([[${ElementTypeFriendlyName}FromBinary]](s));
        }
        return l;
    }
    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<class [[${TypeString}]]> l)
    {
        int Length = static_cast<int>(l->size());
        IntToBinary(s, static_cast<Int>(Length));
        for (int k = 0; k < Length; k += 1)
        {
            [[${ElementTypeFriendlyName}ToBinary]](s, (*l)[k]);
        }
    }

#Template BinaryTranslator_Set l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l, true);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
    static std::shared_ptr<class [[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
    {
        auto l = std::make_shared<[[${TypeString}]]>();
        int Length = static_cast<int>(IntFromBinary(s));
        for (int k = 0; k < Length; k += 1)
        {
            l->insert([[${ElementTypeFriendlyName}FromBinary]](s));
        }
        return l;
    }
    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<class [[${TypeString}]]> l)
    {
        int Length = static_cast<int>(l->size());
        IntToBinary(s, static_cast<Int>(Length));
        for (auto i = l->begin(); i != l->end(); i.operator++())
        {
            [[${ElementTypeFriendlyName}ToBinary]](s, (*i));
        }
    }

#Template BinaryTranslator_Map l:TypeSpec
    $$
        var gp = l.GenericTypeSpec.ParameterValues;
        if (gp.Count != 2)
        {
            throw new ArgumentException();
        }
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l, true);
        var KeyTypeFriendlyName = gp[0].TypeFriendlyName();
        var ValueTypeFriendlyName = gp[1].TypeFriendlyName();
    static std::shared_ptr<class [[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
    {
        auto l = std::make_shared<[[${TypeString}]]>();
        int Length = static_cast<int>(IntFromBinary(s));
        for (int k = 0; k < Length; k += 1)
        {
            auto Key = [[${KeyTypeFriendlyName}FromBinary]](s);
            (*l)[Key] = [[${ValueTypeFriendlyName}FromBinary]](s);
        }
        return l;
    }
    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<class [[${TypeString}]]> l)
    {
        int Length = static_cast<int>(l->size());
        IntToBinary(s, static_cast<Int>(Length));
        for (auto i = l->begin(); i != l->end(); i.operator++())
        {
            [[${KeyTypeFriendlyName}ToBinary]](s, std::get<0>(*i));
            [[${ValueTypeFriendlyName}ToBinary]](s, std::get<1>(*i));
        }
    }

#Template Main Schema:Schema NamespaceName:String
    //==========================================================================
    //
    //  Notice:      This file is automatically generated.
    //               Please don't modify this file.
    //
    //==========================================================================

    #pragma once

    #include <cstdint>
    #include <cwchar>
    #include <limits>
    #include <cstdlib>
    #include <string>
    #include <codecvt>
    #include <locale>
    #include <vector>
    #include <queue>
    #include <unordered_set>
    #include <unordered_map>
    #include <tuple>
    #include <memory>
    #include <functional>
    #include <stdexcept>
    #include ${Schema.Imports.Where(i => IsInclude(i))}
    $$
        var Primitives = GetPrimitives(Schema);
        var ComplexTypes = GetComplexTypes(Schema);
    ${Primitives}
    ${WrapContents(NamespaceName, ComplexTypes)}

$End
