$Comment
    ==========================================================================

      File:        CSharpJson.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构Haxe JSON通讯模板
      Version:     2016.10.06.
      Copyright(C) F.R.C.

    ==========================================================================

#Option
    EnableEmbeddedExpr True

#Namespace Yuki.ObjectSchema.HaxeJson

#Import
    System
    System.Collections.Generic
    System.Linq
    Firefly

#Template IJsonSender
    interface IJsonSender
    {
        function send(commandName : String, commandHash : String, parameters : String) : Void;
    }

#Template JsonSerializationClient Hash:UInt64 Commands:List<TypeDef> SchemaClosureGenerator:ISchemaClosureGenerator
    private class ApplicationClient implements IApplicationClient
    {
        public var s : IJsonSender;
        public var clientCommandCallbacks : Map<String, Array<{commandHash : String, _callback : String -> Void}>>;

        public function new()
        {
        }

        public var hash(get, null) : String;
        public function get_hash() : String
        {
            return "${Hash.ToString("X16", System.Globalization.CultureInfo.InvariantCulture)}";
        }

        public function dequeueCallback(commandName : String) : Void
        {
            clientCommandCallbacks.get(commandName).shift();
        }

        private function addCallback(commandName : String, commandHash : String, _callback : String -> Void) : Void
        {
            if (clientCommandCallbacks.exists(commandName))
            {
                clientCommandCallbacks.get(commandName).push({commandHash : commandHash, _callback : _callback});
            }
            else
            {
                var q = new Array<{commandHash : String, _callback : String -> Void}>();
                q.push({commandHash : commandHash, _callback : _callback});
                clientCommandCallbacks.set(commandName, q);
            }
        }

        $$
            foreach (var c in Commands)
            {
                if (c.OnClientCommand)
                {
                    var CommandName = c.ClientCommand.Name;
                    var Name = c.ClientCommand.TypeFriendlyName();
                    var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                    ##
                        public function [[${LowercaseCamelize(Name)}]](r : [[${Name}Request]], _callback : [[${Name}Reply]] -> Void) : Void
                        {
                            var request = Json.stringify(JsonTranslator.[[${LowercaseCamelize(Name)}RequestToJson]](r));
                            addCallback(${GetEscapedStringLiteral(CommandName)}, "${CommandHash}", function(parameters) { return _callback(JsonTranslator.[[${LowercaseCamelize(Name)}ReplyFromJson]](Json.parse(parameters))); });
                            s.send(${GetEscapedStringLiteral(CommandName)}, "${CommandHash}", request);
                        }
                }
                else if (c.OnServerCommand)
                {
                    var Name = c.ServerCommand.TypeFriendlyName();
                    ##
                        public var [[${LowercaseCamelize(Name)}]] : [[${Name}Event]] -> Void;
                        public function [[raise${Name}]](e : [[${Name}Event]]) : Void { if ([[${LowercaseCamelize(Name)}]] != null) { [[${LowercaseCamelize(Name)}]](e); } }
                }
            }
    }

    @:final
    class JsonSerializationClient
    {
        public function getApplicationClient() : IApplicationClient
        {
            return c;
        }

        private var c : ApplicationClient;
        private var serverCommands : Map<String, {commandHash : String, _callback : String -> Void}>;

        public function new(s : IJsonSender)
        {
            c = new ApplicationClient();
            c.s = s;
            c.clientCommandCallbacks = new Map<String, Array<{commandHash : String, _callback : String -> Void}>>();
            serverCommands = new Map<String, {commandHash : String, _callback : String -> Void}>();
            $$
                foreach (var c in Commands)
                {
                    if (c.OnServerCommand)
                    {
                        var CommandName = c.ServerCommand.Name;
                        var Name = c.ServerCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            serverCommands.set(${GetEscapedStringLiteral(CommandName)}, {commandHash : "${CommandHash}", _callback : function(parameters) { c.[[raise${Name}]](JsonTranslator.[[${LowercaseCamelize(Name)}EventFromJson]](Json.parse(parameters))); }});
                    }
                }
        }

        public function handleResult(commandName : String, commandHash : String, parameters : String) : Void
        {
            if (c.clientCommandCallbacks.exists(commandName))
            {
                var q = c.clientCommandCallbacks.get(commandName);
                if (q.length == 0)
                {
                    throw "InvalidOperationException: " + commandName + "@" + commandHash;
                }
                var callbackPair = q[0];
                if (callbackPair.commandHash != commandHash)
                {
                    throw "InvalidOperationException: " + commandName + "@" + commandHash;
                }
                q.shift();
                var _callback = callbackPair._callback;
                _callback(parameters);
                return;
            }

            if (serverCommands.exists(commandName))
            {
                var callbackPair = serverCommands.get(commandName);
                if (callbackPair.commandHash != commandHash)
                {
                    throw "InvalidOperationException: " + commandName + "@" + commandHash;
                }
                var _callback = callbackPair._callback;
                _callback(parameters);
                return;
            }

            throw "InvalidOperationException: " + commandName + "@" + commandHash;
        }
    }

#Template JsonTranslator Schema:Schema
    @:final
    class JsonTranslator /* static */
    {
        private static function hasField(o : Dynamic, field : String) : Boolean
        {
            return Reflect.hasField(o, field);
        }
        private static function getField(o : Dynamic, field : String) : Dynamic
        {
            if (!Reflect.hasField(o, field)) { throw "InvalidOperation"; }
            return Reflect.field(o, field);
        }
        private static function setField(o : Dynamic, field : String, value : Dynamic) : Void
        {
            Reflect.setField(o, field, value);
        }

        ${GetJsonTranslatorSerializers(Schema)}
    }

#Template JsonTranslator_Primitive_Unit
    public static function unitFromJson(j : Dynamic) : Unit
    {
        return {};
    }
    public static function unitToJson(v : Unit) : Dynamic
    {
        return {};
    }

#Template JsonTranslator_Primitive_Boolean
    public static function booleanFromJson(j : Dynamic) : Boolean
    {
        return cast(j, Boolean);
    }
    public static function booleanToJson(v : Boolean) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_String
    public static function stringFromJson(j : Dynamic) : String
    {
        return cast(j, String);
    }
    public static function stringToJson(v : String) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_Int
    public static function intFromJson(j : Dynamic) : Int
    {
        return cast(j, Int);
    }
    public static function intToJson(v : Int)
    {
        return v;
    }

#Template JsonTranslator_Primitive_Real
    public static function realFromJson(j : Dynamic) : Real
    {
        return cast(j, Real);
    }
    public static function realToJson(v : Real) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_Byte
    public static function byteFromJson(j : Dynamic) : Byte
    {
        return cast(j, Byte);
    }
    public static function byteToJson(v : Byte) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_UInt8
    public static function uint8FromJson(j : Dynamic) : UInt8
    {
        return cast(j, UInt8);
    }
    public static function uint8ToJson(v : UInt8) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_UInt16
    public static function uint16FromJson(j : Dynamic) : UInt16
    {
        return cast(j, UInt16);
    }
    public static function uint16ToJson(v : UInt16) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_UInt32
    public static function uint32FromJson(j : Dynamic) : UInt32
    {
        return cast(j, UInt32);
    }
    public static function uint32ToJson(v : UInt32) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_UInt64
    public static function uint64FromJson(j : Dynamic) : UInt64
    {
        return cast(int64FromJson(j), UInt64);
    }
    public static function uint64ToJson(v : UInt64) : Dynamic
    {
        return int64ToJson(cast(v, Int64));
    }

#Template JsonTranslator_Primitive_Int8
    public static function int8FromJson(j : Dynamic) : Int8
    {
        return cast(j, Int8);
    }
    public static function int8ToJson(v : Int8) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_Int16
    public static function int16FromJson(j : Dynamic) : Int16
    {
        return cast(j, Int16);
    }
    public static function int16ToJson(v : Int16) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_Int32
    public static function int32FromJson(j : Dynamic) : Int32
    {
        return cast(j, Int32);
    }
    public static function int32ToJson(v : Int32) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_Int64
    public static function int64FromJson(j : Dynamic) : Int64
    {
        return Int64.fromFloat(cast(j, Float));
    }
    public static function int64ToJson(v : Int64) : Dynamic
    {
        return v.high * 4294967296.0 + v.low;
    }

#Template JsonTranslator_Primitive_Float32
    public static function float32FromJson(j : Dynamic) : Float32
    {
        return cast(j, Float32);
    }
    public static function float32ToJson(v : Float32) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_Float64
    public static function float64FromJson(j : Dynamic) : Float64
    {
        return cast(j, Float64);
    }
    public static function float64ToJson(v : Float64) : Dynamic
    {
        return v;
    }

#Template JsonTranslator_Primitive_Type
    public static function typeFromJson(j : Dynamic) : Void
    {
        throw "NotSupportedException";
    }
    public static function typeToJson(v : Dynamic) : Void
    {
        throw "NotSupportedException";
    }

#Template JsonTranslator_Alias a:AliasDef
    $$
        var Name = a.TypeFriendlyName();
        var ValueTypeFriendlyName = a.Type.TypeFriendlyName();
    public static function [[${LowercaseCamelize(Name)}FromJson]](j : Dynamic) : [[${Name}]]
    {
        return [[${LowercaseCamelize(ValueTypeFriendlyName)}FromJson]](j);
    }
    public static function [[${LowercaseCamelize(Name)}ToJson]](o : [[${Name}]]) : Dynamic
    {
        return [[${LowercaseCamelize(ValueTypeFriendlyName)}ToJson]](o);
    }

#Template JsonTranslator_Record r:RecordDef
    ${JsonTranslator_Record(r.TypeFriendlyName(), r.Fields)}

#Template JsonTranslator_Record Name:String Fields:List<VariableDef>
    public static function [[${LowercaseCamelize(Name)}FromJson]](j : Dynamic) : [[${Name}]]
    {
        return
        {
            $$
                foreach (var a in Fields)
                {
                    ##
                        [[${LowercaseCamelize(a.Name)}]] : [[${LowercaseCamelize(a.Type.TypeFriendlyName())}FromJson]](getField(j, ${GetEscapedStringLiteral(LowercaseCamelize(a.Name))})),
                }
        };
    }
    public static function [[${LowercaseCamelize(Name)}ToJson]](o : [[${Name}]]) : Dynamic
    {
        var j : Dynamic = {};
        $$
            foreach (var a in Fields)
            {
                ##
                    setField(j, ${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${LowercaseCamelize(a.Type.TypeFriendlyName())}ToJson]](o.[[${LowercaseCamelize(a.Name)}]]));
            }
        return j;
    }

#Template JsonTranslator_TaggedUnion tu:TaggedUnionDef
    ${JsonTranslator_TaggedUnion(tu.TypeFriendlyName(), tu.Alternatives)}

#Template JsonTranslator_TaggedUnion Name:String Alternatives:List<VariableDef>
    public static function [[${LowercaseCamelize(Name)}FromJson]](j : Dynamic) : [[${Name}]]
    {
        $$
            foreach (var a in Alternatives)
            {
                if ((a.Type.OnTypeRef) && (a.Type.TypeRef.Name == "Unit") && (a.Type.TypeRef.Version == ""))
                {
                    ##
                        if (hasField(j, ${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}))
                        {
                            return [[${Name}.${LowercaseCamelize(a.Name)}]];
                        }
                }
                else
                {
                    ##
                        if (hasField(j, ${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}))
                        {
                            var v = [[${LowercaseCamelize(a.Type.TypeFriendlyName())}FromJson]](getField(j, ${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}));
                            return [[${Name}.${LowercaseCamelize(a.Name)}]](v);
                        }
                }
            }
        throw "InvalidOperation";
    }
    public static function [[${LowercaseCamelize(Name)}ToJson]](o : [[${Name}]]) : Dynamic
    {
        var j : Dynamic = {};
        switch (o)
        {
        $$
            foreach (var a in Alternatives)
            {
                if ((a.Type.OnTypeRef) && (a.Type.TypeRef.Name == "Unit") && (a.Type.TypeRef.Version == ""))
                {
                    ##
                        case [[${LowercaseCamelize(a.Name)}]]:
                            setField(j, ${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, unitToJson({}));
                }
                else
                {
                    ##
                        case [[${LowercaseCamelize(a.Name)}]](v):
                            setField(j, ${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${LowercaseCamelize(a.Type.TypeFriendlyName())}ToJson]](v));
                }
            }
        }
        return j;
    }

#Template JsonTranslator_Enum e:EnumDef
    $$
        var Name = e.TypeFriendlyName();
    public static function [[${LowercaseCamelize(Name)}FromJson]](j : Dynamic) : ${GetTypeString(e.UnderlyingType)}
    {
        return cast(j, ${GetTypeString(e.UnderlyingType)});
    }
    public static function [[${LowercaseCamelize(Name)}ToJson]](o : ${GetTypeString(e.UnderlyingType)}) : Dynamic
    {
        return o;
    }

#Template JsonTranslator_ClientCommand c:ClientCommandDef
    ${JsonTranslator_Record(c.TypeFriendlyName() + "Request", c.OutParameters)}
    ${JsonTranslator_TaggedUnion(c.TypeFriendlyName() + "Reply", c.InParameters)}

#Template JsonTranslator_ServerCommand c:ServerCommandDef
    ${JsonTranslator_Record(c.TypeFriendlyName() + "Event", c.OutParameters)}

#Template JsonTranslator_Tuple tp:TypeSpec
    $$
        var Name = tp.TypeFriendlyName();
        var TypeString = GetTypeString(tp);
    public static function [[${LowercaseCamelize(Name)}FromJson]](j : Dynamic) : [[${Name}]]
    {
        var ja = cast(j, Array<Dynamic>);
        return
        {
            $$
                {
                    int k = 0;
                    foreach (var t in tp.Tuple)
                    {
                        ##
                            [[item${k}]] : [[${LowercaseCamelize(t.TypeFriendlyName())}FromJson]](ja[${k}]),
                        k += 1;
                    }
                }
        };
    }
    public static function [[${LowercaseCamelize(Name)}ToJson]](t : [[${Name}]]) : Dynamic
    {
        var ja = new Array<Dynamic>();
        $$
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        ja.push([[${LowercaseCamelize(t.TypeFriendlyName())}ToJson]](t.[[item${k}]]));
                    k += 1;
                }
            }
        return ja;
    }

#Template JsonTranslator_Optional o:TypeSpec
    $$
        var TypeFriendlyName = o.TypeFriendlyName();
        var TypeString = GetTypeString(o);
        var ElementTypeFriendlyName = o.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
    public static function [[${LowercaseCamelize(TypeFriendlyName)}FromJson]](j : Dynamic) : ${TypeString}
    {
        if (hasField(j, "notHasValue"))
        {
            return null;
        }
        if (hasField(j, "hasValue"))
        {
            var v = [[${LowercaseCamelize(ElementTypeFriendlyName)}FromJson]](getField(j, "hasValue"));
            return v;
        }
        throw "InvalidOperation";
    }
    public static function [[${LowercaseCamelize(TypeFriendlyName)}ToJson]](o : ${TypeString}) : Dynamic
    {
        var j : Dynamic = {};
        if (o == null)
        {
            setField(j, "notHasValue", unitToJson({}));
        }
        else
        {
            setField(j, "hasValue", [[${LowercaseCamelize(ElementTypeFriendlyName)}ToJson]](o));
        }
        return j;
    }

#Template JsonTranslator_List l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
    public static function [[${LowercaseCamelize(TypeFriendlyName)}FromJson]](j : Dynamic) : ${TypeString}
    {
        var ja = cast(j, Array<Dynamic>);
        var a = new ${TypeString}();
        for (e in ja)
        {
            a.push([[${LowercaseCamelize(ElementTypeFriendlyName)}FromJson]](e));
        }
        return a;
    }
    public static function [[${LowercaseCamelize(TypeFriendlyName)}ToJson]](c : ${TypeString}) : Dynamic
    {
        var ja = new Array<Dynamic>();
        for (e in c)
        {
            ja.push([[${LowercaseCamelize(ElementTypeFriendlyName)}ToJson]](e));
        }
        return ja;
    }

#Template JsonTranslator_Set l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
    public static function [[${LowercaseCamelize(TypeFriendlyName)}FromJson]](j : Dynamic) : ${TypeString}
    {
        var ja = cast(j, Array<Dynamic>);
        var a = new ${TypeString}();
        for (e in ja)
        {
            a.set([[${LowercaseCamelize(ElementTypeFriendlyName)}FromJson]](e), {});
        }
        return a;
    }
    public static function [[${LowercaseCamelize(TypeFriendlyName)}ToJson]](c : ${TypeString}) : Dynamic
    {
        var ja = new Array<Dynamic>();
        for (e in c.keys())
        {
            ja.push([[${LowercaseCamelize(ElementTypeFriendlyName)}ToJson]](e));
        }
        return ja;
    }

#Template JsonTranslator_Map l:TypeSpec
    $$
        var gp = l.GenericTypeSpec.ParameterValues;
        if (gp.Count != 2)
        {
            throw new ArgumentException();
        }
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var KeyTypeFriendlyName = gp[0].TypeFriendlyName();
        var ValueTypeFriendlyName = gp[1].TypeFriendlyName();
    public static function [[${LowercaseCamelize(TypeFriendlyName)}FromJson]](j : Dynamic) : ${TypeString}
    {
        var ja = cast(j, Array<Dynamic>);
        var a = new ${TypeString}();
        for (e in ja)
        {
            var key = [[${LowercaseCamelize(KeyTypeFriendlyName)}FromJson]](getField(e, "key"));
            var value = [[${LowercaseCamelize(ValueTypeFriendlyName)}FromJson]](getField(e, "value"));
            a.set(key, value);
        }
        return a;
    }
    public static function [[${LowercaseCamelize(TypeFriendlyName)}ToJson]](c : ${TypeString}) : Dynamic
    {
        var ja = new Array<Dynamic>();
        for (key in c.keys())
        {
            var value = c.get(key);
            var jp : Dynamic = {};
            setField(jp, "key", [[${LowercaseCamelize(KeyTypeFriendlyName)}ToJson]](key));
            setField(jp, "value", [[${LowercaseCamelize(ValueTypeFriendlyName)}ToJson]](value));
            ja.push(jp);
        }
        return ja;
    }

#Template Main Schema:Schema PackageName:String
    //==========================================================================
    //
    //  Notice:      This file is automatically generated.
    //               Please don't modify this file.
    //
    //==========================================================================

    $$
        if (PackageName != "")
        {
            ##
                package [[${PackageName}]];
        }
    import haxe.Json;
    import ${Schema.Imports};

    ${GetTypes(Schema)}

$End
