$Comment
    ==========================================================================

      File:        CSharpJson.tree
      Location:    Niveum.Object <Tree>
      Description: 对象类型结构C# JSON通讯模板
      Version:     2022.10.02.
      Copyright(C) F.R.C.

    ==========================================================================

#Option
    EnableEmbeddedExpr True

#Namespace Niveum.ObjectSchema.CSharpJson

#Import
    System
    System.Collections.Generic
    System.Linq
    Firefly

#Template JsonSerializationServer Hash:UInt64 Commands:List<TypeDef> SchemaClosureGenerator:ISchemaClosureGenerator NamespaceName:String
    public sealed class JsonSerializationServer
    {
        private Dictionary<String, Func<IApplicationServer, String, String>> ClientCommandsWithoutHash;
        private Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, String, String>> ClientCommands;
        private Dictionary<String, Func<IApplicationServer, String, Task<String>>> AsyncClientCommandsWithoutHash;
        private Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, String, Task<String>>> AsyncClientCommands;

        private class KeyValuePairEqualityComparer<TKey, TValue> : IEqualityComparer<KeyValuePair<TKey, TValue>>
        {
            public Boolean Equals(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y)
            {
                if (!x.Key.Equals(y.Key)) { return false; }
                if (!x.Value.Equals(y.Value)) { return false; }
                return true;
            }

            public int GetHashCode(KeyValuePair<TKey, TValue> obj)
            {
                var KeyHash = obj.Key.GetHashCode();
                var ValueHash = obj.Value.GetHashCode();
                return KeyHash ^ ((ValueHash << 9) | ((ValueHash >> (32 - 9)) & ((1 << 9) - 1)));
            }
        }

        public JsonSerializationServer()
        {
            ClientCommandsWithoutHash = new Dictionary<String, Func<IApplicationServer, String, String>>(StringComparer.OrdinalIgnoreCase);
            ClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, String, String>>(new KeyValuePairEqualityComparer<String, UInt32>());
            AsyncClientCommandsWithoutHash = new Dictionary<String, Func<IApplicationServer, String, Task<String>>>(StringComparer.OrdinalIgnoreCase);
            AsyncClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, String, Task<String>>>(new KeyValuePairEqualityComparer<String, UInt32>());
            $$
                foreach (var c in Commands)
                {
                    if (c.OnClientCommand)
                    {
                        var CommandNameString = GetEscapedStringLiteral(c.ClientCommand.FullName());
                        var RequestTypeString = GetSuffixedTypeString(c.ClientCommand.Name, c.ClientCommand.Version, "Request", NamespaceName);
                        var ReplyTypeString = GetSuffixedTypeString(c.ClientCommand.Name, c.ClientCommand.Version, "Reply", NamespaceName);
                        var RequestName = GetSuffixedTypeName(c.ClientCommand.Name, c.ClientCommand.Version, "Request", NamespaceName);
                        var ReplyName = GetSuffixedTypeName(c.ClientCommand.Name, c.ClientCommand.Version, "Reply", NamespaceName);
                        var Name = c.ClientCommand.GetTypeSpec().SimpleName(NamespaceName);
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().GetNonattributed().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        if (c.ClientCommand.Version == "")
                        {
                            if (c.ClientCommand.Attributes.Any(a => a.Key == "Async"))
                            {
                                ##
                                    AsyncClientCommandsWithoutHash.Add(${CommandNameString}, async (s, p) => JsonTranslator.[[${ReplyName}ToJson]](await s.[[${Name}]](JsonTranslator.[[${RequestName}FromJson]](JToken.Parse(p)))).ToString(Formatting.None));
                            }
                            else
                            {
                                ##
                                    ClientCommandsWithoutHash.Add(${CommandNameString}, (s, p) => JsonTranslator.[[${ReplyName}ToJson]](s.[[${Name}]](JsonTranslator.[[${RequestName}FromJson]](JToken.Parse(p)))).ToString(Formatting.None));
                            }
                        }
                        if (c.ClientCommand.Attributes.Any(a => a.Key == "Async"))
                        {
                            ##
                                AsyncClientCommands.Add(new KeyValuePair<String, UInt32>(${CommandNameString}, 0x${CommandHash}), async (s, p) => JsonTranslator.[[${ReplyName}ToJson]](await s.[[${Name}]](JsonTranslator.[[${RequestName}FromJson]](JToken.Parse(p)))).ToString(Formatting.None));
                        }
                        else
                        {
                            ##
                                ClientCommands.Add(new KeyValuePair<String, UInt32>(${CommandNameString}, 0x${CommandHash}), (s, p) => JsonTranslator.[[${ReplyName}ToJson]](s.[[${Name}]](JsonTranslator.[[${RequestName}FromJson]](JToken.Parse(p)))).ToString(Formatting.None));
                        }
                    }
                }
        }

        public UInt64 Hash
        {
            get
            {
                return 0x${Hash.ToString("X16", System.Globalization.CultureInfo.InvariantCulture)};
            }
        }

        public Boolean HasCommand(String CommandName)
        {
            return ClientCommandsWithoutHash.ContainsKey(CommandName);
        }
        public Boolean HasCommandAsync(String CommandName)
        {
            return AsyncClientCommandsWithoutHash.ContainsKey(CommandName);
        }

        public Boolean HasCommand(String CommandName, UInt32 CommandHash)
        {
            return ClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
        }
        public Boolean HasCommandAsync(String CommandName, UInt32 CommandHash)
        {
            return AsyncClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
        }

        public String ExecuteCommand(IApplicationServer s, String CommandName, String Parameters)
        {
            var cmd = ClientCommandsWithoutHash[CommandName];
            return cmd(s, Parameters);
        }
        public async Task<String> ExecuteCommandAsync(IApplicationServer s, String CommandName, String Parameters)
        {
            var cmd = AsyncClientCommandsWithoutHash[CommandName];
            return await cmd(s, Parameters);
        }

        public String ExecuteCommand(IApplicationServer s, String CommandName, UInt32 CommandHash, String Parameters)
        {
            var cmd = ClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
            return cmd(s, Parameters);
        }
        public async Task<String> ExecuteCommandAsync(IApplicationServer s, String CommandName, UInt32 CommandHash, String Parameters)
        {
            var cmd = AsyncClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
            return await cmd(s, Parameters);
        }
    }
    public sealed class JsonSerializationServerEventDispatcher
    {
        public JsonSerializationServerEventDispatcher(IApplicationServer s)
        {
            $$
                foreach (var c in Commands)
                {
                    if (c.OnServerCommand)
                    {
                        var CommandNameString = GetEscapedStringLiteral(c.ServerCommand.FullName());
                        var EventName = GetSuffixedTypeName(c.ServerCommand.Name, c.ServerCommand.Version, "Event", NamespaceName);
                        var Name = c.ServerCommand.GetTypeSpec().SimpleName(NamespaceName);
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().GetNonattributed().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            s.${Name} += e => OnServerEvent(${CommandNameString}, 0x${CommandHash}, JsonTranslator.[[${EventName}ToJson]](e).ToString(Formatting.None));
                    }
                }
        }

        public delegate void ServerEventDelegate(String CommandName, UInt32 CommandHash, String Parameters);
        public event ServerEventDelegate ServerEvent;
        private void OnServerEvent(String CommandName, UInt32 CommandHash, String Parameters)
        {
            if (ServerEvent != null) { ServerEvent(CommandName, CommandHash, Parameters); }
        }
    }

#Template IJsonSender
    public interface IJsonSender
    {
        void Send(String CommandName, UInt32 CommandHash, String Parameters, Action<Exception> OnError);
    }

#Template JsonSerializationClient Hash:UInt64 Commands:List<TypeDef> SchemaClosureGenerator:ISchemaClosureGenerator NamespaceName:String
    public sealed class JsonSerializationClient
    {
        private class KeyValuePairEqualityComparer<TKey, TValue> : IEqualityComparer<KeyValuePair<TKey, TValue>>
        {
            public Boolean Equals(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y)
            {
                if (!x.Key.Equals(y.Key)) { return false; }
                if (!x.Value.Equals(y.Value)) { return false; }
                return true;
            }

            public int GetHashCode(KeyValuePair<TKey, TValue> obj)
            {
                var KeyHash = obj.Key.GetHashCode();
                var ValueHash = obj.Value.GetHashCode();
                return KeyHash ^ ((ValueHash << 9) | ((ValueHash >> (32 - 9)) & ((1 << 9) - 1)));
            }
        }

        private class ClientCommandTriple
        {
            public UInt32 Hash;
            public Action<String> Callback;
            public Action<Exception> OnError;
        }
        private class ApplicationClient : IApplicationClient
        {
            public IJsonSender s;
            public Dictionary<String, Queue<ClientCommandTriple>> ClientCommandCallbacks;

            public UInt64 Hash
            {
                get
                {
                    return 0x${Hash.ToString("X16", System.Globalization.CultureInfo.InvariantCulture)};
                }
            }

            public void NotifyErrorCommand(String CommandName, String Message)
            {
                var q = ClientCommandCallbacks[CommandName];
                var t = q.Dequeue();
                t.OnError(new InvalidOperationException(Message));
            }

            private void AddCallback(String CommandName, UInt32 CommandHash, Action<String> Callback, Action<Exception> OnError)
            {
                if (ClientCommandCallbacks.ContainsKey(CommandName))
                {
                    ClientCommandCallbacks[CommandName].Enqueue(new ClientCommandTriple { Hash = CommandHash, Callback = Callback, OnError = OnError });
                }
                else
                {
                    var q = new Queue<ClientCommandTriple>();
                    q.Enqueue(new ClientCommandTriple { Hash = CommandHash, Callback = Callback, OnError = OnError });
                    ClientCommandCallbacks.Add(CommandName, q);
                }
            }

            $$
                foreach (var c in Commands)
                {
                    if (c.OnClientCommand)
                    {
                        var CommandNameString = GetEscapedStringLiteral(c.ClientCommand.FullName());
                        var RequestTypeString = GetSuffixedTypeString(c.ClientCommand.Name, c.ClientCommand.Version, "Request", NamespaceName);
                        var ReplyTypeString = GetSuffixedTypeString(c.ClientCommand.Name, c.ClientCommand.Version, "Reply", NamespaceName);
                        var RequestName = GetSuffixedTypeName(c.ClientCommand.Name, c.ClientCommand.Version, "Request", NamespaceName);
                        var ReplyName = GetSuffixedTypeName(c.ClientCommand.Name, c.ClientCommand.Version, "Reply", NamespaceName);
                        var Name = c.ClientCommand.GetTypeSpec().SimpleName(NamespaceName);
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().GetNonattributed().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            public Task<${ReplyTypeString}> [[${Name}]](${RequestTypeString} r)
                            {
                                var Source = new TaskCompletionSource<${ReplyTypeString}>();
                                var Request = JsonTranslator.[[${RequestName}ToJson]](r).ToString(Formatting.None);
                                AddCallback(${CommandNameString}, 0x${CommandHash}, Parameters => Source.SetResult(JsonTranslator.[[${ReplyName}FromJson]](JToken.Parse(Parameters))), e => Source.SetException(e));
                                s.Send(${CommandNameString}, 0x${CommandHash}, Request, e => Source.SetException(e));
                                return Source.Task;
                            }
                    }
                    else if (c.OnServerCommand)
                    {
                        var Name = c.ServerCommand.GetTypeSpec().SimpleName(NamespaceName);
                        var EventTypeString = GetSuffixedTypeString(c.ServerCommand.Name, c.ServerCommand.Version, "Event", NamespaceName);
                        ##
                            public event Action<${EventTypeString}> [[${Name}]];
                            public void [[Raise${Name}]](${EventTypeString} e) { if ([[${Name}]] != null) { [[${Name}]](e); } }
                    }
                }
        }

        private ApplicationClient c;
        private Dictionary<KeyValuePair<String, UInt32>, Action<String>> ServerCommands;

        public JsonSerializationClient(IJsonSender s)
        {
            c = new ApplicationClient();
            c.s = s;
            c.ClientCommandCallbacks = new Dictionary<String, Queue<ClientCommandTriple>>();
            ServerCommands = new Dictionary<KeyValuePair<String, UInt32>, Action<String>>(new KeyValuePairEqualityComparer<String, UInt32>());
            $$
                foreach (var c in Commands)
                {
                    if (c.OnServerCommand)
                    {
                        var CommandNameString = GetEscapedStringLiteral(c.ServerCommand.FullName());
                        var EventTypeString = GetSuffixedTypeString(c.ServerCommand.Name, c.ServerCommand.Version, "Event", NamespaceName);
                        var EventName = GetSuffixedTypeName(c.ServerCommand.Name, c.ServerCommand.Version, "Event", NamespaceName);
                        var Name = c.ServerCommand.GetTypeSpec().SimpleName(NamespaceName);
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().GetNonattributed().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            ServerCommands.Add(new KeyValuePair<String, UInt32>(${CommandNameString}, 0x${CommandHash}), Parameters => c.[[Raise${Name}]](JsonTranslator.[[${EventName}FromJson]](JToken.Parse(Parameters))));
                    }
                }
        }

        public IApplicationClient GetApplicationClient()
        {
            return c;
        }

        public void HandleResult(String CommandName, UInt32 CommandHash, String Parameters)
        {
            if (c.ClientCommandCallbacks.ContainsKey(CommandName))
            {
                var q = c.ClientCommandCallbacks[CommandName];
                if (q.Count == 0)
                {
                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                }
                var t = q.Peek();
                if (t.Hash != CommandHash)
                {
                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                }
                q.Dequeue();
                var Callback = t.Callback;
                Callback(Parameters);
                return;
            }

            var p = new KeyValuePair<String, UInt32>(CommandName, CommandHash);
            if (ServerCommands.ContainsKey(p))
            {
                var a = ServerCommands[p];
                a(Parameters);
                return;
            }

            throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
        }
    }

#Template JsonLogAspectWrapper Commands:List<TypeDef> NamespaceName:String
    public sealed class JsonLogAspectWrapper : IApplicationServer
    {
        private IApplicationServer Inner;

        public JsonLogAspectWrapper(IApplicationServer Inner)
        {
            this.Inner = Inner;
            $$
                foreach (var c in Commands.Where(c => c.OnServerCommand))
                {
                    var CommandNameString = GetEscapedStringLiteral(c.ServerCommand.FullName());
                    var EventTypeString = GetSuffixedTypeString(c.ServerCommand.Name, c.ServerCommand.Version, "Event", NamespaceName);
                    var EventName = GetSuffixedTypeName(c.ServerCommand.Name, c.ServerCommand.Version, "Event", NamespaceName);
                    var Name = c.ServerCommand.GetTypeSpec().SimpleName(NamespaceName);
                    ##
                        Inner.[[${Name}]] += e =>
                        {
                            if (ServerCommand != null) { ServerCommand(${CommandNameString}, JsonTranslator.[[${EventName}ToJson]](e).ToString(Formatting.None)); }
                            if ([[${Name}]] != null) { [[${Name}]](e); }
                        };
                }
        }

        public event Action<String, String> ClientCommandIn;
        public event Action<String, String> ClientCommandOut;
        public event Action<String, String> ServerCommand;

        $$
            foreach (var c in Commands)
            {
                if (c.OnClientCommand)
                {
                    var CommandNameString = GetEscapedStringLiteral(c.ClientCommand.FullName());
                    var RequestTypeString = GetSuffixedTypeString(c.ClientCommand.Name, c.ClientCommand.Version, "Request", NamespaceName);
                    var ReplyTypeString = GetSuffixedTypeString(c.ClientCommand.Name, c.ClientCommand.Version, "Reply", NamespaceName);
                    var RequestName = GetSuffixedTypeName(c.ClientCommand.Name, c.ClientCommand.Version, "Request", NamespaceName);
                    var ReplyName = GetSuffixedTypeName(c.ClientCommand.Name, c.ClientCommand.Version, "Reply", NamespaceName);
                    var Name = c.ClientCommand.GetTypeSpec().SimpleName(NamespaceName);
                    if (c.ClientCommand.Attributes.Any(a => a.Key == "Async"))
                    {
                        ##
                            public async Task<${ReplyTypeString}> [[${Name}]](${RequestTypeString} Request)
                            {
                                if (ClientCommandIn != null) { ClientCommandIn(${CommandNameString}, JsonTranslator.[[${RequestName}ToJson]](Request).ToString(Formatting.None)); }
                                var Reply = await Inner.[[${Name}]](Request);
                                if (ClientCommandOut != null) { ClientCommandOut(${CommandNameString}, JsonTranslator.[[${ReplyName}ToJson]](Reply).ToString(Formatting.None)); }
                                return Reply;
                            }
                    }
                    else
                    {
                        ##
                            public ${ReplyTypeString} [[${Name}]](${RequestTypeString} Request)
                            {
                                if (ClientCommandIn != null) { ClientCommandIn(${CommandNameString}, JsonTranslator.[[${RequestName}ToJson]](Request).ToString(Formatting.None)); }
                                var Reply = Inner.[[${Name}]](Request);
                                if (ClientCommandOut != null) { ClientCommandOut(${CommandNameString}, JsonTranslator.[[${ReplyName}ToJson]](Reply).ToString(Formatting.None)); }
                                return Reply;
                            }
                    }
                }
                else if (c.OnServerCommand)
                {
                    var EventTypeString = GetSuffixedTypeString(c.ServerCommand.Name, c.ServerCommand.Version, "Event", NamespaceName);
                    var Name = c.ServerCommand.GetTypeSpec().SimpleName(NamespaceName);
                    ##
                        public event Action<${EventTypeString}> [[${Name}]];
                }
            }
    }

#Template JsonTranslator Schema:Schema NamespaceName:String
    public static class JsonTranslator
    {
        ${GetJsonTranslatorSerializers(Schema, NamespaceName)}
    }

#Template JsonTranslator_Primitive_Unit
    public static Unit UnitFromJson(JToken j)
    {
        return new Unit();
    }
    public static JObject UnitToJson(Unit v)
    {
        return new JObject();
    }

#Template JsonTranslator_Primitive_Boolean
    public static Boolean BooleanFromJson(JToken j)
    {
        if (j.Type != JTokenType.Boolean) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToBoolean(jv.Value);
    }
    public static JValue BooleanToJson(Boolean v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_String
    public static String StringFromJson(JToken j)
    {
        if (j.Type != JTokenType.String) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToString(jv.Value);
    }
    public static JValue StringToJson(String v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int
    public static Int IntFromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt32(jv.Value);
    }
    public static JValue IntToJson(Int v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Real
    public static Real RealFromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToDouble(jv.Value);
    }
    public static JValue RealToJson(Real v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Byte
    public static Byte ByteFromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToByte(jv.Value);
    }
    public static JValue ByteToJson(Byte v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt8
    public static UInt8 UInt8FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToByte(jv.Value);
    }
    public static JValue UInt8ToJson(UInt8 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt16
    public static UInt16 UInt16FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToUInt16(jv.Value);
    }
    public static JValue UInt16ToJson(UInt16 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt32
    public static UInt32 UInt32FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToUInt32(jv.Value);
    }
    public static JValue UInt32ToJson(UInt32 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt64
    public static UInt64 UInt64FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToUInt64(jv.Value);
    }
    public static JValue UInt64ToJson(UInt64 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int8
    public static Int8 Int8FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToSByte(jv.Value);
    }
    public static JValue Int8ToJson(Int8 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int16
    public static Int16 Int16FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt16(jv.Value);
    }
    public static JValue Int16ToJson(Int16 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int32
    public static Int32 Int32FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt32(jv.Value);
    }
    public static JValue Int32ToJson(Int32 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int64
    public static Int64 Int64FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt64(jv.Value);
    }
    public static JValue Int64ToJson(Int64 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Float32
    public static Float32 Float32FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToSingle(jv.Value);
    }
    public static JValue Float32ToJson(Float32 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Float64
    public static Float64 Float64FromJson(JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToDouble(jv.Value);
    }
    public static JValue Float64ToJson(Float64 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Type
    public static Type TypeFromJson(JToken j)
    {
        throw new NotSupportedException();
    }
    public static JValue TypeToJson(Type v)
    {
        throw new NotSupportedException();
    }

#Template JsonTranslator_Alias a:AliasDef NamespaceName:String
    ${JsonTranslator_Alias(a.GetTypeSpec().SimpleName(NamespaceName), GetTypeString(a.GetTypeSpec(), NamespaceName), a.Type, NamespaceName)}

#Template JsonTranslator_Alias Name:String TypeString:String ValueType:TypeSpec NamespaceName:String
    $$
        var ValueSimpleName = ValueType.SimpleName(NamespaceName);
    public static ${TypeString} [[${Name}FromJson]](JToken j)
    {
        return new ${TypeString} { Value = [[${ValueSimpleName}FromJson]](j) };
    }
    public static JToken [[${Name}ToJson]](${TypeString} o)
    {
        return [[${ValueSimpleName}ToJson]](o.Value);
    }

#Template JsonTranslator_Record r:RecordDef NamespaceName:String
    ${JsonTranslator_Record(r.GetTypeSpec().SimpleName(NamespaceName), GetTypeString(r.GetTypeSpec(), NamespaceName), r.Fields, NamespaceName)}

#Template JsonTranslator_Record Name:String TypeString:String Fields:List<VariableDef> NamespaceName:String
    public static ${TypeString} [[${Name}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Object) { throw new InvalidOperationException(); }
        var jo = j as JObject;
        if (jo == null) { throw new InvalidOperationException(); }
        var o = new ${TypeString}();
        $$
            foreach (var a in Fields)
            {
                ##
                    o.[[${a.Name}]] = [[${a.Type.SimpleName(NamespaceName)}FromJson]](jo[${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}]);
            }
        return o;
    }
    public static JObject [[${Name}ToJson]](${TypeString} o)
    {
        var jo = new JObject();
        $$
            foreach (var a in Fields)
            {
                ##
                    jo.Add(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${a.Type.SimpleName(NamespaceName)}ToJson]](o.[[${a.Name}]]));
            }
        return jo;
    }

#Template JsonTranslator_TaggedUnion tu:TaggedUnionDef NamespaceName:String
    ${JsonTranslator_TaggedUnion(tu.GetTypeSpec().SimpleName(NamespaceName), GetTypeString(tu.GetTypeSpec(), NamespaceName), GetSuffixedTypeName(tu.Name, tu.Version, "Tag", NamespaceName), GetSuffixedTypeString(tu.Name, tu.Version, "Tag", NamespaceName), tu.Alternatives, NamespaceName)}

#Template JsonTranslator_TaggedUnion Name:String TypeString:String TagName:String TagTypeString:String Alternatives:List<VariableDef> NamespaceName:String
    ${JsonTranslator_Enum(TagName, TagTypeString, NamespaceName)}
    public static ${TypeString} [[${Name}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Object) { throw new InvalidOperationException(); }
        var jo = j as JObject;
        if (jo == null) { throw new InvalidOperationException(); }
        var o = new ${TypeString}();
        var d = (IDictionary<string, JToken>)(jo);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (d.ContainsKey(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}))
                    {
                        o._Tag = ${TagTypeString}.[[${a.Name}]];
                        o.[[${a.Name}]] = [[${a.Type.SimpleName(NamespaceName)}FromJson]](jo[${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}]);
                        return o;
                    }
            }
        throw new InvalidOperationException();
    }
    public static JObject [[${Name}ToJson]](${TypeString} o)
    {
        var jo = new JObject();
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == ${TagTypeString}.[[${a.Name}]])
                    {
                        jo.Add(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${a.Type.SimpleName(NamespaceName)}ToJson]](o.[[${a.Name}]]));
                        return jo;
                    }
            }
        throw new InvalidOperationException();
    }

#Template JsonTranslator_Enum e:EnumDef NamespaceName:String
    ${JsonTranslator_Enum(e.GetTypeSpec().SimpleName(NamespaceName), GetTypeString(e.GetTypeSpec(), NamespaceName), NamespaceName)}

#Template JsonTranslator_Enum Name:String TypeString:String NamespaceName:String
    public static ${TypeString} [[${Name}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Number) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return (${TypeString})(Convert.ToInt64(jv.Value));
    }
    public static JValue [[${Name}ToJson]](${TypeString} o)
    {
        return new JValue(Convert.ToInt64(o));
    }

#Template JsonTranslator_ClientCommand c:ClientCommandDef NamespaceName:String
    ${JsonTranslator_Record(GetSuffixedTypeName(c.Name, c.Version, "Request", NamespaceName), GetSuffixedTypeString(c.Name, c.Version, "Request", NamespaceName), c.OutParameters, NamespaceName)}
    ${JsonTranslator_TaggedUnion(GetSuffixedTypeName(c.Name, c.Version, "Reply", NamespaceName), GetSuffixedTypeString(c.Name, c.Version, "Reply", NamespaceName), GetSuffixedTypeName(c.Name, c.Version, "ReplyTag", NamespaceName), GetSuffixedTypeString(c.Name, c.Version, "ReplyTag", NamespaceName), c.InParameters, NamespaceName)}

#Template JsonTranslator_ServerCommand c:ServerCommandDef NamespaceName:String
    ${JsonTranslator_Record(GetSuffixedTypeName(c.Name, c.Version, "Event", NamespaceName), GetSuffixedTypeString(c.Name, c.Version, "Event", NamespaceName), c.OutParameters, NamespaceName)}

#Template JsonTranslator_Tuple tp:TypeSpec NamespaceName:String
    $$
        var SimpleName = tp.SimpleName(NamespaceName);
        var TypeString = GetTypeString(tp, NamespaceName);
    public static ${TypeString} [[${SimpleName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        $$
            var ItemNames = new List<String>{};
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        var [[Item${k + 1}]] = [[${t.SimpleName(NamespaceName)}FromJson]](ja[${k}]);
                    ItemNames.Add("Item" + (k + 1).ToString(System.Globalization.CultureInfo.InvariantCulture));
                    k += 1;
                }
            }
        return Tuple.Create(${String.Join(", ", ItemNames)});
    }
    public static JArray [[${SimpleName}ToJson]](${TypeString} t)
    {
        var ja = new JArray();
        $$
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        ja.Add([[${t.SimpleName(NamespaceName)}ToJson]](t.[[Item${k + 1}]]));
                    k += 1;
                }
            }
        return ja;
    }

#Template JsonTranslator_Optional o:TypeSpec GenericOptionalType:TaggedUnionDef NamespaceName:String
    $$
        var ElementType = o.GenericTypeSpec.ParameterValues.Single();
        var Alternatives = GenericOptionalType.Alternatives.Select(a => new VariableDef { Name = a.Name, Type = a.Type.OnGenericParameterRef ? ElementType : a.Type, Attributes = a.Attributes, Description = a.Description }).ToList();
        var SimpleName = o.SimpleName(NamespaceName);
        var TypeString = GetTypeString(o, NamespaceName);
    public static ${TypeString} [[${SimpleName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Object) { throw new InvalidOperationException(); }
        var jo = j as JObject;
        if (jo == null) { throw new InvalidOperationException(); }
        var o = new ${TypeString}();
        var d = (IDictionary<string, JToken>)(jo);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (d.ContainsKey(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}))
                    {
                        o._Tag = OptionalTag.[[${a.Name}]];
                        o.[[${a.Name}]] = [[${a.Type.SimpleName(NamespaceName)}FromJson]](jo[${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}]);
                        return o;
                    }
            }
        throw new InvalidOperationException();
    }
    public static JObject [[${SimpleName}ToJson]](${TypeString} o)
    {
        var jo = new JObject();
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == OptionalTag.[[${a.Name}]])
                    {
                        jo.Add(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${a.Type.SimpleName(NamespaceName)}ToJson]](o.[[${a.Name}]]));
                        return jo;
                    }
            }
        throw new InvalidOperationException();
    }

#Template JsonTranslator_List l:TypeSpec NamespaceName:String
    $$
        var SimpleName = l.SimpleName(NamespaceName);
        var TypeString = GetTypeString(l, NamespaceName);
        var ElementSimpleName = l.GenericTypeSpec.ParameterValues.Single().SimpleName(NamespaceName);
    public static ${TypeString} [[${SimpleName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        var a = new ${TypeString}();
        foreach (var e in ja.Children())
        {
            a.Add([[${ElementSimpleName}FromJson]](e));
        }
        return a;
    }
    public static JArray [[${SimpleName}ToJson]](${TypeString} c)
    {
        var ja = new JArray();
        foreach (var e in c)
        {
            ja.Add([[${ElementSimpleName}ToJson]](e));
        }
        return ja;
    }

#Template JsonTranslator_Set l:TypeSpec NamespaceName:String
    $$
        var SimpleName = l.SimpleName(NamespaceName);
        var TypeString = GetTypeString(l, NamespaceName);
        var ElementSimpleName = l.GenericTypeSpec.ParameterValues.Single().SimpleName(NamespaceName);
    public static ${TypeString} [[${SimpleName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        var a = new ${TypeString}();
        foreach (var e in ja.Children())
        {
            a.Add([[${ElementSimpleName}FromJson]](e));
        }
        return a;
    }
    public static JArray [[${SimpleName}ToJson]](${TypeString} c)
    {
        var ja = new JArray();
        foreach (var e in c)
        {
            ja.Add([[${ElementSimpleName}ToJson]](e));
        }
        return ja;
    }

#Template JsonTranslator_Map l:TypeSpec NamespaceName:String
    $$
        var gp = l.GenericTypeSpec.ParameterValues;
        if (gp.Count != 2)
        {
            throw new ArgumentException();
        }
        var SimpleName = l.SimpleName(NamespaceName);
        var TypeString = GetTypeString(l, NamespaceName);
        var KeySimpleName = gp[0].SimpleName(NamespaceName);
        var ValueSimpleName = gp[1].SimpleName(NamespaceName);
    public static ${TypeString} [[${SimpleName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        var a = new ${TypeString}();
        foreach (var e in ja.Children().OfType<JObject>())
        {
            var Key = [[${KeySimpleName}FromJson]](e["key"]);
            var Value = [[${ValueSimpleName}FromJson]](e["value"]);
            a.Add(Key, Value);
        }
        return a;
    }
    public static JArray [[${SimpleName}ToJson]](${TypeString} c)
    {
        var ja = new JArray();
        foreach (var e in c)
        {
            var je = new JObject();
            je.Add("key", [[${KeySimpleName}ToJson]](e.Key));
            je.Add("value", [[${ValueSimpleName}ToJson]](e.Value));
            ja.Add(je);
        }
        return ja;
    }

#Template Main Schema:Schema NamespaceName:String
    //==========================================================================
    //
    //  Notice:      This file is automatically generated.
    //               Please don't modify this file.
    //
    //==========================================================================

    //Reference:
    //NiveumJson

    using System;
    using System.Collections.Generic;
    using System.Linq;
    $$
        var Commands = Schema.Types.Where(t => t.OnClientCommand || t.OnServerCommand).ToList();
        if (Commands.Count > 0)
        {
            ##
                using System.Threading.Tasks;
        }
    using Niveum.Json;
    using ${Schema.Imports};

    ${GetTypes(Schema, NamespaceName)}

$End
