ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name Main
            //Parameters: ${Header}, ${Includes}, ${Contents}
            Value
                $String
                    ${Header}
                    #include ${Includes}

                    ${Contents}

                $End
        Template
            Name Namespace
            //Parameters: ${NamespaceName}, ${Contents}
            Value
                $String
                    namespace [[${NamespaceName}]]
                    {
                        ${Contents}
                    }
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    #pragma once

                    //Reference:

                    #include <cstdint>
                    #include <memory>
                    #include <string>
                    #include <functional>
                    #include <stdexcept>
                    #include <unordered_map>
                    typedef std::int32_t Int;
                    typedef double Real;
        Template
            Name Assembly
            //Parameters: ${Name}, ${Modules}, ${Hash}, ${ModuleInitializes}
            Value
                $String
                    class [[${Name}]]
                    {
                    public:
                        ${Modules}

                        [[${Name}]](std::shared_ptr<Yuki::ExpressionSchema::Assembly> a)
                        {
                            if (a->Hash != 0x${Hash}) { throw std::logic_error("InvalidOperation"); }
                            std::unordered_map<std::wstring, std::shared_ptr<Yuki::ExpressionSchema::ModuleDef>> _d_;
                            for (auto m : *a->Modules)
                            {
                                _d_[m->Name] = m;
                            }
                            ${ModuleInitializes}
                        }
                    };
        Template
            Name Assembly_Module
            //Parameters: ${Name}
            Value
                $String
                    std::shared_ptr<class [[${Name}]]> [[${Name}]];
        Template
            Name Assembly_ModuleInitialize
            //Parameters: ${Name}
            Value
                $String
                    [[${Name}]] = std::make_shared<class [[${Name}]]>(_d_[L"${Name}"]);
        Template
            Name Module
            //Parameters: ${Name}, ${FunctionContexts}, ${FunctionInitializes}, ${FunctionCalls}
            Value
                $String
                    class [[${Name}]]
                    {
                    private:
                        ${FunctionContexts}

                    public:
                        [[${Name}]](std::shared_ptr<Yuki::ExpressionSchema::ModuleDef> md)
                        {
                            std::unordered_map<std::wstring, std::shared_ptr<Yuki::ExpressionSchema::Expr>> fd;
                            for (auto _f_ : *md->Functions)
                            {
                                fd[_f_->Name] = _f_->Body;
                            }
                            ${FunctionInitializes}
                        }

                        ${FunctionCalls}
                    };
        Template
            Name Module_FunctionContext
            //Parameters: ${FunctionName}, ${ReturnType}
            Value
                $String
                    std::function<[[${ReturnType}]](Yuki::Expression::ExpressionParameterContext &)> [[Func_${FunctionName}]];
        Template
            Name Module_FunctionInitialize
            //Parameters: ${FunctionName}, ${Parameters}, ${ReturnType}
            Value
                $String
                    {
                        auto Body = fd[L"${FunctionName}"];
                    
                        Yuki::Expression::ExpressionParameterTypeProvider eptp;
                        ${Parameters}
                        Yuki::Expression::ExpressionCalculator ec;
                        [[Func_${FunctionName}]] = ec.BuildExpression<[[${ReturnType}]]>(eptp, Body);
                    }
        Template
            Name Module_FunctionInitialize_Parameter
            //Parameters: ${FunctionName}, ${Name}, ${Type}
            Value
                $String
                    eptp.Parameters[L"${Name}"] = Yuki::ExpressionSchema::PrimitiveType::${Type};
        Template
            Name Module_FunctionCall
            //Parameters: ${FunctionName}, ${ParameterList}, ${Parameters}, ${ReturnType}
            Value
                $String
                    [[${ReturnType}]] [[${FunctionName}]](${ParameterList})
                    {
                        Yuki::Expression::ExpressionParameterContext epc;
                        ${Parameters}
                        return [[Func_${FunctionName}]](epc);
                    }
        Template
            Name Module_FunctionCall_ParameterList_Parameter
            //Parameters: ${Name}, ${Type}
            Value
                $String
                    [[${Type}]] [[${Name}]]
        Template
            Name Module_FunctionCall_Parameter
            //Parameters: ${FunctionName}, ${Name}
            Value
                $String
                    epc.Parameters[L"${Name}"] = [[${Name}]];
