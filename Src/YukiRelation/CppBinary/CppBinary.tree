$Comment
    ==========================================================================

      File:        CppBinary.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C++二进制模板数据
      Version:     2012.05.02.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name Main
            //Parameters: ${Header}, ${Imports}, ${Primitives}, ${Contents}
            Value
                $String
                    ${Header}
                    using namespace ${Imports};
                    ${Primitives}

                    ${Contents}

                $End
        Template
            Name Namespace
            //Parameters: ${NamespaceName}, ${Contents}
            Value
                $String
                    namespace [[${NamespaceName}]]
                    {
                        ${Contents}
                    }
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    #pragma once

                    //Reference:

                    #include <cstdint>
                    #include <cwchar>
                    #include <climits>
                    #include <cstdlib>
                    #include <string>
                    #include <codecvt>
                    #include <vector>
                    #include <queue>
                    #include <unordered_set>
                    #include <unordered_map>
                    #include <memory>
                    #include <functional>
                    #include <stdexcept>
        Template
            Name BinaryServer
            //Parameters: ${Hash}, ${Commands}
            Value
                $String
                    template<typename TContext>
                    class BinaryServer /* final */
                    {
                    private:
                        struct Hash
                        {
                            std::size_t operator() (const std::pair<std::wstring, std::uint32_t> &p) const
                            {
                                return std::hash<std::wstring>()(std::get<0>(p)) ^ std::get<1>(p);
                            }
                        };
                        std::unordered_map<std::pair<std::wstring, std::uint32_t>, std::function<std::shared_ptr<std::vector<std::uint8_t>>(TContext &, std::shared_ptr<std::vector<std::uint8_t>>)>, Hash> ClientCommands;
                        std::shared_ptr<IServerImplementation<TContext>> i;

                    public:
                        BinaryServer(std::shared_ptr<IServerImplementation<TContext>> si)
                        {
                            i = si;
                            ${Commands}
                        }

                        std::uint64_t Hash()
                        {
                            return 0x${Hash};
                        }

                        Boolean HasCommand(std::wstring CommandName, std::uint32_t CommandHash)
                        {
                            return ClientCommands.count(std::pair<String, std::uint32_t>(CommandName, CommandHash)) > 0;
                        }

                        std::shared_ptr<std::vector<std::uint8_t>> ExecuteCommand(TContext &c, std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters)
                        {
                            auto cmd = ClientCommands[std::pair<std::wstring, std::uint32_t>(CommandName, CommandHash)];
                            return cmd(c, Parameters);
                        }

                        /// (TContext &c, std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters) -> void
                        typedef std::function<void(TContext &, std::wstring, std::uint32_t, std::shared_ptr<std::vector<std::uint8_t>>)> ServerEventDelegate;
                        ServerEventDelegate ServerEvent;
                    private:
                        void OnServerEvent(TContext &c, std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters)
                        {
                            if (ServerEvent != nullptr) { ServerEvent(c, CommandName, CommandHash, Parameters); }
                        }
                    };
        Template
            Name BinaryServer_ClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ClientCommands[std::pair<std::wstring, std::uint32_t>(L"${CommandName}", 0x${CommandHash})] = [&](TContext &c, std::shared_ptr<std::vector<std::uint8_t>> p) -> std::shared_ptr<std::vector<std::uint8_t>>
                    {
                        ByteArrayStream bas;
                        bas.WriteBytes(p);
                        bas.SetPosition(0);
                        auto Request = BinaryTranslator::[[${Name}RequestFromBinary]](bas);
                        auto Reply = i->[[${Name}]](c, Request);
                        bas.SetPosition(0);
                        bas.SetLength(0);
                        BinaryTranslator::[[${Name}ReplyToBinary]](bas, Reply);
                        bas.SetPosition(0);
                        return bas.ReadBytes(bas.GetLength());
                    };
        Template
            Name BinaryServer_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    i->${Name} = [&](TContext &c, std::shared_ptr<[[${Name}Event]]> e)
                    {
                        ByteArrayStream bas;
                        BinaryTranslator::[[${Name}EventToBinary]](bas, e);
                        bas.SetPosition(0);
                        OnServerEvent(c, L"${CommandName}", 0x${CommandHash}, bas.ReadBytes(bas.GetLength()));
                    };
        Template
            Name IBinarySender
            Value
                $String
                    class IBinarySender
                    {
                    public:
                        virtual void Send(std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters) = 0;

                        virtual ~IBinarySender() {}
                    };
        Template
            Name BinaryClient
            //Parameters: ${Hash}, ${ClientCommands}, ${ServerCommands}
            Value
                $String
                    template<typename TContext>
                    class BinaryClient /* final */
                    {
                    private:
                        struct Hash
                        {
                            std::size_t operator() (const std::pair<std::wstring, std::uint32_t> &p) const
                            {
                                return std::hash<std::wstring>()(std::get<0>(p)) ^ std::get<1>(p);
                            }
                        };
                        typedef std::function<void(TContext &, std::shared_ptr<std::vector<std::uint8_t>>)> CommandCallback;
                        std::shared_ptr<IBinarySender> s;
                        std::shared_ptr<IClientImplementation<TContext>> i;
                        std::unordered_map<std::wstring, std::shared_ptr<std::queue<std::pair<std::uint32_t, CommandCallback>>>> ClientCommandCallbacks;
                        std::unordered_map<std::pair<std::wstring, std::uint32_t>, CommandCallback, Hash> ServerCommands;

                    private:
                        std::string w2s(std::wstring ws)
                        {
                            std::size_t n = std::wcstombs(NULL, ws.c_str(), INT_MAX);
                            if ((int)(n) < 0) { throw std::logic_error("InvalidOperationException"); }
                            std::string s(n, 0);
                            std::wcstombs(&s[0], ws.c_str(), n);
                            return s;
                        }

                    public:
                        BinaryClient(std::shared_ptr<IBinarySender> s, std::shared_ptr<IClientImplementation<TContext>> ci)
                        {
                            this->s = s;
                            i = ci;
                            ${ServerCommands}
                        }

                        std::uint64_t Hash()
                        {
                            return 0x${Hash};
                        }

                        void HandleResult(TContext &c, std::wstring CommandName, std::uint32_t CommandHash, std::shared_ptr<std::vector<std::uint8_t>> Parameters)
                        {
                            if (ClientCommandCallbacks.count(CommandName) > 0)
                            {
                                auto q = ClientCommandCallbacks[CommandName];
                                if (q->size() == 0)
                                {
                                    throw std::logic_error("InvalidOperationException" + w2s(CommandName));
                                }
                                auto CallbackPair = q->front();
                                if (std::get<0>(CallbackPair) != CommandHash)
                                {
                                    throw std::logic_error("InvalidOperationException" + w2s(CommandName));
                                }
                                q->pop();
                                auto Callback = std::get<1>(CallbackPair);
                                Callback(c, Parameters);
                                return;
                            }

                            auto p = std::pair<std::wstring, std::uint32_t>(CommandName, CommandHash);
                            if (ServerCommands.count(p) > 0)
                            {
                                auto a = ServerCommands[p];
                                a(c, Parameters);
                                return;
                            }

                            throw std::logic_error("InvalidOperationException" + w2s(CommandName));
                        }

                        void DequeueCallback(std::wstring CommandName)
                        {
                            ClientCommandCallbacks[CommandName]->pop();
                        }

                    private:
                        void AddCallback(std::wstring CommandName, std::uint32_t CommandHash, CommandCallback Callback)
                        {
                            if (ClientCommandCallbacks.count(CommandName) > 0)
                            {
                                ClientCommandCallbacks[CommandName]->push(std::pair<std::uint32_t, CommandCallback>(CommandHash, Callback));
                            }
                            else
                            {
                                auto q = std::make_shared<std::queue<std::pair<std::uint32_t, CommandCallback>>>();
                                q->push(std::pair<std::uint32_t, CommandCallback>(CommandHash, Callback));
                                ClientCommandCallbacks[CommandName] = q;
                            }
                        }

                    public:
                        ${ClientCommands}
                    };
        Template
            Name BinaryClient_ClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    void [[${Name}]](std::shared_ptr<[[${Name}Request]]> r, std::function<void(TContext &, std::shared_ptr<[[${Name}Reply]]>)> Callback)
                    {
                        ByteArrayStream bas;
                        BinaryTranslator::[[${Name}RequestToBinary]](bas, r);
                        bas.SetPosition(0);
                        auto Request = bas.ReadBytes(bas.GetLength());
                        AddCallback(L"${CommandName}", 0x${CommandHash}, [=](TContext &c, std::shared_ptr<std::vector<std::uint8_t>> Parameters)
                        {
                            ByteArrayStream bas;
                            bas.WriteBytes(Parameters);
                            bas.SetPosition(0);
                            auto Reply = BinaryTranslator::[[${Name}ReplyFromBinary]](bas);
                            Callback(c, Reply);
                        });
                        s->Send(L"${CommandName}", 0x${CommandHash}, Request);
                    }
        Template
            Name BinaryClient_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ServerCommands[std::pair<String, std::uint32_t>(L"${CommandName}", 0x${CommandHash})] = [&](TContext &c, std::shared_ptr<std::vector<std::uint8_t>> Parameters)
                    {
                        ByteArrayStream bas;
                        bas.WriteBytes(Parameters);
                        bas.SetPosition(0);
                        auto e = BinaryTranslator::[[${Name}EventFromBinary]](bas);
                        i->[[${Name}]](c, e);
                    };
        Template
            Name Streams
            Value
                $String
                    class IReadableStream
                    {
                    public:
                        virtual std::uint8_t ReadByte() = 0;
                        virtual std::shared_ptr<std::vector<std::uint8_t>> ReadBytes(std::size_t Size) = 0;

                        Unit ReadUnit()
                        {
                            return Unit();
                        }
                        Boolean ReadBoolean()
                        {
                            return ReadByte() != 0;
                        }

                        std::uint8_t ReadUInt8()
                        {
                            return ReadByte();
                        }
                        std::uint16_t ReadUInt16()
                        {
                            std::uint16_t o;
                            o = static_cast<std::uint16_t>(static_cast<std::uint16_t>(ReadByte()) & static_cast<std::uint16_t>(0xFF));
                            o = static_cast<std::uint16_t>(o | ((static_cast<std::uint16_t>(ReadByte()) & 0xFF) << 8));
                            return o;
                        }
                        std::uint32_t ReadUInt32()
                        {
                            std::uint32_t o;
                            o = static_cast<std::uint32_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<std::uint32_t>(ReadByte()) & 0xFF) << 24);
                            return o;
                        }
                        std::uint64_t ReadUInt64()
                        {
                            std::uint64_t o;
                            o = static_cast<std::uint64_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 24);
                            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 32);
                            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 40);
                            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 48);
                            o = o | ((static_cast<std::uint64_t>(ReadByte()) & 0xFF) << 56);
                            return o;
                        }
                        std::int8_t ReadInt8()
                        {
                            return static_cast<std::int8_t>(ReadByte());
                        }
                        std::int16_t ReadInt16()
                        {
                            std::int16_t o;
                            o = static_cast<std::int16_t>(static_cast<std::int16_t>(ReadByte()) & static_cast<std::int16_t>(0xFF));
                            o = static_cast<std::int16_t>(o | ((static_cast<std::int16_t>(ReadByte()) & 0xFF) << 8));
                            return o;
                        }
                        std::int32_t ReadInt32()
                        {
                            std::int32_t o;
                            o = static_cast<std::int32_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<std::int32_t>(ReadByte()) & 0xFF) << 24);
                            return o;
                        }
                        std::int64_t ReadInt64()
                        {
                            std::int64_t o;
                            o = static_cast<std::int64_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 24);
                            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 32);
                            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 40);
                            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 48);
                            o = o | ((static_cast<std::int64_t>(ReadByte()) & 0xFF) << 56);
                            return o;
                        }

                        float ReadFloat32()
                        {
                            std::int32_t i = ReadInt32();
                            return *reinterpret_cast<float *>(&i);
                        }
                        double ReadFloat64()
                        {
                            std::int64_t i = ReadInt64();
                            return *reinterpret_cast<double *>(&i);
                        }

                        String ReadString()
                        {
                            std::int32_t Length = ReadInt32();
                            int n = (int)(Length);
                            std::vector<std::uint8_t> Bytes;
                            for (int k = 0; k < n; k += 1)
                            {
                                Bytes.push_back(ReadByte());
                            }
                            std::wstring_convert<std::codecvt_utf16<wchar_t, 0x10FFFF, std::little_endian>, wchar_t> conv;
                            return conv.from_bytes(reinterpret_cast<const char *>(Bytes.data()), reinterpret_cast<const char *>(Bytes.data() + Bytes.size()));
                        }

                        virtual ~IReadableStream() {}
                    };

                    class IWritableStream
                    {
                    public:
                        virtual void WriteByte(std::uint8_t b) = 0;
                        virtual void WriteBytes(std::shared_ptr<std::vector<std::uint8_t>> l) = 0;

                        void WriteUnit(Unit v)
                        {
                        }
                        void WriteBoolean(Boolean v)
                        {
                            if (v)
                            {
                                WriteByte(0xFF);
                            }
                            else
                            {
                                WriteByte(0);
                            }
                        }

                        void WriteUInt8(std::uint8_t v)
                        {
                            WriteByte(v);
                        }
                        void WriteUInt16(std::uint16_t v)
                        {
                            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                        }
                        void WriteUInt32(std::uint32_t v)
                        {
                            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
                        }
                        void WriteUInt64(std::uint64_t v)
                        {
                            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 32) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 40) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 48) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 56) & 0xFF));
                        }
                        void WriteInt8(std::int8_t v)
                        {
                            WriteByte(static_cast<std::uint8_t>(v));
                        }
                        void WriteInt16(std::int16_t v)
                        {
                            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                        }
                        void WriteInt32(std::int32_t v)
                        {
                            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
                        }
                        void WriteInt64(std::int64_t v)
                        {
                            WriteByte(static_cast<std::uint8_t>(v & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 24) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 32) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 40) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 48) & 0xFF));
                            WriteByte(static_cast<std::uint8_t>((v >> 56) & 0xFF));
                        }

                        void WriteFloat32(float v)
                        {
                            WriteInt32(*reinterpret_cast<std::int32_t *>(&v));
                        }
                        void WriteFloat64(double v)
                        {
                            WriteInt64(*reinterpret_cast<std::int64_t *>(&v));
                        }

                        void WriteString(String v)
                        {
                            std::wstring_convert<std::codecvt_utf16<wchar_t, 0x10FFFF, std::little_endian>, wchar_t> conv;
                            auto Bytes = conv.to_bytes(v);
                            int n = (int)(Bytes.size());
                            WriteInt32((std::int32_t)(n));
                            for (int k = 0; k < n; k += 1)
                            {
                                WriteByte(static_cast<std::uint8_t>(Bytes[k]));
                            }
                        }

                        virtual ~IWritableStream() {}
                    };

                    class IReadableWritableStream : public IReadableStream, public IWritableStream
                    {
                    public:
                        virtual ~IReadableWritableStream() {}
                    };

                    class ByteArrayStream : public IReadableWritableStream /* final */
                    {
                    private:
                        std::vector<std::uint8_t> Buffer;
                        std::size_t Position;
                    public:
                        ByteArrayStream() : Position(0)
                        {
                        }

                        std::uint8_t ReadByte()
                        {
                            if (Position + 1 > Buffer.size()) { throw std::out_of_range(""); }
                            std::uint8_t b = Buffer[Position];
                            Position += 1;
                            return b;
                        }
                        std::shared_ptr<std::vector<std::uint8_t>> ReadBytes(std::size_t Size)
                        {
                            if (Position + Size > Buffer.size()) { throw std::out_of_range(""); }
                            auto l = std::make_shared<std::vector<std::uint8_t>>();
                            l->resize(Size, 0);
                            if (Size == 0) { return l; }
                            std::copy(Buffer.data() + Position, Buffer.data() + Position + Size, l->data());
                            Position += Size;
                            return l;
                        }

                        void WriteByte(std::uint8_t b)
                        {
                            if (Position + 1 > Buffer.size()) { Buffer.resize(Position + 1, 0); }
                            Buffer[Position] = b;
                            Position += 1;
                        }
                        void WriteBytes(std::shared_ptr<std::vector<std::uint8_t>> l)
                        {
                            auto Size = l->size();
                            if (Size == 0) { return; }
                            if (Position + Size > Buffer.size()) { Buffer.resize(Position + Size, 0); }
                            std::copy(l->data(), l->data() + Size, Buffer.data() + Position);
                            Position += Size;
                        }

                        std::size_t GetPosition()
                        {
                            return Position;
                        }

                        void SetPosition(std::size_t Position)
                        {
                            this->Position = Position;
                        }

                        std::size_t GetLength()
                        {
                            return Buffer.size();
                        }

                        void SetLength(std::size_t Length)
                        {
                            Buffer.resize(Length, 0);
                        }
                    };
        Template
            Name BinaryTranslator
            //Parameters: ${Serializers}
            Value
                $String
                    class BinaryTranslator /* final */
                    {
                    public:
                        ${Serializers}
                    };
        Template
            Name BinaryTranslator_Primitive_Unit
            Value
                $String
                    static Unit UnitFromBinary(IReadableStream &s)
                    {
                        return s.ReadUnit();
                    }
                    static void UnitToBinary(IWritableStream &s, Unit v)
                    {
                        s.WriteUnit(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Boolean
            Value
                $String
                    static Boolean BooleanFromBinary(IReadableStream &s)
                    {
                        return s.ReadBoolean();
                    }
                    static void BooleanToBinary(IWritableStream &s, Boolean v)
                    {
                        s.WriteBoolean(v);
                    }
        Template
            Name BinaryTranslator_Primitive_String
            Value
                $String
                    static String StringFromBinary(IReadableStream &s)
                    {
                        return s.ReadString();
                    }
                    static void StringToBinary(IWritableStream &s, String v)
                    {
                        s.WriteString(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int
            Value
                $String
                    static Int IntFromBinary(IReadableStream &s)
                    {
                        return (Int)(s.ReadInt32());
                    }
                    static void IntToBinary(IWritableStream &s, Int v)
                    {
                        s.WriteInt32((Int32)(v));
                    }
        Template
            Name BinaryTranslator_Primitive_Real
            Value
                $String
                    static Real RealFromBinary(IReadableStream &s)
                    {
                        return s.ReadFloat64();
                    }
                    static void RealToBinary(IWritableStream &s, Real v)
                    {
                        s.WriteFloat64(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Byte
            Value
                $String
                    static Byte ByteFromBinary(IReadableStream &s)
                    {
                        return s.ReadByte();
                    }
                    static void ByteToBinary(IWritableStream &s, Byte v)
                    {
                        s.WriteByte(v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt8
            Value
                $String
                    static UInt8 UInt8FromBinary(IReadableStream &s)
                    {
                        return s.ReadUInt8();
                    }
                    static void UInt8ToBinary(IWritableStream &s, UInt8 v)
                    {
                        s.WriteUInt8(v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt16
            Value
                $String
                    static UInt16 UInt16FromBinary(IReadableStream &s)
                    {
                        return s.ReadUInt16();
                    }
                    static void UInt16ToBinary(IWritableStream &s, UInt16 v)
                    {
                        s.WriteUInt16(v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt32
            Value
                $String
                    static UInt32 UInt32FromBinary(IReadableStream &s)
                    {
                        return s.ReadUInt32();
                    }
                    static void UInt32ToBinary(IWritableStream &s, UInt32 v)
                    {
                        s.WriteUInt32(v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt64
            Value
                $String
                    static UInt64 UInt64FromBinary(IReadableStream &s)
                    {
                        return s.ReadUInt64();
                    }
                    static void UInt64ToBinary(IWritableStream &s, UInt64 v)
                    {
                        s.WriteUInt64(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int8
            Value
                $String
                    static Int8 Int8FromBinary(IReadableStream &s)
                    {
                        return s.ReadInt8();
                    }
                    static void Int8ToBinary(IWritableStream &s, Int8 v)
                    {
                        s.WriteInt8(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int16
            Value
                $String
                    static Int16 Int16FromBinary(IReadableStream &s)
                    {
                        return s.ReadInt16();
                    }
                    static void Int16ToBinary(IWritableStream &s, Int16 v)
                    {
                        s.WriteInt16(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int32
            Value
                $String
                    static Int32 Int32FromBinary(IReadableStream &s)
                    {
                        return s.ReadInt32();
                    }
                    static void Int32ToBinary(IWritableStream &s, Int32 v)
                    {
                        s.WriteInt32(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int64
            Value
                $String
                    static Int64 Int64FromBinary(IReadableStream &s)
                    {
                        return s.ReadInt64();
                    }
                    static void Int64ToBinary(IWritableStream &s, Int64 v)
                    {
                        s.WriteInt64(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Float32
            Value
                $String
                    static Float32 Float32FromBinary(IReadableStream &s)
                    {
                        return s.ReadFloat32();
                    }
                    static void Float32ToBinary(IWritableStream &s, Float32 v)
                    {
                        s.WriteFloat32(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Float64
            Value
                $String
                    static Float64 Float64FromBinary(IReadableStream &s)
                    {
                        return s.ReadFloat64();
                    }
                    static void Float64ToBinary(IWritableStream &s, Float64 v)
                    {
                        s.WriteFloat64(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Type
            Value
                $String
                    static Type TypeFromBinary(IReadableStream &s)
                    {
                        throw std::logic_error("NotSupported");
                    }
                    static void TypeToBinary(IWritableStream &s, Type v)
                    {
                        throw std::logic_error("NotSupported");
                    }
        Template
            Name BinaryTranslator_Alias
            //Parameters: ${Name}, ${ValueTypeFriendlyName}
            Value
                $String
                    static std::shared_ptr<[[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${Name}]]>();
                        o->Value = [[${ValueTypeFriendlyName}FromBinary]](s);
                        return o;
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<[[${Name}]]> o)
                    {
                        [[${ValueTypeFriendlyName}ToBinary]](s, o->Value);
                    }
        Template
            Name BinaryTranslator_Record
            //Parameters: ${Name}, ${FieldFroms}, ${FieldTos}
            Value
                $String
                    static std::shared_ptr<[[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${Name}]]>();
                        ${FieldFroms}
                        return o;
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<[[${Name}]]> o)
                    {
                        ${FieldTos}
                    }
        Template
            Name BinaryTranslator_FieldFrom
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    o->[[${Name}]] = [[${TypeFriendlyName}FromBinary]](s);
        Template
            Name BinaryTranslator_FieldTo
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    [[${TypeFriendlyName}ToBinary]](s, o->[[${Name}]]);
        Template
            Name BinaryTranslator_TaggedUnion
            //Parameters: ${Name}, ${AlternativeFroms}, ${AlternativeTos}
            Value
                $String
                    static std::shared_ptr<[[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${Name}]]>();
                        o->_Tag = [[${Name}TagFromBinary]](s);
                        ${AlternativeFroms}
                        throw std::logic_error("InvalidOperation");
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<[[${Name}]]> o)
                    {
                        [[${Name}TagToBinary]](s, o->_Tag);
                        ${AlternativeTos}
                        throw std::logic_error("InvalidOperation");
                    }
        Template
            Name BinaryTranslator_AlternativeFrom
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o->_Tag == [[${TaggedUnionName}Tag_${Name}]])
                    {
                        o->[[${Name}]] = [[${TypeFriendlyName}FromBinary]](s);
                        return o;
                    }
        Template
            Name BinaryTranslator_AlternativeTo
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o->_Tag == [[${TaggedUnionName}Tag_${Name}]])
                    {
                        [[${TypeFriendlyName}ToBinary]](s, o->[[${Name}]]);
                        return;
                    }
        Template
            Name BinaryTranslator_Enum
            //Parameters: ${Name}, ${UnderlyingTypeFriendlyName}, ${UnderlyingType}
            Value
                $String
                    static [[${Name}]] [[${Name}FromBinary]](IReadableStream &s)
                    {
                        return ([[${Name}]])([[${UnderlyingTypeFriendlyName}FromBinary]](s));
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, [[${Name}]] o)
                    {
                        [[${UnderlyingTypeFriendlyName}ToBinary]](s, static_cast<${UnderlyingType}>(o));
                    }
        Template
            Name BinaryTranslator_Tuple
            //Parameters: ${TypeFriendlyName}, ${TupleElementFroms}, ${TupleElementTos}
            Value
                $String
                    static std::shared_ptr<[[${TypeFriendlyName}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto t = std::make_shared<[[${TypeFriendlyName}]]>();
                        ${TupleElementFroms}
                        return t;
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeFriendlyName}]]> t)
                    {
                        ${TupleElementTos}
                    }
        Template
            Name BinaryTranslator_TupleElementFrom
            //Parameters: ${NameIndex}, ${TypeFriendlyName}
            Value
                $String
                    t->[[Item${NameIndex}]] = [[${TypeFriendlyName}FromBinary]](s);
        Template
            Name BinaryTranslator_TupleElementTo
            //Parameters: ${NameIndex}, ${TypeFriendlyName}
            Value
                $String
                    [[${TypeFriendlyName}ToBinary]](s, t->[[Item${NameIndex}]]);
        Template
            Name BinaryTranslator_List
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${ElementTypeFriendlyName}
            Value
                $String
                    static std::shared_ptr<[[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto l = std::make_shared<[[${TypeString}]]>();
                        int Length = (int)(IntFromBinary(s));
                        for (int k = 0; k < Length; k += 1)
                        {
                            l->push_back([[${ElementTypeFriendlyName}FromBinary]](s));
                        }
                        return l;
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeString}]]> l)
                    {
                        int Length = (int)l->size();
                        IntToBinary(s, (Int)(Length));
                        for (int k = 0; k < Length; k += 1)
                        {
                            [[${ElementTypeFriendlyName}ToBinary]](s, (*l)[k]);
                        }
                    }
        Template
            Name BinaryTranslator_Set
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${ElementTypeFriendlyName}
            Value
                $String
                    static std::shared_ptr<[[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto l = std::make_shared<[[${TypeString}]]>();
                        int Length = (int)(IntFromBinary(s));
                        for (int k = 0; k < Length; k += 1)
                        {
                            l->insert([[${ElementTypeFriendlyName}FromBinary]](s));
                        }
                        return l;
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeString}]]> l)
                    {
                        int Length = (int)(l->size());
                        IntToBinary(s, (Int)(Length));
                        for (auto i = l->begin(); i != l->end(); i.operator++())
                        {
                            [[${ElementTypeFriendlyName}ToBinary]](s, (*i));
                        }
                    }
        Template
            Name BinaryTranslator_Map
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${KeyTypeFriendlyName}, ${ValueTypeFriendlyName}
            Value
                $String
                    static std::shared_ptr<[[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto l = std::make_shared<[[${TypeString}]]>();
                        int Length = (int)(IntFromBinary(s));
                        for (int k = 0; k < Length; k += 1)
                        {
                            auto Key = [[${KeyTypeFriendlyName}FromBinary]](s);
                            (*l)[Key] = [[${ValueTypeFriendlyName}FromBinary]](s);
                        }
                        return l;
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeString}]]> l)
                    {
                        int Length = (int)(l->size());
                        IntToBinary(s, (Int)(Length));
                        for (auto i = l->begin(); i != l->end(); i.operator++())
                        {
                            [[${KeyTypeFriendlyName}ToBinary]](s, std::get<0>(*i));
                            [[${ValueTypeFriendlyName}ToBinary]](s, std::get<1>(*i));
                        }
                    }
        Template
            Name BinaryTranslator_Optional
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${AlternativeFroms}, ${AlternativeTos}
            Value
                $String
                    static std::shared_ptr<[[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${TypeString}]]>();
                        o->_Tag = OptionalTagFromBinary(s);
                        ${AlternativeFroms}
                        throw std::logic_error("InvalidOperation");
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeString}]]> o)
                    {
                        OptionalTagToBinary(s, o->_Tag);
                        ${AlternativeTos}
                        throw std::logic_error("InvalidOperation");
                    }
