$Comment
    ==========================================================================

      File:        Schema.tree
      Location:    Yuki.Relation <Tree>
      Description: 关系类型结构C# Memory代码模板数据
      Version:     2013.04.08.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name MainWithNamespace
            //Parameters: ${Header}, ${NamespaceName}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    namespace [[${NamespaceName}]]
                    {
                        ${ComplexTypes}
                    }

                $End
        Template
            Name MainWithoutNamespace
            //Parameters: ${Header}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    ${ComplexTypes}

                $End
        Template
            Name Header
            //Parameters: ${EntityNamespaceName}
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    //Reference:

                    using System;
                    using System.Collections.Generic;
                    using System.Linq;
                    using Firefly;
                    using Firefly.Mapping;
                    using Firefly.Mapping.Binary;
                    using Firefly.Streaming;
                    using Firefly.TextEncoding;
                    using ${EntityNamespaceName};
        Template
            Name DataAccessBase
            //Parameters: ${Tables}, ${Indices}, ${Selects}, ${Generates}, ${Hash}
            Value
                $String
                    public partial class MemoryDataAccess : IDataAccess
                    {
                        private class MemoryDataTables
                        {
                            ${Tables}
                        }

                        private class MemoryDataIndices
                        {
                            ${Indices}
                        }

                        private static class MemoryDataManipulate
                        {
                            ${Selects}
                        }

                        private class OptionalComparer<T> : IComparer<Optional<T>> where T : IComparable<T>
                        {
                            public Int Compare(Optional<T> x, Optional<T> y)
                            {
                                if ((x == null) && (y == null)) { return 0; }
                                if (x == null) { return -1; }
                                if (y == null) { return 1; }
                                return x.HasValue.CompareTo(y.HasValue);
                            }
                        }

                        private MemoryDataTables Tables;
                        private MemoryDataIndices Indices;
                        public MemoryDataAccess(String ConnectionString)
                        {
                            var bs = new BinarySerializer();
                            var st = new StringTranslator();
                            bs.PutReaderTranslator(st);
                            bs.PutWriterTranslator(st);
                            bs.PutCounterTranslator(st);
                            using (var s = Streams.OpenReadable(ConnectionString))
                            {
                                var Hash = s.ReadUInt64();
                                if (Hash != 0x${Hash}) { throw new InvalidOperationException(); }
                                Tables = bs.Read<MemoryDataTables>(s);
                            }
                            Indices = new MemoryDataIndices();
                            ${Generates}
                        }

                        private class StringTranslator : IProjectorToProjectorDomainTranslator<String, Byte[]>, IProjectorToProjectorRangeTranslator<String, Byte[]>
                        {
                            public Func<String, R> TranslateProjectorToProjectorDomain<R>(Func<Byte[], R> Projector)
                            {
                                return s => Projector(TextEncoding.UTF16.GetBytes(s));
                            }

                            public Func<D, String> TranslateProjectorToProjectorRange<D>(Func<D, Byte[]> Projector)
                            {
                                return k => TextEncoding.UTF16.GetString(Projector(k));
                            }
                        }

                        public static IDataAccess Create(String ConnectionString)
                        {
                            return new MemoryDataAccess(ConnectionString);
                        }

                        public void Dispose()
                        {
                        }

                        public void Complete()
                        {
                        }
                    }
        Template
            Name DataAccessBase_Table
            //Parameters: ${EntityName}
            Value
                $String
                    public List<[[${EntityName}]]> [[${EntityName}]] = null;
        Template
            Name DataAccessBase_Index
            //Parameters: ${IndexName}, ${IndexType}
            Value
                $String
                    public [[${IndexType}]] [[${IndexName}]] = null;
        Template
            Name DataAccessBase_SelectMany
            //Parameters: ${EntityName}, ${PartialIndexName}, ${IndexName}, ${ParameterDeclarations}, ${Fetches}, ${ByIndex}, ${Filters}
            Value
                $String
                    public static IEnumerable<[[${EntityName}]]> [[From${EntityName}SelectMany${PartialIndexName}]](MemoryDataTables _Tables_, MemoryDataIndices _Indices_, ${ParameterDeclarations})
                    {
                        var _Index_ = _Indices_.[[${IndexName}]];
                        ${Fetches}
                        return [[_Index${ByIndex}_]]${Filters}.Select(_i_ => _Tables_.[[${EntityName}]][_i_]);
                    }
        Template
            Name DataAccessBase_SelectMany_Fetch
            //Parameters: ${EntityName}, ${ParentByIndex}, ${Column}, ${ByIndex}
            Value
                $String
                    if (![[_Index${ParentByIndex}_]].ContainsKey(${Column}))
                    {
                        return new [[${EntityName}]][] { };
                    }
                    var [[_Index${ByIndex}_]] = [[_Index${ParentByIndex}_]][${Column}];
        Template
            Name DataAccessBase_SelectAll
            //Parameters: ${EntityName}
            Value
                $String
                    public static IEnumerable<[[${EntityName}]]> [[From${EntityName}SelectAll]](MemoryDataTables _Tables_, MemoryDataIndices _Indices_)
                    {
                        return _Tables_.[[${EntityName}]];
                    }
        Template
            Name DataAccessBase_Generate
            //Parameters: ${EntityName}, ${IndexName}, ${IndexType}, ${FirstColumnConstructorParameters}, ${Fetches}, ${Add}
            Value
                $String
                    {
                        var Table = new [[${IndexType}]](${FirstColumnConstructorParameters});
                        for (int k = 0; k < Tables.[[${EntityName}]].Count; k += 1)
                        {
                            var r = Tables.[[${EntityName}]][k];
                            ${Fetches}
                            ${Add}
                        }
                        Indices.[[${IndexName}]] = Table;
                    }
        Template
            Name DataAccessBase_Generate_Fetch
            //Parameters: ${ParentByIndex}, ${RemainIndexType}, ${NextColumnConstructorParameters}, ${Column}, ${ByIndex}
            Value
                $String
                    if (![[Table${ParentByIndex}]].ContainsKey(r.[[${Column}]])) { [[Table${ParentByIndex}]].Add(r.[[${Column}]], new [[${RemainIndexType}]](${NextColumnConstructorParameters})); }
                    var [[Table${ByIndex}]] = [[Table${ParentByIndex}]][r.[[${Column}]]];
        Template
            Name DataAccessBase_Generate_Add
            //Parameters: ${ByIndex}
            Value
                $String
                    [[Table${ByIndex}]].Add(k);
        Template
            Name DataAccess
            //Parameters: ${Queries}
            Value
                $String
                    public partial class MemoryDataAccess
                    {
                        ${Queries}
                    }
        Template
            Name Query
            //Parameters: ${Signature}, ${Content}
            Value
                $String
                    public ${Signature}
                    {
                        ${Content}
                    }
        Template
            Name SelectLock_Optional
            //Parameters: ${ManyName}, ${Parameters}
            Value
                $String
                    var _l_ = MemoryDataManipulate.${ManyName}(this.Tables, this.Indices, ${Parameters}).ToList();
                    if (_l_.Count == 0) { return null; }
                    return _l_.Single();
        Template
            Name SelectLock_One
            //Parameters: ${ManyName}, ${Parameters}
            Value
                $String
                    return MemoryDataManipulate.${ManyName}(this.Tables, this.Indices, ${Parameters}).Single();
        Template
            Name SelectLock_Many
            //Parameters: ${ManyName}, ${Parameters}, ${OrderBys}
            Value
                $String
                    return MemoryDataManipulate.${ManyName}(this.Tables, this.Indices, ${Parameters})${OrderBys}.ToList();
        Template
            Name SelectLock_All
            //Parameters: ${AllName}, ${OrderBys}
            Value
                $String
                    return MemoryDataManipulate.${AllName}(this.Tables, this.Indices)${OrderBys}.ToList();
        Template
            Name SelectLock_Range
            //Parameters: ${ManyName}, ${Parameters}, ${OrderBys}
            Value
                $String
                    return MemoryDataManipulate.${ManyName}(this.Tables, this.Indices, ${Parameters})${OrderBys}.Skip(_Skip_).Take(_Take_).ToList();
        Template
            Name SelectLock_Count
            //Parameters: ${ManyName}, ${Parameters}
            Value
                $String
                    return MemoryDataManipulate.${ManyName}(this.Tables, this.Indices, ${Parameters}).Count();
        Template
            Name InsertUpdateUpsertDelete
            //Parameters:
            Value
                $String
                    throw new NotSupportedException();
        Template
            Name DataAccessPool
            //Parameters: ${Hash}
            Value
                $String
                    public class MemoryDataAccessPool : IDataAccessPool
                    {
                        public UInt64 Hash
                        {
                            get
                            {
                                return 0x${Hash};
                            }
                        }

                        private Dictionary<String, IDataAccess> d = new Dictionary<String, IDataAccess>();
                        public IDataAccess Create(String ConnectionString)
                        {
                            lock (d)
                            {
                                if (d.ContainsKey(ConnectionString)){ return d[ConnectionString]; }
                                var c = MemoryDataAccess.Create(ConnectionString);
                                d.Add(ConnectionString, c);
                                return c;
                            }
                        }
                        public void Dispose()
                        {
                            lock (d)
                            {
                                d.Clear();
                            }
                        }
                    }
