//==========================================================================
//
//  File:        EmbeddedCSharpGenerator.cs
//  Location:    Nivea <Visual C#>
//  Description: 嵌入C#代码生成器
//  Version:     2016.07.22.
//  Copyright(C) F.R.C.
//
//==========================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Firefly;
using Firefly.Texting.TreeFormat.Semantics;
using Nivea.Template.Semantics;

namespace Nivea.Generator
{
    public class EmbeddedCSharpGenerator
    {
        public IEnumerable<String> Generate(File File)
        {
            yield return "//==========================================================================";
            yield return "//";
            yield return "//  Notice:      This file is automatically generated.";
            yield return "//               Please don't modify this file.";
            yield return "//";
            yield return "//==========================================================================";
            yield return "";
            yield return "using System;";
            yield return "using System.Collections.Generic;";
            foreach (var s in File.Sections)
            {
                if (s.OnImport)
                {
                    foreach (var Namespace in s.Import)
                    {
                        var NamespaceStr = String.Join(".", Namespace.Select(Part => GetEscapedIdentifier(Part)));
                        if ((NamespaceStr == "System") || (NamespaceStr == "System.Collections.Generic")) { continue; }
                        yield return "using " + NamespaceStr + ";";
                    }
                }
            }
            yield return "using Boolean = System.Boolean;";
            yield return "using String = System.String;";
            yield return "using Type = System.Type;";
            yield return "using Int = System.Int32;";
            yield return "using Real = System.Double;";
            yield return "using Byte = System.Byte;";
            yield return "using UInt8 = System.Byte;";
            yield return "using UInt16 = System.UInt16;";
            yield return "using UInt32 = System.UInt32;";
            yield return "using UInt64 = System.UInt64;";
            yield return "using Int8 = System.SByte;";
            yield return "using Int16 = System.Int16;";
            yield return "using Int32 = System.Int32;";
            yield return "using Int64 = System.Int64;";
            yield return "using Float32 = System.Single;";
            yield return "using Float64 = System.Double;";
            yield return "";

            var IndentSpaceCount = 0;
            Func<String> GetIndentSpace = () => new String(' ', IndentSpaceCount);

            var IsInNamespace = false;
            var IsInTemplatesClass = false;

            foreach (var s in File.Sections)
            {
                if (s.OnNamespace)
                {
                    if (IsInTemplatesClass)
                    {
                        IsInTemplatesClass = false;
                        IndentSpaceCount -= 4;
                        yield return GetIndentSpace() + "}";
                    }
                    if (IsInNamespace)
                    {
                        IsInNamespace = false;
                        IndentSpaceCount -= 4;
                        yield return GetIndentSpace() + "}";
                    }
                    yield return GetIndentSpace() + "namespace " + String.Join(".", s.Namespace.Select(Part => GetEscapedIdentifier(Part)));
                    yield return GetIndentSpace() + "{";
                    IsInNamespace = true;
                    IndentSpaceCount += 4;
                }
                else if (s.OnTemplate)
                {
                    if (!IsInTemplatesClass)
                    {
                        yield return GetIndentSpace() + "public partial class Templates";
                        yield return GetIndentSpace() + "{";
                        IsInTemplatesClass = true;
                        IndentSpaceCount += 4;
                    }
                    var t = s.Template;
                    yield return GetIndentSpace() + "public IEnumerable<String> " + GetEscapedIdentifier(t.Signature.Name) + "(" + String.Join(", ", t.Signature.Parameters.Select(p => GetTypeString(p.Type) + " " + GetEscapedIdentifier(p.Name))) + ")";
                    yield return GetIndentSpace() + "{";
                    IndentSpaceCount += 4;
                    bool AnyLineGenerated = false;
                    foreach (var Line in GetTemplateExprs(t.Body, 0, true))
                    {
                        yield return GetIndentSpace() + Line;
                        AnyLineGenerated = true;
                    }
                    if (!AnyLineGenerated)
                    {
                        yield return GetIndentSpace() + "yield break;";
                    }
                    IndentSpaceCount -= 4;
                    yield return GetIndentSpace() + "}";
                }
                else if (s.OnConstant)
                {
                    if (!IsInTemplatesClass)
                    {
                        yield return GetIndentSpace() + "public partial class Templates";
                        yield return GetIndentSpace() + "{";
                        IsInTemplatesClass = true;
                        IndentSpaceCount += 4;
                    }
                    yield return GetIndentSpace() + "public readonly " + GetTypeString(s.Constant.Type) + " " + GetEscapedIdentifier(s.Constant.Name) + " = " + GetValueLiteral(s.Constant.Value, s.Constant.Type) + ";";
                }
                else
                {
                    //TODO
                }
            }
            if (IsInTemplatesClass)
            {
                IsInTemplatesClass = false;
                IndentSpaceCount -= 4;
                yield return GetIndentSpace() + "}";
            }
            if (IsInNamespace)
            {
                IsInNamespace = false;
                IndentSpaceCount -= 4;
                yield return GetIndentSpace() + "}";
            }
            yield return "";
        }

        private IEnumerable<String> GetTemplateExprs(List<TemplateExpr> Exprs, int IndentSpaceCount, bool Yield)
        {
            foreach (var te in Exprs)
            {
                if (te.OnLine)
                {
                    var Line = te.Line;
                    yield return (Yield ? "yield return " : "") + (IndentSpaceCount == 0 ? "" : "\"" + new String(' ', IndentSpaceCount) + "\" + ") + String.Join(" + ", GetTemplateSpans(Line)) + ";";
                }
                else if (te.OnIndentedExpr)
                {
                    var e = te.IndentedExpr;
                    if (e.Expr.OnEmbedded)
                    {
                        foreach (var Embedded in e.Expr.Embedded)
                        {
                            if (Embedded.OnSpan)
                            {
                                throw new InvalidOperationException();
                            }
                            else if (Embedded.OnLine)
                            {
                                yield return Embedded.Line;
                            }
                            else if (Embedded.OnIndentedExpr)
                            {
                                var ie = Embedded.IndentedExpr;
                                if (ie.Expr.OnTemplate)
                                {
                                    var t = ie.Expr.Template;
                                    foreach (var Line in GetTemplateExprs(t, IndentSpaceCount + e.IndentSpace, false))
                                    {
                                        yield return new String(' ', ie.IndentSpace) + Line;
                                    }
                                }
                                else if (ie.Expr.OnYieldTemplate)
                                {
                                    var t = ie.Expr.YieldTemplate;
                                    foreach (var Line in GetTemplateExprs(t, IndentSpaceCount + e.IndentSpace, true))
                                    {
                                        yield return new String(' ', ie.IndentSpace) + Line;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        throw new InvalidOperationException();
                    }
                }
            }
        }

        private IEnumerable<String> GetTemplateSpans(List<TemplateSpan> Spans)
        {
            if (Spans.Count == 0) { yield return "\"\""; }
            foreach (var s in Spans)
            {
                if (s.OnLiteral)
                {
                    yield return GetEscapedStringLiteral(s.Literal);
                }
                else if (s.OnIdentifier)
                {
                    yield return "GetEscapedIdentifier(" + String.Join(" + ", GetTemplateSpans(s.Identifier)) + ")";
                }
                else if (s.OnExpr)
                {
                    var e = s.Expr;
                    if (e.OnEmbedded)
                    {
                        var Embedded = e.Embedded;
                        if (Embedded.Count == 1)
                        {
                            var One = Embedded.Single();
                            if (!One.OnSpan) { throw new InvalidOperationException(); }
                            yield return One.Span;
                        }
                        else
                        {
                            throw new InvalidOperationException();
                        }
                    }
                    else
                    {
                        throw new InvalidOperationException();
                    }
                }
                else
                {
                    throw new InvalidOperationException();
                }
            }
        }

        private HashSet<String> Keywords = new HashSet<String> { "abstract", "event", "new", "struct", "as", "explicit", "null", "switch", "base", "extern", "object", "this", "bool", "false", "operator", "throw", "break", "finally", "out", "true", "byte", "fixed", "override", "try", "case", "float", "params", "typeof", "catch", "for", "private", "uint", "char", "foreach", "protected", "ulong", "checked", "goto", "public", "unchecked", "class", "if", "readonly", "unsafe", "const", "implicit", "ref", "ushort", "continue", "in", "return", "using", "decimal", "int", "sbyte", "virtual", "default", "interface", "sealed", "volatile", "delegate", "internal", "short", "void", "do", "is", "sizeof", "while", "double", "lock", "stackalloc", "else", "long", "static", "enum", "namespace", "string", "get", "partial", "set", "value", "where", "yield" };
        private Dictionary<String, String> PrimitiveMappings = new Dictionary<String, String> { { "Unit", "Unit" }, { "Boolean", "System.Boolean" }, { "String", "System.String" }, { "Int", "System.Int32" }, { "Real", "System.Double" }, { "Byte", "System.Byte" }, { "UInt8", "System.Byte" }, { "UInt16", "System.UInt16" }, { "UInt32", "System.UInt32" }, { "UInt64", "System.UInt64" }, { "Int8", "System.SByte" }, { "Int16", "System.Int16" }, { "Int32", "System.Int32" }, { "Int64", "System.Int64" }, { "Float32", "System.Single" }, { "Float64", "System.Double" }, { "Type", "System.Type" }, { "Optional", "Optional" }, { "List", "System.Collections.Generic.List" }, { "Set", "System.Collections.Generic.HashSet" }, { "Map", "System.Collections.Generic.Dictionary" } };
        private Regex rIdentifierPart = new Regex(@"[^\u0000-\u002F\u003A-\u0040\u005B-\u005E\u0060\u007B-\u007F]+");
        private String GetEscapedIdentifier(String Identifier)
        {
            return rIdentifierPart.Replace(Identifier, m =>
            {
                var IdentifierPart = m.Value;
                if (Keywords.Contains(IdentifierPart))
                {
                    return "@" + IdentifierPart;
                }
                else
                {
                    return IdentifierPart;
                }
            });
        }
        private String GetTypeString(TypeSpec Type)
        {
            if (Type.OnTypeRef)
            {
                if (PrimitiveMappings.ContainsKey(Type.TypeRef.Name))
                {
                    var PlatformName = PrimitiveMappings[Type.TypeRef.Name];
                    if (PlatformName.StartsWith("System.Collections.Generic."))
                    {
                        return new String(PlatformName.Skip("System.Collections.Generic.".Length).ToArray());
                    }
                }
                return Type.TypeFriendlyName();
            }
            else if (Type.OnGenericParameterRef)
            {
                return Type.GenericParameterRef;
            }
            else if (Type.OnTuple)
            {
                return Type.TypeFriendlyName();
            }
            else if (Type.OnGenericTypeSpec)
            {
                if (Type.GenericTypeSpec.ParameterValues.Count() > 0)
                {
                    return GetTypeString(Type.GenericTypeSpec.TypeSpec) + "<" + String.Join(", ", Type.GenericTypeSpec.ParameterValues.Select(p => GetTypeString(p))) + ">";
                }
                else
                {
                    return Type.TypeFriendlyName();
                }
            }
            else if (Type.OnArray)
            {
                return GetTypeString(Type.Array) + "[]";
            }
            else if (Type.OnMember)
            {
                return GetTypeString(Type.Member.Parent) + "." + GetTypeString(Type.Member.Child);
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        private String GetEscapedStringLiteral(String s)
        {
            return "\"" + new String(s.SelectMany(c => c == '\\' ? "\\\\" : c == '\"' ? "\\\"" : c == '\r' ? "\\r" : c == '\n' ? "\\n" : new String(c, 1)).ToArray()) + "\"";
        }
        private String GetValueLiteral(Node Value, TypeSpec Type)
        {
            //TODO 支持复杂类型
            if (Type.OnTypeRef)
            {
                if (Type.TypeRef.Version != "") { throw new NotSupportedException(GetTypeString(Type)); }
                var Name = Type.TypeRef.Name;
                if (Value.OnEmpty)
                {
                    if (Name == "Unit")
                    {
                        return "default(Unit)";
                    }
                    else
                    {
                        throw new NotSupportedException(GetTypeString(Type));
                    }
                }
                else if (Value.OnLeaf)
                {
                    if (Name == "Boolean")
                    {
                        return NumericStrings.InvariantParseBoolean(Value.Leaf) ? "true" : "false";
                    }
                    else if (Name == "String")
                    {
                        return GetEscapedStringLiteral(Value.Leaf);
                    }
                    else if (Name == "Int")
                    {
                        return NumericStrings.InvariantParseInt32(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Real")
                    {
                        return NumericStrings.InvariantParseFloat64(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Byte")
                    {
                        return NumericStrings.InvariantParseUInt8(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "UInt8")
                    {
                        return NumericStrings.InvariantParseUInt8(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "UInt16")
                    {
                        return NumericStrings.InvariantParseUInt16(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "UInt32")
                    {
                        return NumericStrings.InvariantParseUInt32(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "UInt64")
                    {
                        return NumericStrings.InvariantParseUInt64(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Int8")
                    {
                        return NumericStrings.InvariantParseInt8(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Int16")
                    {
                        return NumericStrings.InvariantParseInt16(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Int32")
                    {
                        return NumericStrings.InvariantParseInt32(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Int64")
                    {
                        return NumericStrings.InvariantParseInt64(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Float32")
                    {
                        return NumericStrings.InvariantParseFloat32(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Float64")
                    {
                        return NumericStrings.InvariantParseFloat64(Value.Leaf).ToInvariantString();
                    }
                    else if (Name == "Type")
                    {
                        int InvalidCharIndex;
                        var ot = Nivea.Template.Syntax.TypeParser.TryParseTypeSpec(Value.Leaf, (o, Start, End) => { }, out InvalidCharIndex);
                        if (ot.OnHasValue)
                        {
                            return "typeof(" + GetTypeString(ot.Value) + ")";
                        }
                        else
                        {
                            throw new InvalidOperationException("InvalidValue: " + GetTypeString(Type) + " " + GetNodeString(Value));
                        }
                    }
                    else
                    {
                        throw new NotSupportedException(GetTypeString(Type));
                    }
                }
                else if (Value.OnStem && (Value.Stem.Name == "") && (Value.Stem.Children.Count == 1))
                {
                    return GetValueLiteral(Value.Stem.Children.Single(), Type);
                }
                else
                {
                    throw new NotSupportedException(GetTypeString(Type));
                }
            }
            else if (Type.OnGenericTypeSpec)
            {
                if (!Type.GenericTypeSpec.TypeSpec.OnTypeRef) { throw new NotSupportedException(GetTypeString(Type)); }
                if (Type.GenericTypeSpec.TypeSpec.TypeRef.Version != "") { throw new NotSupportedException(GetTypeString(Type)); }
                var Name = Type.GenericTypeSpec.TypeSpec.TypeRef.Name;
                if (!Value.OnStem) { throw new InvalidOperationException("InvalidValue: " + GetTypeString(Type) + " " + GetNodeString(Value)); }
                if (Name == "Optional")
                {
                    if (Type.GenericTypeSpec.ParameterValues.Count != 1) { throw new InvalidOperationException("InvalidType: " + GetTypeString(Type)); }
                    var ElementType = Type.GenericTypeSpec.ParameterValues.Single();
                    if (Value.Stem.Children.Count != 1) { throw new InvalidOperationException("InvalidValue: " + GetTypeString(Type) + " " + GetNodeString(Value)); }
                    var One = Value.Stem.Children.Single();
                    if (Value.Stem.Name == "NotHasValue")
                    {
                        if (!One.OnEmpty) { throw new InvalidOperationException("InvalidValue: " + GetTypeString(Type) + " " + GetNodeString(Value)); }
                        return GetTypeString(Type) + ".CreateNotHasValue()";
                    }
                    else if (Value.Stem.Name == "HasValue")
                    {
                        if (Value.Stem.Children.Count != 1) { throw new InvalidOperationException("InvalidValue: " + GetTypeString(Type) + " " + GetNodeString(Value)); }
                        return GetTypeString(Type) + ".CreateHasValue(" + GetValueLiteral(One, ElementType) + ")";
                    }
                    else
                    {
                        throw new InvalidOperationException("InvalidValue: " + GetTypeString(Type) + " " + GetNodeString(Value));
                    }
                }
                else if ((Name == "List") || (Name == "Set"))
                {
                    if (Type.GenericTypeSpec.ParameterValues.Count != 1) { throw new InvalidOperationException("InvalidType: " + GetTypeString(Type)); }
                    var ElementType = Type.GenericTypeSpec.ParameterValues.Single();
                    var l = new List<String> { };
                    foreach (var v in Value.Stem.Children)
                    {
                        if (!v.OnStem) { throw new InvalidOperationException("InvalidValue: " + GetTypeString(ElementType) + " " + GetNodeString(v)); }
                        if (v.Stem.Children.Count != 1) { throw new InvalidOperationException("InvalidValue: " + GetTypeString(ElementType) + " " + GetNodeString(v)); }
                        l.Add(GetValueLiteral(v.Stem.Children.Single(), ElementType));
                    }
                    return "new " + GetTypeString(Type) + " {" + String.Join(", ", l) + "}";
                }
                else if (Name == "Map")
                {
                    if (Type.GenericTypeSpec.ParameterValues.Count != 2) { throw new InvalidOperationException("InvalidType: " + GetTypeString(Type)); }
                    var KeyType = Type.GenericTypeSpec.ParameterValues[0];
                    var ValueType = Type.GenericTypeSpec.ParameterValues[1];
                    var l = new List<String> { };
                    foreach (var v in Value.Stem.Children)
                    {
                        if (!v.OnStem) { throw new InvalidOperationException("InvalidValue: KeyValuePair<" + GetTypeString(KeyType) + ", " + GetTypeString(ValueType) + "> " + GetNodeString(v)); }
                        if (v.Stem.Children.Count != 2) { throw new InvalidOperationException("InvalidValue: KeyValuePair<" + GetTypeString(KeyType) + ", " + GetTypeString(ValueType) + "> " + GetNodeString(v)); }
                        var Keys = v.Stem.Children.Where(c => c.OnStem && c.Stem.Name == "Key").ToList();
                        var Values = v.Stem.Children.Where(c => c.OnStem && c.Stem.Name == "Value").ToList();
                        if ((Keys.Count != 1) || (Values.Count != 1)) { throw new InvalidOperationException("InvalidValue: KeyValuePair<" + GetTypeString(KeyType) + ", " + GetTypeString(ValueType) + "> " + GetNodeString(v)); }
                        var KeyOne = Keys.Single();
                        var ValueOne = Values.Single();
                        if ((KeyOne.Stem.Children.Count != 1) || (ValueOne.Stem.Children.Count != 1)) { throw new InvalidOperationException("InvalidValue: KeyValuePair<" + GetTypeString(KeyType) + ", " + GetTypeString(ValueType) + "> " + GetNodeString(v)); }
                        var KeyStr = GetValueLiteral(KeyOne.Stem.Children.Single(), KeyType);
                        var ValueStr = GetValueLiteral(ValueOne.Stem.Children.Single(), ValueType);
                        l.Add("{" + KeyStr + ", " + ValueStr + "}");
                    }
                    return "new " + GetTypeString(Type) + " {" + String.Join(", ", l) + "}";
                }
                else
                {
                    throw new NotSupportedException(GetTypeString(Type));
                }
            }
            else
            {
                throw new NotSupportedException(GetTypeString(Type));
            }
        }
        private String GetNodeString(Node v)
        {
            if (v.OnEmpty)
            {
                return "{}";
            }
            else if (v.OnLeaf)
            {
                return GetEscapedStringLiteral(v.Leaf);
            }
            else if (v.OnStem)
            {
                return v.Stem.Name + "{" + String.Join(", ", v.Stem.Children.Select(c => GetNodeString(c))) + "}";
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
    }
}
