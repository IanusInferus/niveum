//==========================================================================
//
//  File:        EmbeddedCSharpGenerator.cs
//  Location:    Nivea <Visual C#>
//  Description: 嵌入C#代码生成器
//  Version:     2016.07.14.
//  Copyright(C) F.R.C.
//
//==========================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Nivea.Template.Semantics;

namespace Nivea.Generator
{
    public class EmbeddedCSharpGenerator
    {
        public IEnumerable<String> Generate(File File)
        {
            yield return "//==========================================================================";
            yield return "//";
            yield return "//  Notice:      This file is automatically generated.";
            yield return "//               Please don't modify this file.";
            yield return "//";
            yield return "//==========================================================================";
            yield return "";
            yield return "using System;";
            yield return "using System.Collections.Generic;";
            foreach (var s in File.Sections)
            {
                if (s.OnImport)
                {
                    foreach (var Namespace in s.Import)
                    {
                        var NamespaceStr = String.Join(".", Namespace.Select(Part => GetEscapedIdentifier(Part)));
                        if ((NamespaceStr == "System") || (NamespaceStr == "System.Collections.Generic")) { continue; }
                        yield return "using " + NamespaceStr + ";";
                    }
                }
            }
            yield return "using Boolean = System.Boolean;";
            yield return "using String = System.String;";
            yield return "using Type = System.Type;";
            yield return "using Int = System.Int32;";
            yield return "using Real = System.Double;";
            yield return "using Byte = System.Byte;";
            yield return "using UInt8 = System.Byte;";
            yield return "using UInt16 = System.UInt16;";
            yield return "using UInt32 = System.UInt32;";
            yield return "using UInt64 = System.UInt64;";
            yield return "using Int8 = System.SByte;";
            yield return "using Int16 = System.Int16;";
            yield return "using Int32 = System.Int32;";
            yield return "using Int64 = System.Int64;";
            yield return "using Float32 = System.Single;";
            yield return "using Float64 = System.Double;";
            yield return "";

            var IndentSpaceCount = 0;
            Func<String> GetIndentSpace = () => new String(' ', IndentSpaceCount);

            var IsInNamespace = false;
            var IsInTemplatesClass = false;

            foreach (var s in File.Sections)
            {
                if (s.OnNamespace)
                {
                    if (IsInTemplatesClass)
                    {
                        IsInTemplatesClass = false;
                        IndentSpaceCount -= 4;
                        yield return GetIndentSpace() + "}";
                    }
                    if (IsInNamespace)
                    {
                        IsInNamespace = false;
                        IndentSpaceCount -= 4;
                        yield return GetIndentSpace() + "}";
                    }
                    yield return GetIndentSpace() + "namespace " + String.Join(".", s.Namespace.Select(Part => GetEscapedIdentifier(Part)));
                    yield return GetIndentSpace() + "{";
                    IsInNamespace = true;
                    IndentSpaceCount += 4;
                }
                else if (s.OnTemplate)
                {
                    if (!IsInTemplatesClass)
                    {
                        yield return GetIndentSpace() + "public partial class Templates";
                        yield return GetIndentSpace() + "{";
                        IsInTemplatesClass = true;
                        IndentSpaceCount += 4;
                    }
                    var t = s.Template;
                    yield return GetIndentSpace() + "public static IEnumerable<String> " + GetEscapedIdentifier(t.Signature.Name) + "(" + String.Join(", ", t.Signature.Parameters.Select(p => GetTypeString(p.Type) + " " + GetEscapedIdentifier(p.Name))) + ")";
                    yield return GetIndentSpace() + "{";
                    IndentSpaceCount += 4;
                    foreach (var Line in GetTemplateExprs(t.Body, 0, true))
                    {
                        yield return GetIndentSpace() + Line;
                    }
                    IndentSpaceCount -= 4;
                    yield return GetIndentSpace() + "}";
                }
                else
                {
                    //TODO
                }
            }
            if (IsInTemplatesClass)
            {
                IsInTemplatesClass = false;
                IndentSpaceCount -= 4;
                yield return GetIndentSpace() + "}";
            }
            if (IsInNamespace)
            {
                IsInNamespace = false;
                IndentSpaceCount -= 4;
                yield return GetIndentSpace() + "}";
            }
            yield return "";
        }

        private IEnumerable<String> GetTemplateExprs(List<TemplateExpr> Exprs, int IndentSpaceCount, bool Yield)
        {
            foreach (var te in Exprs)
            {
                if (te.OnLine)
                {
                    var Line = te.Line;
                    yield return (Yield ? "yield return " : "") + (IndentSpaceCount == 0 ? "" : "\"" + new String(' ', IndentSpaceCount) + "\" + ") + String.Join(" + ", GetTemplateSpans(Line)) + ";";
                }
                else if (te.OnIndentedExpr)
                {
                    var e = te.IndentedExpr;
                    if (e.Expr.OnEmbedded)
                    {
                        foreach (var Embedded in e.Expr.Embedded)
                        {
                            if (Embedded.OnSpan)
                            {
                                throw new InvalidOperationException();
                            }
                            else if (Embedded.OnLine)
                            {
                                yield return Embedded.Line;
                            }
                            else if (Embedded.OnIndentedExpr)
                            {
                                var ie = Embedded.IndentedExpr;
                                if (ie.Expr.OnTemplate)
                                {
                                    var t = ie.Expr.Template;
                                    foreach (var Line in GetTemplateExprs(t, IndentSpaceCount + e.IndentSpace, false))
                                    {
                                        yield return new String(' ', ie.IndentSpace) + Line;
                                    }
                                }
                                else if (ie.Expr.OnYieldTemplate)
                                {
                                    var t = ie.Expr.YieldTemplate;
                                    foreach (var Line in GetTemplateExprs(t, IndentSpaceCount + e.IndentSpace, true))
                                    {
                                        yield return new String(' ', ie.IndentSpace) + Line;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        throw new InvalidOperationException();
                    }
                }
            }
        }

        private IEnumerable<String> GetTemplateSpans(List<TemplateSpan> Spans)
        {
            if (Spans.Count == 0) { yield return "\"\""; }
            foreach (var s in Spans)
            {
                if (s.OnLiteral)
                {
                    yield return GetEscapedStringLiteral(s.Literal);
                }
                else if (s.OnIdentifier)
                {
                    yield return "GetEscapedIdentifier(" + String.Join(" + ", GetTemplateSpans(s.Identifier)) + ")";
                }
                else if (s.OnExpr)
                {
                    var e = s.Expr;
                    if (e.OnEmbedded)
                    {
                        var Embedded = e.Embedded;
                        if (Embedded.Count == 1)
                        {
                            var One = Embedded.Single();
                            if (!One.OnSpan) { throw new InvalidOperationException(); }
                            yield return One.Span;
                        }
                        else
                        {
                            throw new InvalidOperationException();
                        }
                    }
                    else
                    {
                        throw new InvalidOperationException();
                    }
                }
                else
                {
                    throw new InvalidOperationException();
                }
            }
        }

        private HashSet<String> Keywords = new HashSet<String> { "abstract", "event", "new", "struct", "as", "explicit", "null", "switch", "base", "extern", "object", "this", "bool", "false", "operator", "throw", "break", "finally", "out", "true", "byte", "fixed", "override", "try", "case", "float", "params", "typeof", "catch", "for", "private", "uint", "char", "foreach", "protected", "ulong", "checked", "goto", "public", "unchecked", "class", "if", "readonly", "unsafe", "const", "implicit", "ref", "ushort", "continue", "in", "return", "using", "decimal", "int", "sbyte", "virtual", "default", "interface", "sealed", "volatile", "delegate", "internal", "short", "void", "do", "is", "sizeof", "while", "double", "lock", "stackalloc", "else", "long", "static", "enum", "namespace", "string", "get", "partial", "set", "value", "where", "yield" };
        private Dictionary<String, String> PrimitiveMappings = new Dictionary<String, String> { { "Unit", "Unit" }, { "Boolean", "System.Boolean" }, { "String", "System.String" }, { "Int", "System.Int32" }, { "Real", "System.Double" }, { "Byte", "System.Byte" }, { "UInt8", "System.Byte" }, { "UInt16", "System.UInt16" }, { "UInt32", "System.UInt32" }, { "UInt64", "System.UInt64" }, { "Int8", "System.SByte" }, { "Int16", "System.Int16" }, { "Int32", "System.Int32" }, { "Int64", "System.Int64" }, { "Float32", "System.Single" }, { "Float64", "System.Double" }, { "Type", "System.Type" }, { "Optional", "Optional" }, { "List", "System.Collections.Generic.List" }, { "Set", "System.Collections.Generic.HashSet" }, { "Map", "System.Collections.Generic.Dictionary" } };
        private Regex rIdentifierPart = new Regex(@"[^\u0000-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007F]+");
        private String GetEscapedIdentifier(String Identifier)
        {
            return rIdentifierPart.Replace(Identifier, m =>
            {
                var IdentifierPart = m.Value;
                if (Keywords.Contains(IdentifierPart))
                {
                    return "@" + IdentifierPart;
                }
                else
                {
                    return IdentifierPart;
                }
            });
        }
        private String GetTypeString(TypeSpec Type)
        {
            if (Type.OnTypeRef)
            {
                if (PrimitiveMappings.ContainsKey(Type.TypeRef.Name))
                {
                    var PlatformName = PrimitiveMappings[Type.TypeRef.Name];
                    if (PlatformName.StartsWith("System.Collections.Generic."))
                    {
                        return new String(PlatformName.Skip("System.Collections.Generic.".Length).ToArray());
                    }
                }
                return Type.TypeFriendlyName();
            }
            else if (Type.OnGenericParameterRef)
            {
                return Type.GenericParameterRef;
            }
            else if (Type.OnTuple)
            {
                return Type.TypeFriendlyName();
            }
            else if (Type.OnGenericTypeSpec)
            {
                if (Type.GenericTypeSpec.ParameterValues.Count() > 0)
                {
                    return GetTypeString(Type.GenericTypeSpec.TypeSpec) + "<" + String.Join(", ", Type.GenericTypeSpec.ParameterValues.Select(p => GetTypeString(p))) + ">";
                }
                else
                {
                    return Type.TypeFriendlyName();
                }
            }
            else if (Type.OnArray)
            {
                return GetTypeString(Type.Array) + "[]";
            }
            else if (Type.OnMember)
            {
                return GetTypeString(Type.Member.Parent) + "." + GetTypeString(Type.Member.Child);
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        private String GetEscapedStringLiteral(String s)
        {
            return "\"" + new String(s.SelectMany(c => c == '\"' ? "\\\"" : c == '\r' ? "\\r" : c == '\n' ? "\\n" : new String(c, 1)).ToArray()) + "\"";
        }
    }
}
