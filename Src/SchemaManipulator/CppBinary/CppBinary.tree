$Comment
    ==========================================================================

      File:        CppBinary.tree
      Location:    Yuki.SchemaManipulator <Tree>
      Description: 对象类型结构C++二进制模板数据
      Version:     2012.02.23.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
        $List String
            __abstract
            __alignof
            __asm
            __assume
            __based
            __box
            __cdecl
            __declspec
            __delegate
            __event
            __except
            __fastcall
            __finally
            __forceinline
            __gc
            __hook
            __identifier
            __if_exists
            __if_not_exists
            __inline
            __int16
            __int32
            __int64
            __int8
            __interface
            __leave
            __m128
            __m128d
            __m128i
            __m64
            __multiple_inheritance
            __nogc
            __noop
            __pin
            __property
            __raise
            __sealed
            __single_inheritance
            __stdcall
            __super
            __thiscall
            __try
            __except
            __finally
            __try_cast
            __unaligned
            __unhook
            __uuidof
            __value
            __virtual_inheritance
            __w64
            __wchar_t
            wchar_t
            abstract
            array
            auto
            bool
            break
            case
            catch
            char
            class
            const
            const_cast
            continue
            decltype
            default
            delegate
            delete
            deprecated
            dllexport
            dllimport
            do
            double
            dynamic_cast
            else
            enum
            event
            explicit
            extern
            false
            finally
            float
            for
            each
            in
            friend
            friend_as
            gcnew
            generic
            goto
            if
            initonly
            inline
            int
            interface
            interior_ptr
            literal
            long
            mutable
            naked
            namespace
            new
            noinline
            noreturn
            nothrow
            novtable
            nullptr
            operator
            private
            property
            protected
            public
            ref
            register
            reinterpret_cast
            return
            safecast
            sealed
            selectany
            short
            signed
            sizeof
            static
            static_assert
            static_cast
            struct
            switch
            template
            this
            thread
            throw
            true
            try
            typedef
            typeid
            typename
            union
            unsigned
            using
            uuid
            value
            virtual
            void
            volatile
            while
    PrimitiveMappings
        PrimitiveMapping
            Name Unit
            PlatformName Unit
        PrimitiveMapping
            Name Boolean
            PlatformName bool
        PrimitiveMapping
            Name String
            PlatformName std::wstring
        PrimitiveMapping
            Name Int
            PlatformName int32_t
        PrimitiveMapping
            Name Real
            PlatformName double
        PrimitiveMapping
            Name Type
            PlatformName std::wstring
        PrimitiveMapping
            Name List
            PlatformName std::vector
        PrimitiveMapping
            Name Set
            PlatformName std::unordered_set
        PrimitiveMapping
            Name Map
            PlatformName std::unordered_map
    Templates
        Template
            Name Main
            //Parameters: ${Header}, ${Imports}, ${Primitives}, ${Contents}
            Value
                $String
                    ${Header}
                    using namespace ${Imports};
                    ${Primitives}

                    ${Contents}

                $End
        Template
            Name Namespace
            //Parameters: ${NamespaceName}, ${Contents}
            Value
                $String
                    namespace [[${NamespaceName}]]
                    {
                        ${Contents}
                    }
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    #pragma once

                    //Reference:

                    #include <cstdint>
                    #include <string>
                    #include <vector>
                    #include <unordered_set>
                    #include <unordered_map>
                    #include <memory>
                    #include <stdexcept>
        Template
            Name Streams
            Value
                $String
                    class IReadableStream
                    {
                    public:
                        virtual uint8_t ReadByte() = 0;
                        virtual std::vector<uint8_t> ReadBytes(size_t Size) = 0;

                        Unit ReadUnit()
                        {
                            return Unit();
                        }
                        Boolean ReadBoolean()
                        {
                            return ReadByte() != 0;
                        }

                        uint8_t ReadUInt8()
                        {
                            return ReadByte();
                        }
                        uint16_t ReadUInt16()
                        {
                            uint16_t o;
                            o = static_cast<uint16_t>(static_cast<uint16_t>(ReadByte()) & static_cast<uint16_t>(0xFF));
                            o = static_cast<uint16_t>(o | ((static_cast<uint16_t>(ReadByte()) & 0xFF) << 8));
                            return o;
                        }
                        uint32_t ReadUInt32()
                        {
                            uint32_t o;
                            o = static_cast<uint32_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<uint32_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<uint32_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<uint32_t>(ReadByte()) & 0xFF) << 24);
                            return o;
                        }
                        uint64_t ReadUInt64()
                        {
                            uint64_t o;
                            o = static_cast<uint64_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<uint64_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<uint64_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<uint64_t>(ReadByte()) & 0xFF) << 24);
                            o = o | ((static_cast<uint64_t>(ReadByte()) & 0xFF) << 32);
                            o = o | ((static_cast<uint64_t>(ReadByte()) & 0xFF) << 40);
                            o = o | ((static_cast<uint64_t>(ReadByte()) & 0xFF) << 48);
                            o = o | ((static_cast<uint64_t>(ReadByte()) & 0xFF) << 56);
                            return o;
                        }
                        int8_t ReadInt8()
                        {
                            return static_cast<int8_t>(ReadByte());
                        }
                        int16_t ReadInt16()
                        {
                            int16_t o;
                            o = static_cast<int16_t>(static_cast<int16_t>(ReadByte()) & static_cast<int16_t>(0xFF));
                            o = static_cast<int16_t>(o | ((static_cast<int16_t>(ReadByte()) & 0xFF) << 8));
                            return o;
                        }
                        int32_t ReadInt32()
                        {
                            int32_t o;
                            o = static_cast<int32_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<int32_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<int32_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<int32_t>(ReadByte()) & 0xFF) << 24);
                            return o;
                        }
                        int64_t ReadInt64()
                        {
                            int64_t o;
                            o = static_cast<int64_t>(ReadByte()) & 0xFF;
                            o = o | ((static_cast<int64_t>(ReadByte()) & 0xFF) << 8);
                            o = o | ((static_cast<int64_t>(ReadByte()) & 0xFF) << 16);
                            o = o | ((static_cast<int64_t>(ReadByte()) & 0xFF) << 24);
                            o = o | ((static_cast<int64_t>(ReadByte()) & 0xFF) << 32);
                            o = o | ((static_cast<int64_t>(ReadByte()) & 0xFF) << 40);
                            o = o | ((static_cast<int64_t>(ReadByte()) & 0xFF) << 48);
                            o = o | ((static_cast<int64_t>(ReadByte()) & 0xFF) << 56);
                            return o;
                        }

                        float ReadFloat32()
                        {
                            int32_t i = ReadInt32();
                            return *reinterpret_cast<float *>(&i);
                        }
                        double ReadFloat64()
                        {
                            int64_t i = ReadInt64();
                            return *reinterpret_cast<double *>(&i);
                        }

                        String ReadString()
                        {
                            int32_t Length = ReadInt32();
                            int32_t n = Length / 2;
                            std::vector<wchar_t> Chars;
                            for (int k = 0; k < n; k += 1)
                            {
                                Chars.push_back(static_cast<wchar_t>(ReadUInt16()));
                            }
                            if ((Length & 1) != 0)
                            {
                                ReadByte();
                            }
                            return String(Chars.begin(), Chars.end());
                        }
                    };

                    class IWritableStream
                    {
                    public:
                        virtual void WriteByte(uint8_t b) = 0;
                        virtual void WriteBytes(std::vector<uint8_t> l) = 0;

                        void WriteUnit(Unit v)
                        {
                        }
                        void WriteBoolean(Boolean v)
                        {
                            if (v)
                            {
                                WriteByte(0xFF);
                            }
                            else
                            {
                                WriteByte(0);
                            }
                        }

                        void WriteUInt8(uint8_t v)
                        {
                            WriteByte(v);
                        }
                        void WriteUInt16(uint16_t v)
                        {
                            WriteByte(static_cast<uint8_t>(v & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 8) & 0xFF));
                        }
                        void WriteUInt32(uint32_t v)
                        {
                            WriteByte(static_cast<uint8_t>(v & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 24) & 0xFF));
                        }
                        void WriteUInt64(uint64_t v)
                        {
                            WriteByte(static_cast<uint8_t>(v & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 24) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 32) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 40) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 48) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 56) & 0xFF));
                        }
                        void WriteInt8(int8_t v)
                        {
                            WriteByte(static_cast<uint8_t>(v));
                        }
                        void WriteInt16(int16_t v)
                        {
                            WriteByte(static_cast<uint8_t>(v & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 8) & 0xFF));
                        }
                        void WriteInt32(int32_t v)
                        {
                            WriteByte(static_cast<uint8_t>(v & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 24) & 0xFF));
                        }
                        void WriteInt64(int64_t v)
                        {
                            WriteByte(static_cast<uint8_t>(v & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 8) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 16) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 24) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 32) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 40) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 48) & 0xFF));
                            WriteByte(static_cast<uint8_t>((v >> 56) & 0xFF));
                        }

                        void WriteFloat32(float v)
                        {
                            WriteInt32(*reinterpret_cast<int32_t *>(&v));
                        }
                        void WriteFloat64(double v)
                        {
                            WriteInt64(*reinterpret_cast<int64_t *>(&v));
                        }

                        void WriteString(String v)
                        {
                            int32_t n = v.size();
                            int32_t Length = n * 2;
                            WriteInt32(Length);
                            for (int k = 0; k < n; k += 1)
                            {
                                WriteUInt16(static_cast<uint16_t>(v[k]));
                            }
                        }
                    };

                    class IReadableWritableStream : public IReadableStream, public IWritableStream
                    {
                    };
        Template
            Name BinaryTranslator
            //Parameters: ${Serializers}
            Value
                $String
                    class BinaryTranslator /* final */
                    {
                    public:
                        ${Serializers}
                    };
        Template
            Name BinaryTranslator_Primitive_Unit
            Value
                $String
                    static Unit UnitFromBinary(IReadableStream &s)
                    {
                        return s.ReadUnit();
                    }
                    static void UnitToBinary(IWritableStream &s, Unit v)
                    {
                        s.WriteUnit(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Boolean
            Value
                $String
                    static Boolean BooleanFromBinary(IReadableStream &s)
                    {
                        return s.ReadBoolean();
                    }
                    static void BooleanToBinary(IWritableStream &s, Boolean v)
                    {
                        s.WriteBoolean(v);
                    }
        Template
            Name BinaryTranslator_Primitive_String
            Value
                $String
                    static String StringFromBinary(IReadableStream &s)
                    {
                        return s.ReadString();
                    }
                    static void StringToBinary(IWritableStream &s, String v)
                    {
                        s.WriteString(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int
            Value
                $String
                    static Int IntFromBinary(IReadableStream &s)
                    {
                        return s.ReadInt32();
                    }
                    static void IntToBinary(IWritableStream &s, Int v)
                    {
                        s.WriteInt32(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Real
            Value
                $String
                    static Real RealFromBinary(IReadableStream &s)
                    {
                        return s.ReadFloat64();
                    }
                    static void RealToBinary(IWritableStream &s, Real v)
                    {
                        s.WriteFloat64(v);
                    }
        Template
            Name BinaryTranslator_Primitive_Type
            Value
                $String
                    static Type TypeFromBinary(IReadableStream &s)
                    {
                        throw std::logic_error("NotSupported");
                    }
                    static void TypeToBinary(IWritableStream &s, Type v)
                    {
                        throw std::logic_error("NotSupported");
                    }
        Template
            Name BinaryTranslator_Alias
            //Parameters: ${Name}, ${ValueTypeFriendlyName}
            Value
                $String
                    static std::shared_ptr<[[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${Name}]]>();
                        o->Value = [[${ValueTypeFriendlyName}FromBinary]](s);
                        return o;
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<[[${Name}]]> o)
                    {
                        [[${ValueTypeFriendlyName}ToBinary]](s, o->Value);
                    }
        Template
            Name BinaryTranslator_Record
            //Parameters: ${Name}, ${FieldFroms}, ${FieldTos}
            Value
                $String
                    static std::shared_ptr<[[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${Name}]]>();
                        ${FieldFroms}
                        return o;
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<[[${Name}]]> o)
                    {
                        ${FieldTos}
                    }
        Template
            Name BinaryTranslator_FieldFrom
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    o->[[${Name}]] = [[${TypeFriendlyName}FromBinary]](s);
        Template
            Name BinaryTranslator_FieldTo
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    [[${TypeFriendlyName}ToBinary]](s, o->[[${Name}]]);
        Template
            Name BinaryTranslator_TaggedUnion
            //Parameters: ${Name}, ${AlternativeFroms}, ${AlternativeTos}
            Value
                $String
                    static std::shared_ptr<[[${Name}]]> [[${Name}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${Name}]]>();
                        o->_Tag = [[${Name}TagFromBinary]](s);
                        ${AlternativeFroms}
                        throw std::logic_error("InvalidOperation");
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, std::shared_ptr<[[${Name}]]> o)
                    {
                        [[${Name}TagToBinary]](s, o->_Tag);
                        ${AlternativeTos}
                        throw std::logic_error("InvalidOperation");
                    }
        Template
            Name BinaryTranslator_AlternativeFrom
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o->_Tag == [[${TaggedUnionName}Tag_${Name}]])
                    {
                        o->[[${Name}]] = [[${TypeFriendlyName}FromBinary]](s);
                        return o;
                    }
        Template
            Name BinaryTranslator_AlternativeTo
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o->_Tag == [[${TaggedUnionName}Tag_${Name}]])
                    {
                        [[${TypeFriendlyName}ToBinary]](s, o->[[${Name}]]);
                        return;
                    }
        Template
            Name BinaryTranslator_Enum
            //Parameters: ${Name}, ${UnderlyingTypeFriendlyName}, ${UnderlyingType}
            Value
                $String
                    static [[${Name}]] [[${Name}FromBinary]](IReadableStream &s)
                    {
                        return ([[${Name}]])([[${UnderlyingTypeFriendlyName}FromBinary]](s));
                    }
                    static void [[${Name}ToBinary]](IWritableStream &s, [[${Name}]] o)
                    {
                        [[${UnderlyingTypeFriendlyName}ToBinary]](s, static_cast<${UnderlyingType}>(o));
                    }
        Template
            Name BinaryTranslator_Tuple
            //Parameters: ${TypeFriendlyName}, ${TupleElementFroms}, ${TupleElementTos}
            Value
                $String
                    static std::shared_ptr<[[${TypeFriendlyName}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto t = std::make_shared<[[${TypeFriendlyName}]]>();
                        ${TupleElementFroms}
                        return t;
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeFriendlyName}]]> t)
                    {
                        ${TupleElementTos}
                    }
        Template
            Name BinaryTranslator_TupleElementFrom
            //Parameters: ${NameIndex}, ${TypeFriendlyName}
            Value
                $String
                    t->[[Item${NameIndex}]] = [[${TypeFriendlyName}FromBinary]](s);
        Template
            Name BinaryTranslator_TupleElementTo
            //Parameters: ${NameIndex}, ${TypeFriendlyName}
            Value
                $String
                    [[${TypeFriendlyName}ToBinary]](s, t->[[Item${NameIndex}]]);
        Template
            Name BinaryTranslator_List
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${ElementTypeFriendlyName}
            Value
                $String
                    static std::shared_ptr<[[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto l = std::make_shared<[[${TypeString}]]>();
                        int32_t Length = IntFromBinary(s);
                        for (int k = 0; k < Length; k += 1)
                        {
                            l->push_back([[${ElementTypeFriendlyName}FromBinary]](s));
                        }
                        return l;
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeString}]]> l)
                    {
                        int32_t Length = l->size();
                        IntToBinary(s, Length);
                        for (int k = 0; k < Length; k += 1)
                        {
                            [[${ElementTypeFriendlyName}ToBinary]](s, (*l)[k]);
                        }
                    }
        Template
            Name BinaryTranslator_Optional
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${AlternativeFroms}, ${AlternativeTos}
            Value
                $String
                    static std::shared_ptr<[[${TypeString}]]> [[${TypeFriendlyName}FromBinary]](IReadableStream &s)
                    {
                        auto o = std::make_shared<[[${TypeString}]]>();
                        o->_Tag = OptionalTagFromBinary(s);
                        ${AlternativeFroms}
                        throw std::logic_error("InvalidOperation");
                    }
                    static void [[${TypeFriendlyName}ToBinary]](IWritableStream &s, std::shared_ptr<[[${TypeString}]]> o)
                    {
                        OptionalTagToBinary(s, o->_Tag);
                        ${AlternativeTos}
                        throw std::logic_error("InvalidOperation");
                    }
