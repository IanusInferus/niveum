$Comment
    ==========================================================================

      File:        JavaBinary.tree
      Location:    Niveum.Core <Tree>
      Description: 对象类型结构Java二进制模板
      Version:     2017.07.01.
      Copyright(C) F.R.C.

    ==========================================================================

#Option
    EnableEmbeddedExpr True

#Namespace Niveum.ObjectSchema.JavaBinary

#Import
    System
    System.Collections.Generic
    System.Linq
    Firefly

#Template Streams
    public static abstract class IReadableStream
    {
        public abstract byte ReadByte();
        public abstract byte[] ReadBytes(int Size);

        public Unit ReadUnit()
        {
            return new Unit();
        }
        public Boolean ReadBoolean()
        {
            return ReadByte() != 0;
        }

        public byte ReadUInt8()
        {
            return ReadByte();
        }
        public short ReadUInt16()
        {
            short o;
            o = (short) ((short) (this.ReadInt8()) & (short) (0xFF));
            o = (short) (o | (((short) (this.ReadInt8()) & 0xFF) << 8));
            return o;
        }
        public int ReadUInt32()
        {
            int o;
            o = (int) (this.ReadInt8()) & 0xFF;
            o = o | (((int) (this.ReadInt8()) & 0xFF) << 8);
            o = o | (((int) (this.ReadInt8()) & 0xFF) << 16);
            o = o | (((int) (this.ReadInt8()) & 0xFF) << 24);
            return o;
        }
        public long ReadUInt64()
        {
            long o;
            o = (long) (this.ReadInt8()) & 0xFF;
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 8);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 16);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 24);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 32);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 40);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 48);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 56);
            return o;
        }
        public byte ReadInt8()
        {
            return ReadByte();
        }
        public short ReadInt16()
        {
            short o;
            o = (short) ((short) (this.ReadInt8()) & (short) (0xFF));
            o = (short) (o | (((short) (this.ReadInt8()) & 0xFF) << 8));
            return o;
        }
        public int ReadInt32()
        {
            int o;
            o = (int) (this.ReadInt8()) & 0xFF;
            o = o | (((int) (this.ReadInt8()) & 0xFF) << 8);
            o = o | (((int) (this.ReadInt8()) & 0xFF) << 16);
            o = o | (((int) (this.ReadInt8()) & 0xFF) << 24);
            return o;
        }
        public long ReadInt64()
        {
            long o;
            o = (long) (this.ReadInt8()) & 0xFF;
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 8);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 16);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 24);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 32);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 40);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 48);
            o = o | (((long) (this.ReadInt8()) & 0xFF) << 56);
            return o;
        }

        public float ReadFloat32()
        {
            return Float.intBitsToFloat(this.ReadInt32());
        }
        public double ReadFloat64()
        {
            return Double.longBitsToDouble(this.ReadInt64());
        }

        public String ReadString()
        {
            int n = this.ReadInt32();
            byte[] s = new byte[n];
            for (int k = 0; k < n; k += 1)
            {
                s[k] = this.ReadInt8();
            }
            try
            {
                return new String(s, "UTF-16LE");
            }
            catch (java.io.UnsupportedEncodingException ex)
            {
                throw new RuntimeException(ex);
            }
        }
    };

    public static abstract class IWritableStream
    {
        public abstract void WriteByte(byte b);
        public abstract void WriteBytes(byte[] l);

        public void WriteUnit(Unit v)
        {
        }
        public void WriteBoolean(boolean v)
        {
            if (v)
            {
                WriteByte((byte)(0xFF));
            }
            else
            {
                WriteByte((byte)(0));
            }
        }

        public void WriteUInt8(byte v)
        {
            WriteByte(v);
        }
        public void WriteUInt16(short v)
        {
            WriteByte((byte)(v & 0xFF));
            WriteByte((byte)((v >> 8) & 0xFF));
        }
        public void WriteUInt32(int v)
        {
            WriteByte((byte)(v & 0xFF));
            WriteByte((byte)((v >> 8) & 0xFF));
            WriteByte((byte)((v >> 16) & 0xFF));
            WriteByte((byte)((v >> 24) & 0xFF));
        }
        public void WriteUInt64(long v)
        {
            WriteByte((byte)(v & 0xFF));
            WriteByte((byte)((v >> 8) & 0xFF));
            WriteByte((byte)((v >> 16) & 0xFF));
            WriteByte((byte)((v >> 24) & 0xFF));
            WriteByte((byte)((v >> 32) & 0xFF));
            WriteByte((byte)((v >> 40) & 0xFF));
            WriteByte((byte)((v >> 48) & 0xFF));
            WriteByte((byte)((v >> 56) & 0xFF));
        }
        public void WriteInt8(byte v)
        {
            WriteByte((byte)(v));
        }
        public void WriteInt16(short v)
        {
            WriteByte((byte)(v & 0xFF));
            WriteByte((byte)((v >> 8) & 0xFF));
        }
        public void WriteInt32(int v)
        {
            WriteByte((byte)(v & 0xFF));
            WriteByte((byte)((v >> 8) & 0xFF));
            WriteByte((byte)((v >> 16) & 0xFF));
            WriteByte((byte)((v >> 24) & 0xFF));
        }
        public void WriteInt64(long v)
        {
            WriteByte((byte)(v & 0xFF));
            WriteByte((byte)((v >> 8) & 0xFF));
            WriteByte((byte)((v >> 16) & 0xFF));
            WriteByte((byte)((v >> 24) & 0xFF));
            WriteByte((byte)((v >> 32) & 0xFF));
            WriteByte((byte)((v >> 40) & 0xFF));
            WriteByte((byte)((v >> 48) & 0xFF));
            WriteByte((byte)((v >> 56) & 0xFF));
        }

        public void WriteFloat32(float v)
        {
            WriteInt32(Float.floatToIntBits(v));
        }
        public void WriteFloat64(double v)
        {
            WriteInt64(Double.doubleToLongBits(v));
        }

        public void WriteString(String v)
        {
            byte[] l;
            try
            {
                l = v.getBytes("UTF-16LE");
            }
            catch (java.io.UnsupportedEncodingException ex)
            {
                throw new RuntimeException(ex);
            }
            WriteInt32(l.length);
            for (int k = 0; k < l.length; k += 1)
            {
                WriteByte(l[k]);
            }
        }
    };

#Template BinaryTranslator Schema:Schema
    public static final class BinaryTranslator
    {
        ${GetBinaryTranslatorSerializers(Schema)}
    }

#Template BinaryTranslator_Primitive_Unit
    public static Unit UnitFromBinary(IReadableStream s)
    {
        return s.ReadUnit();
    }
    public static void UnitToBinary(IWritableStream s, Unit v)
    {
        s.WriteUnit(v);
    }

#Template BinaryTranslator_Primitive_Boolean
    public static Boolean BooleanFromBinary(IReadableStream s)
    {
        return s.ReadBoolean();
    }
    public static void BooleanToBinary(IWritableStream s, Boolean v)
    {
        s.WriteBoolean(v);
    }

#Template BinaryTranslator_Primitive_String
    public static String StringFromBinary(IReadableStream s)
    {
        return s.ReadString();
    }
    public static void StringToBinary(IWritableStream s, String v)
    {
        s.WriteString(v);
    }

#Template BinaryTranslator_Primitive_Int
    public static int IntFromBinary(IReadableStream s)
    {
        return s.ReadInt32();
    }
    public static void IntToBinary(IWritableStream s, int v)
    {
        s.WriteInt32(v);
    }

#Template BinaryTranslator_Primitive_Real
    public static double RealFromBinary(IReadableStream s)
    {
        return s.ReadFloat64();
    }
    public static void RealToBinary(IWritableStream s, double v)
    {
        s.WriteFloat64(v);
    }

#Template BinaryTranslator_Primitive_Byte
    public static byte ByteFromBinary(IReadableStream s)
    {
        return s.ReadByte();
    }
    public static void ByteToBinary(IWritableStream s, byte v)
    {
        s.WriteByte(v);
    }

#Template BinaryTranslator_Primitive_UInt8
    public static byte UInt8FromBinary(IReadableStream s)
    {
        return s.ReadUInt8();
    }
    public static void UInt8ToBinary(IWritableStream s, byte v)
    {
        s.WriteUInt8(v);
    }

#Template BinaryTranslator_Primitive_UInt16
    public static short UInt16FromBinary(IReadableStream s)
    {
        return s.ReadUInt16();
    }
    public static void UInt16ToBinary(IWritableStream s, short v)
    {
        s.WriteUInt16(v);
    }

#Template BinaryTranslator_Primitive_UInt32
    public static int UInt32FromBinary(IReadableStream s)
    {
        return s.ReadUInt32();
    }
    public static void UInt32ToBinary(IWritableStream s, int v)
    {
        s.WriteUInt32(v);
    }

#Template BinaryTranslator_Primitive_UInt64
    public static long UInt64FromBinary(IReadableStream s)
    {
        return s.ReadUInt64();
    }
    public static void UInt64ToBinary(IWritableStream s, long v)
    {
        s.WriteUInt64(v);
    }

#Template BinaryTranslator_Primitive_Int8
    public static byte Int8FromBinary(IReadableStream s)
    {
        return s.ReadInt8();
    }
    public static void Int8ToBinary(IWritableStream s, byte v)
    {
        s.WriteInt8(v);
    }

#Template BinaryTranslator_Primitive_Int16
    public static short Int16FromBinary(IReadableStream s)
    {
        return s.ReadInt16();
    }
    public static void Int16ToBinary(IWritableStream s, short v)
    {
        s.WriteInt16(v);
    }

#Template BinaryTranslator_Primitive_Int32
    public static int Int32FromBinary(IReadableStream s)
    {
        return s.ReadInt32();
    }
    public static void Int32ToBinary(IWritableStream s, int v)
    {
        s.WriteInt32(v);
    }

#Template BinaryTranslator_Primitive_Int64
    public static long Int64FromBinary(IReadableStream s)
    {
        return s.ReadInt64();
    }
    public static void Int64ToBinary(IWritableStream s, long v)
    {
        s.WriteInt64(v);
    }

#Template BinaryTranslator_Primitive_Float32
    public static float Float32FromBinary(IReadableStream s)
    {
        return s.ReadFloat32();
    }
    public static void Float32ToBinary(IWritableStream s, float v)
    {
        s.WriteFloat32(v);
    }

#Template BinaryTranslator_Primitive_Float64
    public static double Float64FromBinary(IReadableStream s)
    {
        return s.ReadFloat64();
    }
    public static void Float64ToBinary(IWritableStream s, double v)
    {
        s.WriteFloat64(v);
    }

#Template BinaryTranslator_Primitive_Type
    public static java.lang.reflect.Type TypeFromBinary(IReadableStream s)
    {
        throw new RuntimeException("NotSupported");
    }
    public static void TypeToBinary(IWritableStream s, java.lang.reflect.Type v)
    {
        throw new RuntimeException("NotSupported");
    }

#Template BinaryTranslator_Alias a:AliasDef
    $$
        var Name = a.TypeFriendlyName();
        var ValueTypeFriendlyName = a.Type.TypeFriendlyName();
    public static [[${Name}]] [[${Name}FromBinary]](IReadableStream s)
    {
        [[${Name}]] o = new [[${Name}]]();
        o.Value = [[${ValueTypeFriendlyName}FromBinary]](s);
        return o;
    }
    public static void [[${Name}ToBinary]](IWritableStream s, [[${Name}]] o)
    {
        [[${ValueTypeFriendlyName}ToBinary]](s, o.Value);
    }

#Template BinaryTranslator_Record r:RecordDef
    ${BinaryTranslator_Record(r.TypeFriendlyName(), r.Fields)}

#Template BinaryTranslator_Record Name:String Fields:List<VariableDef>
    public static [[${Name}]] [[${Name}FromBinary]](IReadableStream s)
    {
        [[${Name}]] o = new [[${Name}]]();
        $$
            foreach (var a in Fields)
            {
                ##
                    o.[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromBinary]](s);
            }
        return o;
    }
    public static void [[${Name}ToBinary]](IWritableStream s, [[${Name}]] o)
    {
        $$
            foreach (var a in Fields)
            {
                ##
                    [[${a.Type.TypeFriendlyName()}ToBinary]](s, o.[[${a.Name}]]);
            }
    }

#Template BinaryTranslator_TaggedUnion tu:TaggedUnionDef
    ${BinaryTranslator_TaggedUnion(tu.TypeFriendlyName(), tu.Alternatives)}

#Template BinaryTranslator_TaggedUnion Name:String Alternatives:List<VariableDef>
    ${BinaryTranslator_Enum(Name + "Tag", "Int", "int")}
    public static [[${Name}]] [[${Name}FromBinary]](IReadableStream s)
    {
        [[${Name}]] o = new [[${Name}]]();
        o._Tag = [[${Name}TagFromBinary]](s);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag.${a.Name}]])
                    {
                        o.[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromBinary]](s);
                        return o;
                    }
            }
        throw new RuntimeException("InvalidOperation");
    }
    public static void [[${Name}ToBinary]](IWritableStream s, [[${Name}]] o)
    {
        [[${Name}TagToBinary]](s, o._Tag);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag.${a.Name}]])
                    {
                        [[${a.Type.TypeFriendlyName()}ToBinary]](s, o.[[${a.Name}]]);
                        return;
                    }
            }
        throw new RuntimeException("InvalidOperation");
    }

#Template BinaryTranslator_Enum e:EnumDef
    ${BinaryTranslator_Enum(e.TypeFriendlyName(), e.UnderlyingType.TypeFriendlyName(), GetTypeString(e.UnderlyingType))}

#Template BinaryTranslator_Enum Name:String UnderlyingTypeFriendlyName:String UnderlyingType:String
    public static ${UnderlyingType} [[${Name}FromBinary]](IReadableStream s)
    {
        return [[${UnderlyingTypeFriendlyName}FromBinary]](s);
    }
    public static void [[${Name}ToBinary]](IWritableStream s, ${UnderlyingType} o)
    {
        [[${UnderlyingTypeFriendlyName}ToBinary]](s, o);
    }

#Template BinaryTranslator_ClientCommand c:ClientCommandDef
    ${BinaryTranslator_Record(c.TypeFriendlyName() + "Request", c.OutParameters)}
    ${BinaryTranslator_TaggedUnion(c.TypeFriendlyName() + "Reply", c.InParameters)}

#Template BinaryTranslator_ServerCommand c:ServerCommandDef
    ${BinaryTranslator_Record(c.TypeFriendlyName() + "Event", c.OutParameters)}

#Template BinaryTranslator_Tuple tp:TypeSpec
    $$
        var TypeFriendlyName = tp.TypeFriendlyName();
        var TypeString = GetTypeString(tp);
    public static [[${TypeFriendlyName}]] [[${TypeFriendlyName}FromBinary]](IReadableStream s)
    {
        [[${TypeFriendlyName}]] t = new [[${TypeFriendlyName}]]();
        $$
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        t.[[Item${k}]] = [[${t.TypeFriendlyName()}FromBinary]](s);
                    k += 1;
                }
            }
        return t;
    }
    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, [[${TypeFriendlyName}]] t)
    {
        $$
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        [[${t.TypeFriendlyName()}ToBinary]](s, t.[[Item${k}]]);
                    k += 1;
                }
            }
    }

#Template BinaryTranslator_Optional o:TypeSpec GenericOptionalType:TaggedUnionDef
    $$
        var ElementType = o.GenericTypeSpec.ParameterValues.Single();
        var Alternatives = GenericOptionalType.Alternatives.Select(a => new VariableDef { Name = a.Name, Type = a.Type.OnGenericParameterRef ? ElementType : a.Type, Attributes = a.Attributes, Description = a.Description }).ToList();
        var TypeFriendlyName = o.TypeFriendlyName();
        var TypeString = GetTypeString(o);
        var Name = TypeString;
    public static ${TypeString} [[${TypeFriendlyName}FromBinary]](IReadableStream s)
    {
        ${TypeString} o = new ${TypeString}();
        o._Tag = OptionalTagFromBinary(s);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag.${a.Name}]])
                    {
                        o.[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromBinary]](s);
                        return o;
                    }
            }
        throw new RuntimeException("InvalidOperation");
    }
    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, ${TypeString} o)
    {
        OptionalTagToBinary(s, o._Tag);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag.${a.Name}]])
                    {
                        [[${a.Type.TypeFriendlyName()}ToBinary]](s, o.[[${a.Name}]]);
                        return;
                    }
            }
        throw new RuntimeException("InvalidOperation");
    }

#Template BinaryTranslator_List l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
        var ElementTypeString = GetTypeString(l.GenericTypeSpec.ParameterValues.Single());
    public static ${TypeString} [[${TypeFriendlyName}FromBinary]](IReadableStream s)
    {
        int Length = IntFromBinary(s);
        ${TypeString} l = new ${TypeString}(Length);
        for (int k = 0; k < Length; k += 1)
        {
            l.add([[${ElementTypeFriendlyName}FromBinary]](s));
        }
        return l;
    }
    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, ${TypeString} l)
    {
        int Length = l.size();
        IntToBinary(s, Length);
        for (${ElementTypeString} e : l)
        {
            [[${ElementTypeFriendlyName}ToBinary]](s, e);
        }
    }

#Template BinaryTranslator_Set l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
        var ElementTypeString = GetTypeString(l.GenericTypeSpec.ParameterValues.Single());
    public static ${TypeString} [[${TypeFriendlyName}FromBinary]](IReadableStream s)
    {
        int Length = IntFromBinary(s);
        ${TypeString} l = new ${TypeString}(Length);
        for (int k = 0; k < Length; k += 1)
        {
            l.add([[${ElementTypeFriendlyName}FromBinary]](s));
        }
        return l;
    }
    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, ${TypeString} l)
    {
        int Length = l.size();
        IntToBinary(s, Length);
        for (${ElementTypeString} e : l)
        {
            [[${ElementTypeFriendlyName}ToBinary]](s, e);
        }
    }

#Template BinaryTranslator_Map l:TypeSpec
    $$
        var gp = l.GenericTypeSpec.ParameterValues;
        if (gp.Count != 2)
        {
            throw new ArgumentException();
        }
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var KeyTypeString = GetTypeString(gp[0]);
        var KeyTypeFriendlyName = gp[0].TypeFriendlyName();
        var ValueTypeFriendlyName = gp[1].TypeFriendlyName();
    public static ${TypeString} [[${TypeFriendlyName}FromBinary]](IReadableStream s)
    {
        int Length = IntFromBinary(s);
        ${TypeString} l = new ${TypeString}(Length);
        for (int k = 0; k < Length; k += 1)
        {
            ${KeyTypeString} Key = [[${KeyTypeFriendlyName}FromBinary]](s);
            l.put(Key, [[${ValueTypeFriendlyName}FromBinary]](s));
        }
        return l;
    }
    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, ${TypeString} l)
    {
        int Length = l.size();
        IntToBinary(s, Length);
        for (${KeyTypeString} Key : l.keySet())
        {
            [[${KeyTypeFriendlyName}ToBinary]](s, Key);
            [[${ValueTypeFriendlyName}ToBinary]](s, l.get(Key));
        }
    }

#Template Main Schema:Schema ClassName:String PackageName:String
    //==========================================================================
    //
    //  Notice:      This file is automatically generated.
    //               Please don't modify this file.
    //
    //==========================================================================

    $$
        if (PackageName != "")
        {
            ##
                package ${PackageName};
        }
    import ${Schema.Imports}.*;
    ${GetPrimitives(Schema)}

    public class ${ClassName}
    {
        ${GetComplexTypes(Schema)}
    }

$End
