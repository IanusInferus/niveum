$Comment
    ==========================================================================

      File:        CSharpBinary.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C#二进制通讯模板数据
      Version:     2012.04.23.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name MainWithNamespace
            //Parameters: ${Header}, ${NamespaceName}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    namespace [[${NamespaceName}]]
                    {
                        ${ComplexTypes}
                    }

                $End
        Template
            Name MainWithoutNamespace
            //Parameters: ${Header}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    ${ComplexTypes}

                $End
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    //Reference:

                    using System;
                    using System.Collections.Generic;
                    using Firefly;
                    using Firefly.Streaming;
                    using Firefly.Mapping;
                    using Firefly.Mapping.Binary;
                    using Firefly.TextEncoding;
        Template
            Name BinaryServer
            //Parameters: ${Hash}, ${Commands}
            Value
                $String
                    public sealed class BinaryServer<TContext>
                    {
                        private Dictionary<KeyValuePair<String, UInt32>, Func<TContext, Byte[], Byte[]>> ClientCommands;
                        private BinaryTranslator bt = new BinaryTranslator();

                        public BinaryServer(IServerImplementation<TContext> i)
                        {
                            ClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Func<TContext, Byte[], Byte[]>>();
                            ${Commands}
                        }

                        public UInt64 Hash
                        {
                            get
                            {
                                return 0x${Hash};
                            }
                        }

                        public Boolean HasCommand(String CommandName, UInt32 CommandHash)
                        {
                            return ClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
                        }

                        public Byte[] ExecuteCommand(TContext c, String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            var cmd = ClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
                            return cmd(c, Parameters);
                        }

                        public delegate void ServerEventDelegate(TContext c, String CommandName, UInt32 CommandHash, Byte[] Parameters);
                        public event ServerEventDelegate ServerEvent;
                        private void OnServerEvent(TContext c, String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            if (ServerEvent != null) { ServerEvent(c, CommandName, CommandHash, Parameters); }
                        }
                    }
        Template
            Name BinaryServer_ClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ClientCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), (c, p) => bt.Serialize(i.[[${Name}]](c, bt.Deserialize<[[${Name}Request]]>(p))));
        Template
            Name BinaryServer_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    i.${Name} += (c, e) => OnServerEvent(c, @"${CommandName}", 0x${CommandHash}, bt.Serialize(e));
        Template
            Name IBinarySender
            Value
                $String
                    public interface IBinarySender
                    {
                        void Send(String CommandName, UInt32 CommandHash, Byte[] Parameters);
                    }
        Template
            Name BinaryClient
            //Parameters: ${Hash}, ${ClientCommands}, ${ServerCommands}
            Value
                $String
                    public sealed class BinaryClient<TContext>
                    {
                        private IBinarySender s;
                        private IClientImplementation<TContext> i;
                        private Dictionary<String, Queue<KeyValuePair<UInt32, Action<TContext, Byte[]>>>> ClientCommandCallbacks;
                        private Dictionary<KeyValuePair<String, UInt32>, Action<TContext, Byte[]>> ServerCommands;
                        private BinaryTranslator bt = new BinaryTranslator();

                        public BinaryClient(IBinarySender s, IClientImplementation<TContext> i)
                        {
                            this.s = s;
                            this.i = i;
                            ClientCommandCallbacks = new Dictionary<String, Queue<KeyValuePair<UInt32, Action<TContext, Byte[]>>>>();
                            ServerCommands = new Dictionary<KeyValuePair<String, UInt32>, Action<TContext, Byte[]>>();
                            ${ServerCommands}
                        }

                        public UInt64 Hash
                        {
                            get
                            {
                                return 0x${Hash};
                            }
                        }

                        public void HandleResult(TContext c, String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            if (ClientCommandCallbacks.ContainsKey(CommandName))
                            {
                                var q = ClientCommandCallbacks[CommandName];
                                if (q.Count == 0)
                                {
                                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8"));
                                }
                                var CallbackPair = q.Peek();
                                if (CallbackPair.Key != CommandHash)
                                {
                                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8"));
                                }
                                q.Dequeue();
                                var Callback = CallbackPair.Value;
                                Callback(c, Parameters);
                                return;
                            }

                            var p = new KeyValuePair<String, UInt32>(CommandName, CommandHash);
                            if (ServerCommands.ContainsKey(p))
                            {
                                var a = ServerCommands[p];
                                a(c, Parameters);
                                return;
                            }

                            throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8"));
                        }

                        private void AddCallback(String CommandName, UInt32 CommandHash, Action<TContext, Byte[]> Callback)
                        {
                            if (ClientCommandCallbacks.ContainsKey(CommandName))
                            {
                                ClientCommandCallbacks[CommandName].Enqueue(new KeyValuePair<UInt32, Action<TContext, Byte[]>>(CommandHash, Callback));
                            }
                            else
                            {
                                var q = new Queue<KeyValuePair<UInt32, Action<TContext, Byte[]>>>();
                                q.Enqueue(new KeyValuePair<UInt32, Action<TContext, Byte[]>>(CommandHash, Callback));
                                ClientCommandCallbacks.Add(CommandName, q);
                            }
                        }

                        public void DequeueCallback(String CommandName)
                        {
                            ClientCommandCallbacks[CommandName].Dequeue();
                        }

                        ${ClientCommands}
                    }
        Template
            Name BinaryClient_ClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public void [[${Name}]]([[${Name}Request]] r, Action<TContext, [[${Name}Reply]]> Callback)
                    {
                        var Request = bt.Serialize(r);
                        AddCallback(@"${CommandName}", 0x${CommandHash}, (c, Parameters) => Callback(c, bt.Deserialize<[[${Name}Reply]]>(Parameters)));
                        s.Send(@"${CommandName}", 0x${CommandHash}, Request);
                    }
        Template
            Name BinaryClient_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ServerCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), (c, Parameters) => i.[[${Name}]](c, bt.Deserialize<[[${Name}Event]]>(Parameters)));
        Template
            Name BinaryTranslator
            //Parameters: ${Serializers}
            Value
                $String
                    public class BinaryTranslator
                    {
                        private BinarySerializer bs;

                        public BinaryTranslator()
                        {
                            bs = new BinarySerializer();
                            var st = new StringTranslator();
                            bs.PutReaderTranslator(st);
                            bs.PutWriterTranslator(st);
                            bs.PutCounterTranslator(st);
                        }

                        public Byte[] Serialize<T>(T Value)
                        {
                            using (var s = Streams.CreateMemoryStream())
                            {
                                bs.Write<T>(Value, s);
                                s.Position = 0;
                                return s.Read((int)(s.Length));
                            }
                        }
                        public T Deserialize<T>(Byte[] Bytes)
                        {
                            using (var s = Streams.CreateMemoryStream())
                            {
                                s.Write(Bytes);
                                s.Position = 0;
                                return bs.Read<T>(s);
                            }
                        }

                        private class StringTranslator : IProjectorToProjectorDomainTranslator<String, Byte[]>, IProjectorToProjectorRangeTranslator<String, Byte[]>
                        {
                            public Func<String, R> TranslateProjectorToProjectorDomain<R>(Func<Byte[], R> Projector)
                            {
                                return s => Projector(TextEncoding.UTF16.GetBytes(s));
                            }

                            public Func<D, String> TranslateProjectorToProjectorRange<D>(Func<D, Byte[]> Projector)
                            {
                                return k => TextEncoding.UTF16.GetString(Projector(k));
                            }
                        }
                    }
