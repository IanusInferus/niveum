$Comment
    ==========================================================================

      File:        Schema.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C#二进制通讯模板数据
      Version:     2014.02.11.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name MainWithNamespace
            //Parameters: ${Header}, ${NamespaceName}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    namespace [[${NamespaceName}]]
                    {
                        ${ComplexTypes}
                    }

                $End
        Template
            Name MainWithoutNamespace
            //Parameters: ${Header}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    ${ComplexTypes}

                $End
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    //Reference:

                    using System;
                    using System.Collections.Generic;
                    using System.Threading;
        Template
            Name Header_WithFirefly
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    //Reference:

                    using System;
                    using System.Collections.Generic;
                    using System.Threading;
                    using Firefly;
                    using Firefly.Streaming;
                    using Firefly.Mapping;
                    using Firefly.Mapping.Binary;
                    using Firefly.TextEncoding;
        Template
            Name BinarySerializationServer
            //Parameters: ${Hash}, ${ClientCommands}, ${ServerCommands}
            Value
                $String
                    public sealed class BinarySerializationServer
                    {
                        private Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, Byte[], Byte[]>> ClientCommands;
                        private Dictionary<KeyValuePair<String, UInt32>, Action<IApplicationServer, Byte[], Action<Byte[]>, Action<Exception>>> AsyncClientCommands;

                        public BinarySerializationServer()
                        {
                            ClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, Byte[], Byte[]>>();
                            AsyncClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Action<IApplicationServer, UInt8[], Action<UInt8[]>, Action<Exception>>>();
                            ${ClientCommands}
                        }

                        public UInt64 Hash
                        {
                            get
                            {
                                return 0x${Hash};
                            }
                        }

                        public Boolean HasCommand(String CommandName, UInt32 CommandHash)
                        {
                            return ClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
                        }
                        public Boolean HasCommandAsync(String CommandName, UInt32 CommandHash)
                        {
                            return AsyncClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
                        }

                        public Byte[] ExecuteCommand(IApplicationServer s, String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            var cmd = ClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
                            return cmd(s, Parameters);
                        }
                        public void ExecuteCommandAsync(IApplicationServer s, String CommandName, UInt32 CommandHash, Byte[] Parameters, Action<Byte[]> Callback, Action<Exception> OnFailure)
                        {
                            var cmd = AsyncClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
                            cmd(s, Parameters, Callback, OnFailure);
                        }
                    }
                    public sealed class BinarySerializationServerEventDispatcher
                    {
                        public BinarySerializationServerEventDispatcher(IApplicationServer s)
                        {
                            ${ServerCommands}
                        }

                        public delegate void ServerEventDelegate(String CommandName, UInt32 CommandHash, Byte[] Parameters);
                        public event ServerEventDelegate ServerEvent;
                        private void OnServerEvent(String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            if (ServerEvent != null) { ServerEvent(CommandName, CommandHash, Parameters); }
                        }
                    }
        Template
            Name BinarySerializationServer_ClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ClientCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), (s, p) =>
                    {
                        using (var bas = new ByteArrayStream())
                        {
                            bas.WriteBytes(p);
                            bas.Position = 0;
                            var Request = BinaryTranslator.[[${Name}RequestFromBinary]](bas);
                            var Reply = s.[[${Name}]](Request);
                            bas.Position = 0;
                            bas.SetLength(0);
                            BinaryTranslator.[[${Name}ReplyToBinary]](bas, Reply);
                            bas.Position = 0;
                            return bas.ReadBytes(bas.Length);
                        }
                    });
        Template
            Name BinarySerializationServer_ClientCommandAsync
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    AsyncClientCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), (s, p, Callback, OnFailure) =>
                    {
                        using (var bas = new ByteArrayStream())
                        {
                            bas.WriteBytes(p);
                            bas.Position = 0;
                            var Request = BinaryTranslator.[[${Name}RequestFromBinary]](bas);
                            s.[[${Name}]](Request, Reply =>
                            {
                                using (var rbas = new ByteArrayStream())
                                {
                                    BinaryTranslator.[[${Name}ReplyToBinary]](rbas, Reply);
                                    rbas.Position = 0;
                                    Callback(rbas.ReadBytes(rbas.Length));
                                }
                            }, OnFailure);
                        }
                    });
        Template
            Name BinarySerializationServer_ClientCommand_WithFirefly
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ClientCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), (s, p) => BinaryTranslator.Serialize(s.[[${Name}]](BinaryTranslator.Deserialize<[[${Name}Request]]>(p))));
        Template
            Name BinarySerializationServer_ClientCommandAsync_WithFirefly
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    AsyncClientCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), (s, p, Callback, OnFailure) => s.[[${Name}]](BinaryTranslator.Deserialize<[[${Name}Request]]>(p), Reply => Callback(BinaryTranslator.Serialize(Reply)), OnFailure));
        Template
            Name BinarySerializationServer_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    s.${Name} += e =>
                    {
                        using (var bas = new ByteArrayStream())
                        {
                            BinaryTranslator.[[${Name}EventToBinary]](bas, e);
                            bas.Position = 0;
                            OnServerEvent(@"${CommandName}", 0x${CommandHash}, bas.ReadBytes(bas.Length));
                        }
                    };
        Template
            Name BinarySerializationServer_ServerCommand_WithFirefly
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    s.${Name} += e => OnServerEvent(@"${CommandName}", 0x${CommandHash}, BinaryTranslator.Serialize(e));
        Template
            Name IBinarySender
            Value
                $String
                    public interface IBinarySender
                    {
                        void Send(String CommandName, UInt32 CommandHash, Byte[] Parameters);
                    }
        Template
            Name BinarySerializationClient
            //Parameters: ${Hash}, ${ApplicationCommands}, ${ServerCommands}
            Value
                $String
                    public sealed class BinarySerializationClient
                    {
                        public IApplicationClient GetApplicationClient()
                        {
                            return c;
                        }

                        private class ApplicationClient : IApplicationClient
                        {
                            public IBinarySender s;
                            public Dictionary<String, Queue<KeyValuePair<UInt32, Action<Byte[]>>>> ClientCommandCallbacks;

                            public UInt64 Hash
                            {
                                get
                                {
                                    return 0x${Hash};
                                }
                            }

                            public void DequeueCallback(String CommandName)
                            {
                                ClientCommandCallbacks[CommandName].Dequeue();
                            }

                            private void AddCallback(String CommandName, UInt32 CommandHash, Action<Byte[]> Callback)
                            {
                                if (ClientCommandCallbacks.ContainsKey(CommandName))
                                {
                                    ClientCommandCallbacks[CommandName].Enqueue(new KeyValuePair<UInt32, Action<Byte[]>>(CommandHash, Callback));
                                }
                                else
                                {
                                    var q = new Queue<KeyValuePair<UInt32, Action<Byte[]>>>();
                                    q.Enqueue(new KeyValuePair<UInt32, Action<Byte[]>>(CommandHash, Callback));
                                    ClientCommandCallbacks.Add(CommandName, q);
                                }
                            }

                            ${ApplicationCommands}
                        }

                        private ApplicationClient c;
                        private Dictionary<KeyValuePair<String, UInt32>, Action<Byte[]>> ServerCommands;

                        public BinarySerializationClient(IBinarySender s)
                        {
                            c = new ApplicationClient();
                            c.s = s;
                            c.ClientCommandCallbacks = new Dictionary<String, Queue<KeyValuePair<UInt32, Action<Byte[]>>>>();
                            ServerCommands = new Dictionary<KeyValuePair<String, UInt32>, Action<Byte[]>>();
                            ${ServerCommands}
                        }

                        public void HandleResult(String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            if (c.ClientCommandCallbacks.ContainsKey(CommandName))
                            {
                                var q = c.ClientCommandCallbacks[CommandName];
                                if (q.Count == 0)
                                {
                                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                                }
                                var CallbackPair = q.Peek();
                                if (CallbackPair.Key != CommandHash)
                                {
                                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                                }
                                q.Dequeue();
                                var Callback = CallbackPair.Value;
                                Callback(Parameters);
                                return;
                            }

                            var p = new KeyValuePair<String, UInt32>(CommandName, CommandHash);
                            if (ServerCommands.ContainsKey(p))
                            {
                                var a = ServerCommands[p];
                                a(Parameters);
                                return;
                            }

                            throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                        }
                    }
        Template
            Name BinarySerializationClient_ApplicationClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    public void [[${Name}]]([[${Name}Request]] r, Action<[[${Name}Reply]]> Callback)
                    {
                        using (var bas = new ByteArrayStream())
                        {
                            BinaryTranslator.[[${Name}RequestToBinary]](bas, r);
                            bas.Position = 0;
                            var Request = bas.ReadBytes(bas.Length);
                            AddCallback(@"${CommandName}", 0x${CommandHash}, Parameters =>
                            {
                                using (var basr = new ByteArrayStream())
                                {
                                    basr.WriteBytes(Parameters);
                                    basr.Position = 0;
                                    var Reply = BinaryTranslator.[[${Name}ReplyFromBinary]](basr);
                                    Callback(Reply);
                                }
                            });
                            s.Send(@"${CommandName}", 0x${CommandHash}, Request);
                        }
                    }
        Template
            Name BinarySerializationClient_ApplicationClientCommand_WithFirefly
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    public void [[${Name}]]([[${Name}Request]] r, Action<[[${Name}Reply]]> Callback)
                    {
                        var Request = BinaryTranslator.Serialize(r);
                        AddCallback(@"${CommandName}", 0x${CommandHash}, Parameters => Callback(BinaryTranslator.Deserialize<[[${Name}Reply]]>(Parameters)));
                        s.Send(@"${CommandName}", 0x${CommandHash}, Request);
                    }
        Template
            Name BinarySerializationClient_ApplicationServerCommand
            //Parameters: ${Name}
            Value
                $String
                    public event Action<[[${Name}Event]]> [[${Name}]];
                    public void [[Raise${Name}]]([[${Name}Event]] e) { if ([[${Name}]] != null) { [[${Name}]](e); } }
        Template
            Name BinarySerializationClient_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ServerCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), Parameters =>
                    {
                        using (var bas = new ByteArrayStream())
                        {
                            bas.WriteBytes(Parameters);
                            bas.Position = 0;
                            var e = BinaryTranslator.[[${Name}EventFromBinary]](bas);
                            c.[[Raise${Name}]](e);
                        }
                    });
        Template
            Name BinarySerializationClient_ServerCommand_WithFirefly
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ServerCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), Parameters => c.[[Raise${Name}]](BinaryTranslator.Deserialize<[[${Name}Event]]>(Parameters)));
        Template
            Name BinaryTranslator_WithFirefly
            //Parameters: ${Serializers}
            Value
                $String
                    public static class BinaryTranslator
                    {
                        private static ThreadLocal<BinarySerializer> bs = new ThreadLocal<BinarySerializer>
                        (
                            () =>
                            {
                                var s = new BinarySerializer();
                                var st = new StringTranslator();
                                s.PutReaderTranslator(st);
                                s.PutWriterTranslator(st);
                                s.PutCounterTranslator(st);
                                return s;
                            }
                        );

                        public static Byte[] Serialize<T>(T Value)
                        {
                            using (var s = Streams.CreateMemoryStream())
                            {
                                bs.Value.Write<T>(Value, s);
                                s.Position = 0;
                                return s.Read((int)(s.Length));
                            }
                        }
                        public static T Deserialize<T>(Byte[] Bytes)
                        {
                            using (var s = new ByteArrayStream(Bytes))
                            {
                                return bs.Value.Read<T>(s);
                            }
                        }

                        private class StringTranslator : IProjectorToProjectorDomainTranslator<String, Byte[]>, IProjectorToProjectorRangeTranslator<String, Byte[]>
                        {
                            public Func<String, R> TranslateProjectorToProjectorDomain<R>(Func<Byte[], R> Projector)
                            {
                                return s => Projector(TextEncoding.UTF16.GetBytes(s));
                            }

                            public Func<D, String> TranslateProjectorToProjectorRange<D>(Func<D, Byte[]> Projector)
                            {
                                return k => TextEncoding.UTF16.GetString(Projector(k));
                            }
                        }
                    }
        Template
            Name Streams
            Value
                $String
                    public interface IReadableStream : IDisposable
                    {
                        Byte ReadByte();
                        Byte[] ReadBytes(int Size);
                    }
                    public interface IWritableStream : IDisposable
                    {
                        void WriteByte(Byte b);
                        void WriteBytes(Byte[] Buffer);
                    }

                    public static class ReadStream
                    {
                        public static Unit ReadUnit(IReadableStream s)
                        {
                            return new Unit();
                        }
                        public static Boolean ReadBoolean(IReadableStream s)
                        {
                            return s.ReadByte() != 0;
                        }
                        public static Byte ReadByte(IReadableStream s)
                        {
                            return s.ReadByte();
                        }

                        public static Byte ReadUInt8(IReadableStream s)
                        {
                            return s.ReadByte();
                        }
                        public static UInt16 ReadUInt16(IReadableStream s)
                        {
                            UInt16 o;
                            o = (UInt16)((UInt16)(s.ReadByte()) & (UInt16)(0xFF));
                            o = (UInt16)(o | (((UInt16)(s.ReadByte()) & 0xFF) << 8));
                            return o;
                        }
                        public static UInt32 ReadUInt32(IReadableStream s)
                        {
                            UInt32 o;
                            o = (UInt32)(s.ReadByte()) & 0xFF;
                            o = o | (((UInt32)(s.ReadByte()) & 0xFF) << 8);
                            o = o | (((UInt32)(s.ReadByte()) & 0xFF) << 16);
                            o = o | (((UInt32)(s.ReadByte()) & 0xFF) << 24);
                            return o;
                        }
                        public static UInt64 ReadUInt64(IReadableStream s)
                        {
                            UInt64 o;
                            o = (UInt64)(s.ReadByte()) & 0xFF;
                            o = o | (((UInt64)(s.ReadByte()) & 0xFF) << 8);
                            o = o | (((UInt64)(s.ReadByte()) & 0xFF) << 16);
                            o = o | (((UInt64)(s.ReadByte()) & 0xFF) << 24);
                            o = o | (((UInt64)(s.ReadByte()) & 0xFF) << 32);
                            o = o | (((UInt64)(s.ReadByte()) & 0xFF) << 40);
                            o = o | (((UInt64)(s.ReadByte()) & 0xFF) << 48);
                            o = o | (((UInt64)(s.ReadByte()) & 0xFF) << 56);
                            return o;
                        }
                        public static SByte ReadInt8(IReadableStream s)
                        {
                            return unchecked((SByte)(s.ReadByte()));
                        }
                        public static Int16 ReadInt16(IReadableStream s)
                        {
                            Int16 o;
                            o = (Int16)((Int16)(s.ReadByte()) & (Int16)(0xFF));
                            o = (Int16)(o | (Int16)(((Int16)(s.ReadByte()) & 0xFF) << 8));
                            return o;
                        }
                        public static Int32 ReadInt32(IReadableStream s)
                        {
                            Int32 o;
                            o = (Int32)(s.ReadByte()) & 0xFF;
                            o = o | (((Int32)(s.ReadByte()) & 0xFF) << 8);
                            o = o | (((Int32)(s.ReadByte()) & 0xFF) << 16);
                            o = o | (((Int32)(s.ReadByte()) & 0xFF) << 24);
                            return o;
                        }
                        public static Int64 ReadInt64(IReadableStream s)
                        {
                            Int64 o;
                            o = (Int64)(s.ReadByte()) & 0xFF;
                            o = o | (((Int64)(s.ReadByte()) & 0xFF) << 8);
                            o = o | (((Int64)(s.ReadByte()) & 0xFF) << 16);
                            o = o | (((Int64)(s.ReadByte()) & 0xFF) << 24);
                            o = o | (((Int64)(s.ReadByte()) & 0xFF) << 32);
                            o = o | (((Int64)(s.ReadByte()) & 0xFF) << 40);
                            o = o | (((Int64)(s.ReadByte()) & 0xFF) << 48);
                            o = o | (((Int64)(s.ReadByte()) & 0xFF) << 56);
                            return o;
                        }

                        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
                        private struct FloatInt32
                        {
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Single Float32Value;
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Int32 Int32Value;
                        }
                        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
                        private struct FloatInt64
                        {
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Double Float64Value;
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Int64 Int64Value;
                        }
                        public static Single ReadFloat32(IReadableStream s)
                        {
                            var fi = new FloatInt32();
                            fi.Int32Value = ReadInt32(s);
                            return fi.Float32Value;
                        }
                        public static Double ReadFloat64(IReadableStream s)
                        {
                            var fi = new FloatInt64();
                            fi.Int64Value = ReadInt64(s);
                            return fi.Float64Value;
                        }

                        public static String ReadString(IReadableStream s)
                        {
                            var Length = ReadInt32(s);
                            var n = (int)(Length);
                            var Bytes = new List<Byte>();
                            for (int k = 0; k < n; k += 1)
                            {
                                Bytes.Add(s.ReadByte());
                            }
                            return System.Text.Encoding.Unicode.GetString(Bytes.ToArray());
                        }
                    }

                    public static class WriteStream
                    {
                        public static void WriteUnit(IWritableStream s, Unit v)
                        {
                        }
                        public static void WriteBoolean(IWritableStream s, Boolean v)
                        {
                            if (v)
                            {
                                s.WriteByte(0xFF);
                            }
                            else
                            {
                                s.WriteByte(0);
                            }
                        }
                        public static void WriteByte(IWritableStream s, Byte v)
                        {
                            s.WriteByte(v);
                        }

                        public static void WriteUInt8(IWritableStream s, Byte v)
                        {
                            s.WriteByte(v);
                        }
                        public static void WriteUInt16(IWritableStream s, UInt16 v)
                        {
                            s.WriteByte((Byte)(v & 0xFF));
                            s.WriteByte((Byte)((v >> 8) & 0xFF));
                        }
                        public static void WriteUInt32(IWritableStream s, UInt32 v)
                        {
                            s.WriteByte((Byte)(v & 0xFF));
                            s.WriteByte((Byte)((v >> 8) & 0xFF));
                            s.WriteByte((Byte)((v >> 16) & 0xFF));
                            s.WriteByte((Byte)((v >> 24) & 0xFF));
                        }
                        public static void WriteUInt64(IWritableStream s, UInt64 v)
                        {
                            s.WriteByte((Byte)(v & 0xFF));
                            s.WriteByte((Byte)((v >> 8) & 0xFF));
                            s.WriteByte((Byte)((v >> 16) & 0xFF));
                            s.WriteByte((Byte)((v >> 24) & 0xFF));
                            s.WriteByte((Byte)((v >> 32) & 0xFF));
                            s.WriteByte((Byte)((v >> 40) & 0xFF));
                            s.WriteByte((Byte)((v >> 48) & 0xFF));
                            s.WriteByte((Byte)((v >> 56) & 0xFF));
                        }
                        public static void WriteInt8(IWritableStream s, SByte v)
                        {
                            s.WriteByte(unchecked((Byte)(v)));
                        }
                        public static void WriteInt16(IWritableStream s, Int16 v)
                        {
                            s.WriteByte((Byte)(v & 0xFF));
                            s.WriteByte((Byte)((v >> 8) & 0xFF));
                        }
                        public static void WriteInt32(IWritableStream s, Int32 v)
                        {
                            s.WriteByte((Byte)(v & 0xFF));
                            s.WriteByte((Byte)((v >> 8) & 0xFF));
                            s.WriteByte((Byte)((v >> 16) & 0xFF));
                            s.WriteByte((Byte)((v >> 24) & 0xFF));
                        }
                        public static void WriteInt64(IWritableStream s, Int64 v)
                        {
                            s.WriteByte((Byte)(v & 0xFF));
                            s.WriteByte((Byte)((v >> 8) & 0xFF));
                            s.WriteByte((Byte)((v >> 16) & 0xFF));
                            s.WriteByte((Byte)((v >> 24) & 0xFF));
                            s.WriteByte((Byte)((v >> 32) & 0xFF));
                            s.WriteByte((Byte)((v >> 40) & 0xFF));
                            s.WriteByte((Byte)((v >> 48) & 0xFF));
                            s.WriteByte((Byte)((v >> 56) & 0xFF));
                        }

                        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
                        private struct FloatInt32
                        {
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Single Float32Value;
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Int32 Int32Value;
                        }
                        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
                        private struct FloatInt64
                        {
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Double Float64Value;
                            [System.Runtime.InteropServices.FieldOffset(0)]
                            public Int64 Int64Value;
                        }
                        public static void WriteFloat32(IWritableStream s, Single v)
                        {
                            var fi = new FloatInt32();
                            fi.Float32Value = v;
                            WriteInt32(s, fi.Int32Value);
                        }
                        public static void WriteFloat64(IWritableStream s, Double v)
                        {
                            var fi = new FloatInt64();
                            fi.Float64Value = v;
                            WriteInt64(s, fi.Int64Value);
                        }

                        public static void WriteString(IWritableStream s, String v)
                        {
                            var Bytes = System.Text.Encoding.Unicode.GetBytes(v);
                            WriteInt32(s, (Int32)(Bytes.Length));
                            foreach (var b in Bytes)
                            {
                                s.WriteByte(b);
                            }
                        }
                    }

                    public interface IReadableWritableStream : IReadableStream, IWritableStream
                    {
                    }

                    public sealed class ByteArrayStream : IReadableWritableStream
                    {
                        private List<Byte> Buffer;
                        public int Position { get; set; }

                        public ByteArrayStream()
                        {
                            Buffer = new List<Byte>();
                            Position = 0;
                        }
                        public void Dispose()
                        {
                        }

                        public Byte ReadByte()
                        {
                            if (Position + 1 > Buffer.Count) { throw new IndexOutOfRangeException(); }
                            var b = Buffer[Position];
                            Position += 1;
                            return b;
                        }
                        public Byte[] ReadBytes(int Size)
                        {
                            if (Position + Size > Buffer.Count) { throw new IndexOutOfRangeException(); }
                            var l = new Byte[Size];
                            if (Size == 0) { return l; }
                            Buffer.CopyTo(Position, l, 0, Size);
                            Position += Size;
                            return l;
                        }

                        public void WriteByte(Byte b)
                        {
                            if (Position + 1 > Buffer.Count) { SetLength(Position + 1); }
                            Buffer[Position] = b;
                            Position += 1;
                        }
                        public void WriteBytes(Byte[] l)
                        {
                            var Size = l.Length;
                            if (Size == 0) { return; }
                            if (Position + Size > Buffer.Count) { SetLength(Position + Size); }
                            for (var k = 0; k < Size; k += 1)
                            {
                                Buffer[Position + k] = l[k];
                            }
                            Position += Size;
                        }

                        public int Length
                        {
                            get
                            {
                                return Buffer.Count;
                            }
                        }

                        public void SetLength(int Length)
                        {
                            if (Buffer.Count < Length)
                            {
                                var Diff = Length - Buffer.Count;
                                for (var k = 0; k < Diff; k += 1)
                                {
                                    Buffer.Add(0);
                                }
                            }
                            else
                            {
                                Buffer.RemoveRange(Length, Buffer.Count - Length);
                            }
                        }
                    }
        Template
            Name BinaryTranslator
            //Parameters: ${Serializers}
            Value
                $String
                    public sealed class BinaryTranslator
                    {
                        ${Serializers}
                    }
        Template
            Name BinaryTranslator_Primitive_Unit
            Value
                $String
                    public static Unit UnitFromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadUnit(s);
                    }
                    public static void UnitToBinary(IWritableStream s, Unit v)
                    {
                        WriteStream.WriteUnit(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Boolean
            Value
                $String
                    public static Boolean BooleanFromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadBoolean(s);
                    }
                    public static void BooleanToBinary(IWritableStream s, Boolean v)
                    {
                        WriteStream.WriteBoolean(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_String
            Value
                $String
                    public static String StringFromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadString(s);
                    }
                    public static void StringToBinary(IWritableStream s, String v)
                    {
                        WriteStream.WriteString(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int
            Value
                $String
                    public static Int IntFromBinary(IReadableStream s)
                    {
                        return (Int)(ReadStream.ReadInt32(s));
                    }
                    public static void IntToBinary(IWritableStream s, Int v)
                    {
                        WriteStream.WriteInt32(s, (Int32)(v));
                    }
        Template
            Name BinaryTranslator_Primitive_Real
            Value
                $String
                    public static Real RealFromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadFloat64(s);
                    }
                    public static void RealToBinary(IWritableStream s, Real v)
                    {
                        WriteStream.WriteFloat64(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Byte
            Value
                $String
                    public static Byte ByteFromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadByte(s);
                    }
                    public static void ByteToBinary(IWritableStream s, Byte v)
                    {
                        WriteStream.WriteByte(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt8
            Value
                $String
                    public static UInt8 UInt8FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadUInt8(s);
                    }
                    public static void UInt8ToBinary(IWritableStream s, UInt8 v)
                    {
                        WriteStream.WriteUInt8(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt16
            Value
                $String
                    public static UInt16 UInt16FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadUInt16(s);
                    }
                    public static void UInt16ToBinary(IWritableStream s, UInt16 v)
                    {
                        WriteStream.WriteUInt16(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt32
            Value
                $String
                    public static UInt32 UInt32FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadUInt32(s);
                    }
                    public static void UInt32ToBinary(IWritableStream s, UInt32 v)
                    {
                        WriteStream.WriteUInt32(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_UInt64
            Value
                $String
                    public static UInt64 UInt64FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadUInt64(s);
                    }
                    public static void UInt64ToBinary(IWritableStream s, UInt64 v)
                    {
                        WriteStream.WriteUInt64(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int8
            Value
                $String
                    public static Int8 Int8FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadInt8(s);
                    }
                    public static void Int8ToBinary(IWritableStream s, Int8 v)
                    {
                        WriteStream.WriteInt8(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int16
            Value
                $String
                    public static Int16 Int16FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadInt16(s);
                    }
                    public static void Int16ToBinary(IWritableStream s, Int16 v)
                    {
                        WriteStream.WriteInt16(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int32
            Value
                $String
                    public static Int32 Int32FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadInt32(s);
                    }
                    public static void Int32ToBinary(IWritableStream s, Int32 v)
                    {
                        WriteStream.WriteInt32(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Int64
            Value
                $String
                    public static Int64 Int64FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadInt64(s);
                    }
                    public static void Int64ToBinary(IWritableStream s, Int64 v)
                    {
                        WriteStream.WriteInt64(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Float32
            Value
                $String
                    public static Float32 Float32FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadFloat32(s);
                    }
                    public static void Float32ToBinary(IWritableStream s, Float32 v)
                    {
                        WriteStream.WriteFloat32(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Float64
            Value
                $String
                    public static Float64 Float64FromBinary(IReadableStream s)
                    {
                        return ReadStream.ReadFloat64(s);
                    }
                    public static void Float64ToBinary(IWritableStream s, Float64 v)
                    {
                        WriteStream.WriteFloat64(s, v);
                    }
        Template
            Name BinaryTranslator_Primitive_Type
            Value
                $String
                    public static Type TypeFromBinary(IReadableStream s)
                    {
                        throw new NotSupportedException();
                    }
                    public static void TypeToBinary(IWritableStream s, Type v)
                    {
                        throw new NotSupportedException();
                    }
        Template
            Name BinaryTranslator_Alias
            //Parameters: ${Name}, ${ValueTypeFriendlyName}
            Value
                $String
                    public static [[${Name}]] [[${Name}FromBinary]](IReadableStream s)
                    {
                        var o = new [[${Name}]]();
                        o.Value = [[${ValueTypeFriendlyName}FromBinary]](s);
                        return o;
                    }
                    public static void [[${Name}ToBinary]](IWritableStream s, [[${Name}]] o)
                    {
                        [[${ValueTypeFriendlyName}ToBinary]](s, o.Value);
                    }
        Template
            Name BinaryTranslator_Record
            //Parameters: ${Name}, ${FieldFroms}, ${FieldTos}
            Value
                $String
                    public static [[${Name}]] [[${Name}FromBinary]](IReadableStream s)
                    {
                        var o = new [[${Name}]]();
                        ${FieldFroms}
                        return o;
                    }
                    public static void [[${Name}ToBinary]](IWritableStream s, [[${Name}]] o)
                    {
                        ${FieldTos}
                    }
        Template
            Name BinaryTranslator_FieldFrom
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    o.[[${Name}]] = [[${TypeFriendlyName}FromBinary]](s);
        Template
            Name BinaryTranslator_FieldTo
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    [[${TypeFriendlyName}ToBinary]](s, o.[[${Name}]]);
        Template
            Name BinaryTranslator_TaggedUnion
            //Parameters: ${Name}, ${AlternativeFroms}, ${AlternativeTos}
            Value
                $String
                    public static [[${Name}]] [[${Name}FromBinary]](IReadableStream s)
                    {
                        var o = new [[${Name}]]();
                        o._Tag = [[${Name}TagFromBinary]](s);
                        ${AlternativeFroms}
                        throw new InvalidOperationException();
                    }
                    public static void [[${Name}ToBinary]](IWritableStream s, [[${Name}]] o)
                    {
                        [[${Name}TagToBinary]](s, o._Tag);
                        ${AlternativeTos}
                        throw new InvalidOperationException();
                    }
        Template
            Name BinaryTranslator_AlternativeFrom
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o._Tag == [[${TaggedUnionName}Tag.${Name}]])
                    {
                        o.[[${Name}]] = [[${TypeFriendlyName}FromBinary]](s);
                        return o;
                    }
        Template
            Name BinaryTranslator_AlternativeTo
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o._Tag == [[${TaggedUnionName}Tag.${Name}]])
                    {
                        [[${TypeFriendlyName}ToBinary]](s, o.[[${Name}]]);
                        return;
                    }
        Template
            Name BinaryTranslator_Enum
            //Parameters: ${Name}, ${UnderlyingTypeFriendlyName}, ${UnderlyingType}
            Value
                $String
                    public static [[${Name}]] [[${Name}FromBinary]](IReadableStream s)
                    {
                        return ([[${Name}]])([[${UnderlyingTypeFriendlyName}FromBinary]](s));
                    }
                    public static void [[${Name}ToBinary]](IWritableStream s, [[${Name}]] o)
                    {
                        [[${UnderlyingTypeFriendlyName}ToBinary]](s, (${UnderlyingType})(o));
                    }
        Template
            Name BinaryTranslator_Tuple
            //Parameters: ${TypeFriendlyName}, ${TupleElementFroms}, ${TupleElementTos}
            Value
                $String
                    public static [[${TypeFriendlyName}]] [[${TypeFriendlyName}FromBinary]](IReadableStream s)
                    {
                        var t = new [[${TypeFriendlyName}]]();
                        ${TupleElementFroms}
                        return t;
                    }
                    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, [[${TypeFriendlyName}]] t)
                    {
                        ${TupleElementTos}
                    }
        Template
            Name BinaryTranslator_TupleElementFrom
            //Parameters: ${NameIndex}, ${TypeFriendlyName}
            Value
                $String
                    t.[[Item${NameIndex}]] = [[${TypeFriendlyName}FromBinary]](s);
        Template
            Name BinaryTranslator_TupleElementTo
            //Parameters: ${NameIndex}, ${TypeFriendlyName}
            Value
                $String
                    [[${TypeFriendlyName}ToBinary]](s, t.[[Item${NameIndex}]]);
        Template
            Name BinaryTranslator_List
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${ElementTypeFriendlyName}
            Value
                $String
                    public static [[${TypeString}]] [[${TypeFriendlyName}FromBinary]](IReadableStream s)
                    {
                        var l = new [[${TypeString}]]();
                        int Length = (int)(IntFromBinary(s));
                        for (int k = 0; k < Length; k += 1)
                        {
                            l.Add([[${ElementTypeFriendlyName}FromBinary]](s));
                        }
                        return l;
                    }
                    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, [[${TypeString}]] l)
                    {
                        int Length = l.Count;
                        IntToBinary(s, (Int)(Length));
                        for (int k = 0; k < Length; k += 1)
                        {
                            [[${ElementTypeFriendlyName}ToBinary]](s, l[k]);
                        }
                    }
        Template
            Name BinaryTranslator_Set
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${ElementTypeFriendlyName}
            Value
                $String
                    public static [[${TypeString}]] [[${TypeFriendlyName}FromBinary]](IReadableStream s)
                    {
                        var l = new [[${TypeString}]]();
                        int Length = (int)(IntFromBinary(s));
                        for (int k = 0; k < Length; k += 1)
                        {
                            l.Add([[${ElementTypeFriendlyName}FromBinary]](s));
                        }
                        return l;
                    }
                    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, [[${TypeString}]] l)
                    {
                        int Length = l.Count;
                        IntToBinary(s, (Int)(Length));
                        foreach (var e in l)
                        {
                            [[${ElementTypeFriendlyName}ToBinary]](s, e);
                        }
                    }
        Template
            Name BinaryTranslator_Map
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${KeyTypeFriendlyName}, ${ValueTypeFriendlyName}
            Value
                $String
                    public static [[${TypeString}]] [[${TypeFriendlyName}FromBinary]](IReadableStream s)
                    {
                        var l = new [[${TypeString}]]();
                        int Length = (Int)(IntFromBinary(s));
                        for (int k = 0; k < Length; k += 1)
                        {
                            var Key = [[${KeyTypeFriendlyName}FromBinary]](s);
                            l.Add(Key, [[${ValueTypeFriendlyName}FromBinary]](s));
                        }
                        return l;
                    }
                    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, [[${TypeString}]] l)
                    {
                        int Length = l.Count;
                        IntToBinary(s, (Int)(Length));
                        foreach (var p in l)
                        {
                            [[${KeyTypeFriendlyName}ToBinary]](s, p.Key);
                            [[${ValueTypeFriendlyName}ToBinary]](s, p.Value);
                        }
                    }
        Template
            Name BinaryTranslator_Optional
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${AlternativeFroms}, ${AlternativeTos}
            Value
                $String
                    public static [[${TypeString}]] [[${TypeFriendlyName}FromBinary]](IReadableStream s)
                    {
                        var o = new [[${TypeString}]]();
                        o._Tag = OptionalTagFromBinary(s);
                        ${AlternativeFroms}
                        throw new InvalidOperationException();
                    }
                    public static void [[${TypeFriendlyName}ToBinary]](IWritableStream s, [[${TypeString}]] o)
                    {
                        OptionalTagToBinary(s, o._Tag);
                        ${AlternativeTos}
                        throw new InvalidOperationException();
                    }
