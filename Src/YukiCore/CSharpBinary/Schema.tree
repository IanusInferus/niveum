$Comment
    ==========================================================================

      File:        Schema.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C#二进制通讯模板数据
      Version:     2012.12.17.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name MainWithNamespace
            //Parameters: ${Header}, ${NamespaceName}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    namespace [[${NamespaceName}]]
                    {
                        ${ComplexTypes}
                    }

                $End
        Template
            Name MainWithoutNamespace
            //Parameters: ${Header}, ${Imports}, ${Primitives}, ${ComplexTypes}
            Value
                $String
                    ${Header}
                    using ${Imports};
                    ${Primitives}

                    ${ComplexTypes}

                $End
        Template
            Name Header
            //Parameters:
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    //Reference:

                    using System;
                    using System.Collections.Generic;
                    using System.Threading;
                    using Firefly;
                    using Firefly.Streaming;
                    using Firefly.Mapping;
                    using Firefly.Mapping.Binary;
                    using Firefly.TextEncoding;
        Template
            Name BinarySerializationServer
            //Parameters: ${Hash}, ${ClientCommands}, ${ServerCommands}
            Value
                $String
                    public sealed class BinarySerializationServer
                    {
                        private Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, Byte[], Byte[]>> ClientCommands;

                        public BinarySerializationServer()
                        {
                            ClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, Byte[], Byte[]>>();
                            ${ClientCommands}
                        }

                        public UInt64 Hash
                        {
                            get
                            {
                                return 0x${Hash};
                            }
                        }

                        public Boolean HasCommand(String CommandName, UInt32 CommandHash)
                        {
                            return ClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
                        }

                        public Byte[] ExecuteCommand(IApplicationServer s, String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            var cmd = ClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
                            return cmd(s, Parameters);
                        }
                    }
                    public sealed class BinarySerializationServerEventDispatcher
                    {
                        public BinarySerializationServerEventDispatcher(IApplicationServer s)
                        {
                            ${ServerCommands}
                        }

                        public delegate void ServerEventDelegate(String CommandName, UInt32 CommandHash, Byte[] Parameters);
                        public event ServerEventDelegate ServerEvent;
                        private void OnServerEvent(String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            if (ServerEvent != null) { ServerEvent(CommandName, CommandHash, Parameters); }
                        }
                    }
        Template
            Name BinarySerializationServer_ClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ClientCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), (s, p) => BinaryTranslator.Serialize(s.[[${Name}]](BinaryTranslator.Deserialize<[[${Name}Request]]>(p))));
        Template
            Name BinarySerializationServer_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    s.${Name} += e => OnServerEvent(@"${CommandName}", 0x${CommandHash}, BinaryTranslator.Serialize(e));
        Template
            Name IBinarySender
            Value
                $String
                    public interface IBinarySender
                    {
                        void Send(String CommandName, UInt32 CommandHash, Byte[] Parameters);
                    }
        Template
            Name BinarySerializationClient
            //Parameters: ${Hash}, ${ApplicationCommands}, ${ServerCommands}
            Value
                $String
                    public sealed class BinarySerializationClient
                    {
                        public IApplicationClient GetApplicationClient()
                        {
                            return c;
                        }

                        private class ApplicationClient : IApplicationClient
                        {
                            public IBinarySender s;
                            public Dictionary<String, Queue<KeyValuePair<UInt32, Action<Byte[]>>>> ClientCommandCallbacks;

                            public UInt64 Hash
                            {
                                get
                                {
                                    return 0x${Hash};
                                }
                            }

                            public void DequeueCallback(String CommandName)
                            {
                                ClientCommandCallbacks[CommandName].Dequeue();
                            }

                            private void AddCallback(String CommandName, UInt32 CommandHash, Action<Byte[]> Callback)
                            {
                                if (ClientCommandCallbacks.ContainsKey(CommandName))
                                {
                                    ClientCommandCallbacks[CommandName].Enqueue(new KeyValuePair<UInt32, Action<Byte[]>>(CommandHash, Callback));
                                }
                                else
                                {
                                    var q = new Queue<KeyValuePair<UInt32, Action<Byte[]>>>();
                                    q.Enqueue(new KeyValuePair<UInt32, Action<Byte[]>>(CommandHash, Callback));
                                    ClientCommandCallbacks.Add(CommandName, q);
                                }
                            }

                            ${ApplicationCommands}
                        }

                        private ApplicationClient c;
                        private Dictionary<KeyValuePair<String, UInt32>, Action<Byte[]>> ServerCommands;

                        public BinarySerializationClient(IBinarySender s)
                        {
                            c = new ApplicationClient();
                            c.s = s;
                            c.ClientCommandCallbacks = new Dictionary<String, Queue<KeyValuePair<UInt32, Action<Byte[]>>>>();
                            ServerCommands = new Dictionary<KeyValuePair<String, UInt32>, Action<Byte[]>>();
                            ${ServerCommands}
                        }

                        public void HandleResult(String CommandName, UInt32 CommandHash, Byte[] Parameters)
                        {
                            if (c.ClientCommandCallbacks.ContainsKey(CommandName))
                            {
                                var q = c.ClientCommandCallbacks[CommandName];
                                if (q.Count == 0)
                                {
                                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                                }
                                var CallbackPair = q.Peek();
                                if (CallbackPair.Key != CommandHash)
                                {
                                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                                }
                                q.Dequeue();
                                var Callback = CallbackPair.Value;
                                Callback(Parameters);
                                return;
                            }

                            var p = new KeyValuePair<String, UInt32>(CommandName, CommandHash);
                            if (ServerCommands.ContainsKey(p))
                            {
                                var a = ServerCommands[p];
                                a(Parameters);
                                return;
                            }

                            throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                        }
                    }
        Template
            Name BinarySerializationClient_ApplicationClientCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    public void [[${Name}]]([[${Name}Request]] r, Action<[[${Name}Reply]]> Callback)
                    {
                        var Request = BinaryTranslator.Serialize(r);
                        AddCallback(@"${CommandName}", 0x${CommandHash}, Parameters => Callback(BinaryTranslator.Deserialize<[[${Name}Reply]]>(Parameters)));
                        s.Send(@"${CommandName}", 0x${CommandHash}, Request);
                    }
        Template
            Name BinarySerializationClient_ApplicationServerCommand
            //Parameters: ${Name}
            Value
                $String
                    public event Action<[[${Name}Event]]> [[${Name}]];
                    public void [[Raise${Name}]]([[${Name}Event]] e) { if ([[${Name}]] != null) { [[${Name}]](e); } }
        Template
            Name BinarySerializationClient_ServerCommand
            //Parameters: ${CommandName}, ${Name}, ${CommandHash}
            Value
                $String
                    ServerCommands.Add(new KeyValuePair<String, UInt32>(@"${CommandName}", 0x${CommandHash}), Parameters => c.[[Raise${Name}]](BinaryTranslator.Deserialize<[[${Name}Event]]>(Parameters)));
        Template
            Name BinaryTranslator
            //Parameters: ${Serializers}
            Value
                $String
                    public static class BinaryTranslator
                    {
                        private static ThreadLocal<BinarySerializer> bs = new ThreadLocal<BinarySerializer>
                        (
                            () =>
                            {
                                var s = new BinarySerializer();
                                var st = new StringTranslator();
                                s.PutReaderTranslator(st);
                                s.PutWriterTranslator(st);
                                s.PutCounterTranslator(st);
                                return s;
                            }
                        );

                        public static Byte[] Serialize<T>(T Value)
                        {
                            using (var s = Streams.CreateMemoryStream())
                            {
                                bs.Value.Write<T>(Value, s);
                                s.Position = 0;
                                return s.Read((int)(s.Length));
                            }
                        }
                        public static T Deserialize<T>(Byte[] Bytes)
                        {
                            using (var s = new ByteArrayStream(Bytes))
                            {
                                return bs.Value.Read<T>(s);
                            }
                        }

                        private class StringTranslator : IProjectorToProjectorDomainTranslator<String, Byte[]>, IProjectorToProjectorRangeTranslator<String, Byte[]>
                        {
                            public Func<String, R> TranslateProjectorToProjectorDomain<R>(Func<Byte[], R> Projector)
                            {
                                return s => Projector(TextEncoding.UTF16.GetBytes(s));
                            }

                            public Func<D, String> TranslateProjectorToProjectorRange<D>(Func<D, Byte[]> Projector)
                            {
                                return k => TextEncoding.UTF16.GetString(Projector(k));
                            }
                        }
                    }
