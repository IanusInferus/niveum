$Comment
    ==========================================================================

      File:        CSharpJson.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C# JSON通讯模板
      Version:     2016.10.05.
      Copyright(C) F.R.C.

    ==========================================================================

#Option
    EnableEmbeddedExpr True

#Namespace Yuki.ObjectSchema.CSharpJson

#Import
    System
    System.Collections.Generic
    System.Linq
    Firefly

#Template JsonSerializationServer Hash:UInt64 Commands:List<TypeDef> SchemaClosureGenerator:ISchemaClosureGenerator
    public sealed class JsonSerializationServer
    {
        private Dictionary<String, Func<IApplicationServer, String, String>> ClientCommandsWithoutHash;
        private Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, String, String>> ClientCommands;
        private Dictionary<String, Action<IApplicationServer, String, Action<String>, Action<Exception>>> AsyncClientCommandsWithoutHash;
        private Dictionary<KeyValuePair<String, UInt32>, Action<IApplicationServer, String, Action<String>, Action<Exception>>> AsyncClientCommands;

        private class KeyValuePairEqualityComparer<TKey, TValue> : IEqualityComparer<KeyValuePair<TKey, TValue>>
        {
            public Boolean Equals(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y)
            {
                if (!x.Key.Equals(y.Key)) { return false; }
                if (!x.Value.Equals(y.Value)) { return false; }
                return true;
            }

            public int GetHashCode(KeyValuePair<TKey, TValue> obj)
            {
                var KeyHash = obj.Key.GetHashCode();
                var ValueHash = obj.Value.GetHashCode();
                return KeyHash ^ ((ValueHash << 9) | ((ValueHash >> (32 - 9)) & ((1 << 9) - 1)));
            }
        }

        public JsonSerializationServer()
        {
            ClientCommandsWithoutHash = new Dictionary<String, Func<IApplicationServer, String, String>>(StringComparer.OrdinalIgnoreCase);
            ClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Func<IApplicationServer, String, String>>(new KeyValuePairEqualityComparer<String, UInt32>());
            AsyncClientCommandsWithoutHash = new Dictionary<String, Action<IApplicationServer, String, Action<String>, Action<Exception>>>(StringComparer.OrdinalIgnoreCase);
            AsyncClientCommands = new Dictionary<KeyValuePair<String, UInt32>, Action<IApplicationServer, String, Action<String>, Action<Exception>>>(new KeyValuePairEqualityComparer<String, UInt32>());
            $$
                foreach (var c in Commands)
                {
                    if (c.OnClientCommand)
                    {
                        var CommandName = c.ClientCommand.Name;
                        var Name = c.ClientCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        if (c.ClientCommand.Version == "")
                        {
                            if (c.ClientCommand.Attributes.Any(a => a.Key == "Async"))
                            {
                                ##
                                    AsyncClientCommandsWithoutHash.Add(${GetEscapedStringLiteral(CommandName)}, (s, p, Callback, OnFailure) => s.[[${Name}]](JsonTranslator.[[${Name}RequestFromJson]](JToken.Parse(p)), Reply => Callback(JsonTranslator.[[${Name}ReplyToJson]](Reply).ToString(Formatting.None)), OnFailure));
                            }
                            else
                            {
                                ##
                                    ClientCommandsWithoutHash.Add(${GetEscapedStringLiteral(CommandName)}, (s, p) => JsonTranslator.[[${Name}ReplyToJson]](s.[[${Name}]](JsonTranslator.[[${Name}RequestFromJson]](JToken.Parse(p)))).ToString(Formatting.None));
                            }
                        }
                        if (c.ClientCommand.Attributes.Any(a => a.Key == "Async"))
                        {
                            ##
                                AsyncClientCommands.Add(new KeyValuePair<String, UInt32>(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}), (s, p, Callback, OnFailure) => s.[[${Name}]](JsonTranslator.[[${Name}RequestFromJson]](JToken.Parse(p)), Reply => Callback(JsonTranslator.[[${Name}ReplyToJson]](Reply).ToString(Formatting.None)), OnFailure));
                        }
                        else
                        {
                            ##
                                ClientCommands.Add(new KeyValuePair<String, UInt32>(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}), (s, p) => JsonTranslator.[[${Name}ReplyToJson]](s.[[${Name}]](JsonTranslator.[[${Name}RequestFromJson]](JToken.Parse(p)))).ToString(Formatting.None));
                        }
                    }
                }
        }

        public UInt64 Hash
        {
            get
            {
                return 0x${Hash.ToString("X16", System.Globalization.CultureInfo.InvariantCulture)};
            }
        }

        public Boolean HasCommand(String CommandName)
        {
            return ClientCommandsWithoutHash.ContainsKey(CommandName);
        }
        public Boolean HasCommandAsync(String CommandName)
        {
            return AsyncClientCommandsWithoutHash.ContainsKey(CommandName);
        }

        public Boolean HasCommand(String CommandName, UInt32 CommandHash)
        {
            return ClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
        }
        public Boolean HasCommandAsync(String CommandName, UInt32 CommandHash)
        {
            return AsyncClientCommands.ContainsKey(new KeyValuePair<String, UInt32>(CommandName, CommandHash));
        }

        public String ExecuteCommand(IApplicationServer s, String CommandName, String Parameters)
        {
            var cmd = ClientCommandsWithoutHash[CommandName];
            return cmd(s, Parameters);
        }
        public void ExecuteCommandAsync(IApplicationServer s, String CommandName, String Parameters, Action<String> Callback, Action<Exception> OnFailure)
        {
            var cmd = AsyncClientCommandsWithoutHash[CommandName];
            cmd(s, Parameters, Callback, OnFailure);
        }

        public String ExecuteCommand(IApplicationServer s, String CommandName, UInt32 CommandHash, String Parameters)
        {
            var cmd = ClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
            return cmd(s, Parameters);
        }
        public void ExecuteCommandAsync(IApplicationServer s, String CommandName, UInt32 CommandHash, String Parameters, Action<String> Callback, Action<Exception> OnFailure)
        {
            var cmd = AsyncClientCommands[new KeyValuePair<String, UInt32>(CommandName, CommandHash)];
            cmd(s, Parameters, Callback, OnFailure);
        }
    }
    public sealed class JsonSerializationServerEventDispatcher
    {
        public JsonSerializationServerEventDispatcher(IApplicationServer s)
        {
            $$
                foreach (var c in Commands)
                {
                    if (c.OnServerCommand)
                    {
                        var CommandName = c.ServerCommand.Name;
                        var Name = c.ServerCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            s.${Name} += e => OnServerEvent(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}, JsonTranslator.[[${Name}EventToJson]](e).ToString(Formatting.None));
                    }
                }
        }

        public delegate void ServerEventDelegate(String CommandName, UInt32 CommandHash, String Parameters);
        public event ServerEventDelegate ServerEvent;
        private void OnServerEvent(String CommandName, UInt32 CommandHash, String Parameters)
        {
            if (ServerEvent != null) { ServerEvent(CommandName, CommandHash, Parameters); }
        }
    }

#Template IJsonSender
    public interface IJsonSender
    {
        void Send(String CommandName, UInt32 CommandHash, String Parameters);
    }

#Template JsonSerializationClient Hash:UInt64 Commands:List<TypeDef> SchemaClosureGenerator:ISchemaClosureGenerator
    public sealed class JsonSerializationClient
    {
        private class KeyValuePairEqualityComparer<TKey, TValue> : IEqualityComparer<KeyValuePair<TKey, TValue>>
        {
            public Boolean Equals(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y)
            {
                if (!x.Key.Equals(y.Key)) { return false; }
                if (!x.Value.Equals(y.Value)) { return false; }
                return true;
            }

            public int GetHashCode(KeyValuePair<TKey, TValue> obj)
            {
                var KeyHash = obj.Key.GetHashCode();
                var ValueHash = obj.Value.GetHashCode();
                return KeyHash ^ ((ValueHash << 9) | ((ValueHash >> (32 - 9)) & ((1 << 9) - 1)));
            }
        }

        private class ApplicationClient : IApplicationClient
        {
            public IJsonSender s;
            public Dictionary<String, Queue<KeyValuePair<UInt32, Action<String>>>> ClientCommandCallbacks;

            public UInt64 Hash
            {
                get
                {
                    return 0x${Hash.ToString("X16", System.Globalization.CultureInfo.InvariantCulture)};
                }
            }

            public void DequeueCallback(String CommandName)
            {
                ClientCommandCallbacks[CommandName].Dequeue();
            }

            private void AddCallback(String CommandName, UInt32 CommandHash, Action<String> Callback)
            {
                if (ClientCommandCallbacks.ContainsKey(CommandName))
                {
                    ClientCommandCallbacks[CommandName].Enqueue(new KeyValuePair<UInt32, Action<String>>(CommandHash, Callback));
                }
                else
                {
                    var q = new Queue<KeyValuePair<UInt32, Action<String>>>();
                    q.Enqueue(new KeyValuePair<UInt32, Action<String>>(CommandHash, Callback));
                    ClientCommandCallbacks.Add(CommandName, q);
                }
            }

            $$
                foreach (var c in Commands)
                {
                    if (c.OnClientCommand)
                    {
                        var CommandName = c.ClientCommand.Name;
                        var Name = c.ClientCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            public void [[${Name}]]([[${Name}Request]] r, Action<[[${Name}Reply]]> Callback)
                            {
                                var Request = JsonTranslator.[[${Name}RequestToJson]](r).ToString(Formatting.None);
                                AddCallback(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}, Parameters => Callback(JsonTranslator.[[${Name}ReplyFromJson]](JToken.Parse(Parameters))));
                                s.Send(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}, Request);
                            }
                    }
                    else if (c.OnServerCommand)
                    {
                        var Name = c.ServerCommand.TypeFriendlyName();
                        ##
                            public event Action<[[${Name}Event]]> [[${Name}]];
                            public void [[Raise${Name}]]([[${Name}Event]] e) { if ([[${Name}]] != null) { [[${Name}]](e); } }
                    }
                }
        }

        private ApplicationClient c;
        private Dictionary<KeyValuePair<String, UInt32>, Action<String>> ServerCommands;

        public JsonSerializationClient(IJsonSender s)
        {
            c = new ApplicationClient();
            c.s = s;
            c.ClientCommandCallbacks = new Dictionary<String, Queue<KeyValuePair<UInt32, Action<String>>>>();
            ServerCommands = new Dictionary<KeyValuePair<String, UInt32>, Action<String>>(new KeyValuePairEqualityComparer<String, UInt32>());
            $$
                foreach (var c in Commands)
                {
                    if (c.OnServerCommand)
                    {
                        var CommandName = c.ServerCommand.Name;
                        var Name = c.ServerCommand.TypeFriendlyName();
                        var CommandHash = ((UInt32)(SchemaClosureGenerator.GetSubSchema(new List<TypeDef> { c }, new List<TypeSpec> { }).GetNonversioned().Hash().Bits(31, 0))).ToString("X8", System.Globalization.CultureInfo.InvariantCulture);
                        ##
                            ServerCommands.Add(new KeyValuePair<String, UInt32>(${GetEscapedStringLiteral(CommandName)}, 0x${CommandHash}), Parameters => c.[[Raise${Name}]](JsonTranslator.[[${Name}EventFromJson]](JToken.Parse(Parameters))));
                    }
                }
        }

        public IApplicationClient GetApplicationClient()
        {
            return c;
        }

        public void HandleResult(String CommandName, UInt32 CommandHash, String Parameters)
        {
            if (c.ClientCommandCallbacks.ContainsKey(CommandName))
            {
                var q = c.ClientCommandCallbacks[CommandName];
                if (q.Count == 0)
                {
                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                }
                var CallbackPair = q.Peek();
                if (CallbackPair.Key != CommandHash)
                {
                    throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
                }
                q.Dequeue();
                var Callback = CallbackPair.Value;
                Callback(Parameters);
                return;
            }

            var p = new KeyValuePair<String, UInt32>(CommandName, CommandHash);
            if (ServerCommands.ContainsKey(p))
            {
                var a = ServerCommands[p];
                a(Parameters);
                return;
            }

            throw new InvalidOperationException(CommandName + "@" + CommandHash.ToString("X8", System.Globalization.CultureInfo.InvariantCulture));
        }
    }

#Template JsonLogAspectWrapper Commands:List<TypeDef>
    public sealed class JsonLogAspectWrapper : IApplicationServer
    {
        private IApplicationServer Inner;

        public JsonLogAspectWrapper(IApplicationServer Inner)
        {
            this.Inner = Inner;
            $$
                foreach (var c in Commands.Where(c => c.OnServerCommand))
                {
                    var Name = c.TypeFriendlyName();
                    ##
                        Inner.[[${Name}]] += e =>
                        {
                            if (ServerCommand != null) { ServerCommand(${GetEscapedStringLiteral(Name)}, JsonTranslator.[[${Name}EventToJson]](e).ToString(Formatting.None)); }
                            if ([[${Name}]] != null) { [[${Name}]](e); }
                        };
                }
        }

        public event Action<String, String> ClientCommandIn;
        public event Action<String, String> ClientCommandOut;
        public event Action<String, String> ServerCommand;

        $$
            foreach (var c in Commands)
            {
                if (c.OnClientCommand)
                {
                    var Name = c.ClientCommand.TypeFriendlyName();
                    if (c.ClientCommand.Attributes.Any(a => a.Key == "Async"))
                    {
                        ##
                            public void [[${Name}]]([[${Name}Request]] Request, Action<[[${Name}Reply]]> Callback, Action<Exception> OnFailure)
                            {
                                if (ClientCommandIn != null) { ClientCommandIn(${GetEscapedStringLiteral(Name)}, JsonTranslator.[[${Name}RequestToJson]](Request).ToString(Formatting.None)); }
                                Action<[[${Name}Reply]]> CallbackInner = Reply =>
                                {
                                    if (ClientCommandOut != null) { ClientCommandOut(${GetEscapedStringLiteral(Name)}, JsonTranslator.[[${Name}ReplyToJson]](Reply).ToString(Formatting.None)); }
                                    Callback(Reply);
                                };
                                Inner.[[${Name}]](Request, CallbackInner, OnFailure);
                            }
                    }
                    else
                    {
                        ##
                            public [[${Name}Reply]] [[${Name}]]([[${Name}Request]] Request)
                            {
                                if (ClientCommandIn != null) { ClientCommandIn(${GetEscapedStringLiteral(Name)}, JsonTranslator.[[${Name}RequestToJson]](Request).ToString(Formatting.None)); }
                                var Reply = Inner.[[${Name}]](Request);
                                if (ClientCommandOut != null) { ClientCommandOut(${GetEscapedStringLiteral(Name)}, JsonTranslator.[[${Name}ReplyToJson]](Reply).ToString(Formatting.None)); }
                                return Reply;
                            }
                    }
                }
                else if (c.OnServerCommand)
                {
                    var Name = c.ServerCommand.TypeFriendlyName();
                    ##
                        public event Action<[[${Name}Event]]> [[${Name}]];
                }
            }
    }

#Template JsonTranslator Schema:Schema
    public static class JsonTranslator
    {
        ${GetJsonTranslatorSerializers(Schema)}
    }

#Template JsonTranslator_Primitive_Unit
    public static Unit UnitFromJson(JToken j)
    {
        return new Unit();
    }
    public static JObject UnitToJson(Unit v)
    {
        return new JObject();
    }

#Template JsonTranslator_Primitive_Boolean
    public static Boolean BooleanFromJson(JToken j)
    {
        if ((j.Type != JTokenType.Boolean) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToBoolean(jv.Value);
    }
    public static JValue BooleanToJson(Boolean v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_String
    public static String StringFromJson(JToken j)
    {
        if (j.Type != JTokenType.String) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToString(jv.Value);
    }
    public static JValue StringToJson(String v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int
    public static Int IntFromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt32(jv.Value);
    }
    public static JValue IntToJson(Int v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Real
    public static Real RealFromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.Float) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToDouble(jv.Value);
    }
    public static JValue RealToJson(Real v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Byte
    public static Byte ByteFromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToByte(jv.Value);
    }
    public static JValue ByteToJson(Byte v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt8
    public static UInt8 UInt8FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToByte(jv.Value);
    }
    public static JValue UInt8ToJson(UInt8 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt16
    public static UInt16 UInt16FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToUInt16(jv.Value);
    }
    public static JValue UInt16ToJson(UInt16 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt32
    public static UInt32 UInt32FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToUInt32(jv.Value);
    }
    public static JValue UInt32ToJson(UInt32 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_UInt64
    public static UInt64 UInt64FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToUInt64(jv.Value);
    }
    public static JValue UInt64ToJson(UInt64 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int8
    public static Int8 Int8FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToSByte(jv.Value);
    }
    public static JValue Int8ToJson(Int8 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int16
    public static Int16 Int16FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt16(jv.Value);
    }
    public static JValue Int16ToJson(Int16 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int32
    public static Int32 Int32FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt32(jv.Value);
    }
    public static JValue Int32ToJson(Int32 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Int64
    public static Int64 Int64FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToInt64(jv.Value);
    }
    public static JValue Int64ToJson(Int64 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Float32
    public static Float32 Float32FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.Float) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToSingle(jv.Value);
    }
    public static JValue Float32ToJson(Float32 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Float64
    public static Float64 Float64FromJson(JToken j)
    {
        if ((j.Type != JTokenType.Integer) && (j.Type != JTokenType.Float) && (j.Type != JTokenType.String)) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return Convert.ToDouble(jv.Value);
    }
    public static JValue Float64ToJson(Float64 v)
    {
        return new JValue(v);
    }

#Template JsonTranslator_Primitive_Type
    public static Type TypeFromJson(JToken j)
    {
        throw new NotSupportedException();
    }
    public static JValue TypeToJson(Type v)
    {
        throw new NotSupportedException();
    }

#Template JsonTranslator_Alias a:AliasDef
    $$
        var Name = a.TypeFriendlyName();
        var ValueTypeFriendlyName = a.Type.TypeFriendlyName();
    public static [[${Name}]] [[${Name}FromJson]](JToken j)
    {
        return new [[${Name}]] { Value = [[${ValueTypeFriendlyName}FromJson]](j) };
    }
    public static JToken [[${Name}ToJson]]([[${Name}]] o)
    {
        return [[${ValueTypeFriendlyName}ToJson]](o.Value);
    }

#Template JsonTranslator_Record r:RecordDef
    ${JsonTranslator_Record(r.TypeFriendlyName(), r.Fields)}

#Template JsonTranslator_Record Name:String Fields:List<VariableDef>
    public static [[${Name}]] [[${Name}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Object) { throw new InvalidOperationException(); }
        var jo = j as JObject;
        if (jo == null) { throw new InvalidOperationException(); }
        var o = new [[${Name}]]();
        $$
            foreach (var a in Fields)
            {
                ##
                    o.[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromJson]](jo[${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}]);
            }
        return o;
    }
    public static JObject [[${Name}ToJson]]([[${Name}]] o)
    {
        var jo = new JObject();
        $$
            foreach (var a in Fields)
            {
                ##
                    jo.Add(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${a.Type.TypeFriendlyName()}ToJson]](o.[[${a.Name}]]));
            }
        return jo;
    }

#Template JsonTranslator_TaggedUnion tu:TaggedUnionDef
    ${JsonTranslator_TaggedUnion(tu.TypeFriendlyName(), tu.Alternatives)}

#Template JsonTranslator_TaggedUnion Name:String Alternatives:List<VariableDef>
    ${JsonTranslator_Enum(Name + "Tag")}
    public static [[${Name}]] [[${Name}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Object) { throw new InvalidOperationException(); }
        var jo = j as JObject;
        if (jo == null) { throw new InvalidOperationException(); }
        var o = new [[${Name}]]();
        var d = (IDictionary<string, JToken>)(jo);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (d.ContainsKey(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}))
                    {
                        o._Tag = [[${Name}Tag.${a.Name}]];
                        o.[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromJson]](jo[${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}]);
                        return o;
                    }
            }
        throw new InvalidOperationException();
    }
    public static JObject [[${Name}ToJson]]([[${Name}]] o)
    {
        var jo = new JObject();
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag.${a.Name}]])
                    {
                        jo.Add(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${a.Type.TypeFriendlyName()}ToJson]](o.[[${a.Name}]]));
                        return jo;
                    }
            }
        throw new InvalidOperationException();
    }

#Template JsonTranslator_Enum e:EnumDef
    ${JsonTranslator_Enum(e.TypeFriendlyName())}

#Template JsonTranslator_Enum Name:String
    public static [[${Name}]] [[${Name}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Integer) { throw new InvalidOperationException(); }
        var jv = j as JValue;
        return ([[${Name}]])(Convert.ToInt64(jv.Value));
    }
    public static JValue [[${Name}ToJson]]([[${Name}]] o)
    {
        return new JValue(Convert.ToInt64(o));
    }

#Template JsonTranslator_ClientCommand c:ClientCommandDef
    ${JsonTranslator_Record(c.TypeFriendlyName() + "Request", c.OutParameters)}
    ${JsonTranslator_TaggedUnion(c.TypeFriendlyName() + "Reply", c.InParameters)}

#Template JsonTranslator_ServerCommand c:ServerCommandDef
    ${JsonTranslator_Record(c.TypeFriendlyName() + "Event", c.OutParameters)}

#Template JsonTranslator_Tuple tp:TypeSpec
    $$
        var TypeFriendlyName = tp.TypeFriendlyName();
        var TypeString = GetTypeString(tp);
    public static [[${TypeString}]] [[${TypeFriendlyName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        $$
            var ItemNames = new List<String>{};
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        var [[Item${k + 1}]] = [[${t.TypeFriendlyName()}FromJson]](ja[${k}]);
                    ItemNames.Add("Item" + (k + 1).ToString(System.Globalization.CultureInfo.InvariantCulture));
                    k += 1;
                }
            }
        return Tuple.Create(${String.Join(", ", ItemNames)});
    }
    public static JArray [[${TypeFriendlyName}ToJson]]([[${TypeString}]] t)
    {
        var ja = new JArray();
        $$
            {
                int k = 0;
                foreach (var t in tp.Tuple)
                {
                    ##
                        ja.Add([[${t.TypeFriendlyName()}ToJson]](t.[[Item${k + 1}]]));
                    k += 1;
                }
            }
        return ja;
    }

#Template JsonTranslator_Optional o:TypeSpec GenericOptionalType:TaggedUnionDef
    $$
        var ElementType = o.GenericTypeSpec.ParameterValues.Single();
        var Alternatives = GenericOptionalType.Alternatives.Select(a => new VariableDef { Name = a.Name, Type = a.Type.OnGenericParameterRef ? ElementType : a.Type, Attributes = a.Attributes, Description = a.Description }).ToList();
        var TypeFriendlyName = o.TypeFriendlyName();
        var TypeString = GetTypeString(o);
        var Name = "Optional";
    public static [[${TypeString}]] [[${TypeFriendlyName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Object) { throw new InvalidOperationException(); }
        var jo = j as JObject;
        if (jo == null) { throw new InvalidOperationException(); }
        var o = new [[${TypeString}]]();
        var d = (IDictionary<string, JToken>)(jo);
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (d.ContainsKey(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}))
                    {
                        o._Tag = [[${Name}Tag.${a.Name}]];
                        o.[[${a.Name}]] = [[${a.Type.TypeFriendlyName()}FromJson]](jo[${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}]);
                        return o;
                    }
            }
        throw new InvalidOperationException();
    }
    public static JObject [[${TypeFriendlyName}ToJson]]([[${TypeString}]] o)
    {
        var jo = new JObject();
        $$
            foreach (var a in Alternatives)
            {
                ##
                    if (o._Tag == [[${Name}Tag.${a.Name}]])
                    {
                        jo.Add(${GetEscapedStringLiteral(LowercaseCamelize(a.Name))}, [[${a.Type.TypeFriendlyName()}ToJson]](o.[[${a.Name}]]));
                        return jo;
                    }
            }
        throw new InvalidOperationException();
    }

#Template JsonTranslator_List l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
    public static [[${TypeString}]] [[${TypeFriendlyName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        var a = new [[${TypeString}]]();
        foreach (var e in ja.Children())
        {
            a.Add([[${ElementTypeFriendlyName}FromJson]](e));
        }
        return a;
    }
    public static JArray [[${TypeFriendlyName}ToJson]]([[${TypeString}]] c)
    {
        var ja = new JArray();
        foreach (var e in c)
        {
            ja.Add([[${ElementTypeFriendlyName}ToJson]](e));
        }
        return ja;
    }

#Template JsonTranslator_Set l:TypeSpec
    $$
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var ElementTypeFriendlyName = l.GenericTypeSpec.ParameterValues.Single().TypeFriendlyName();
    public static [[${TypeString}]] [[${TypeFriendlyName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        var a = new [[${TypeString}]]();
        foreach (var e in ja.Children())
        {
            a.Add([[${ElementTypeFriendlyName}FromJson]](e));
        }
        return a;
    }
    public static JArray [[${TypeFriendlyName}ToJson]]([[${TypeString}]] c)
    {
        var ja = new JArray();
        foreach (var e in c)
        {
            ja.Add([[${ElementTypeFriendlyName}ToJson]](e));
        }
        return ja;
    }

#Template JsonTranslator_Map l:TypeSpec
    $$
        var gp = l.GenericTypeSpec.ParameterValues;
        if (gp.Count != 2)
        {
            throw new ArgumentException();
        }
        var TypeFriendlyName = l.TypeFriendlyName();
        var TypeString = GetTypeString(l);
        var KeyTypeFriendlyName = gp[0].TypeFriendlyName();
        var ValueTypeFriendlyName = gp[1].TypeFriendlyName();
    public static [[${TypeString}]] [[${TypeFriendlyName}FromJson]](JToken j)
    {
        if (j.Type != JTokenType.Array) { throw new InvalidOperationException(); }
        var ja = j as JArray;
        var a = new [[${TypeString}]]();
        foreach (var e in ja.Children())
        {
            var Key = [[${KeyTypeFriendlyName}FromJson]](e["key"]);
            var Value = [[${ValueTypeFriendlyName}FromJson]](e["value"]);
            a.Add(Key, Value);
        }
        return a;
    }
    public static JArray [[${TypeFriendlyName}ToJson]]([[${TypeString}]] c)
    {
        var ja = new JArray();
        foreach (var e in c)
        {
            var je = new JObject();
            je.Add("key", [[${KeyTypeFriendlyName}ToJson]](e.Key));
            je.Add("value", [[${ValueTypeFriendlyName}ToJson]](e.Value));
            ja.Add(je);
        }
        return ja;
    }

#Template Main Schema:Schema NamespaceName:String
    //==========================================================================
    //
    //  Notice:      This file is automatically generated.
    //               Please don't modify this file.
    //
    //==========================================================================

    //Reference:
    //Newtonsoft.Json.dll

    using System;
    using System.Collections.Generic;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;
    using ${Schema.Imports};
    $$
        var Primitives = GetPrimitives(Schema);
    ${Primitives}

    $$
        var ComplexTypes = GetComplexTypes(Schema);
        if (NamespaceName == "")
        {
            ##
                ${ComplexTypes}
        }
        else
        {
            ##
                namespace [[${NamespaceName}]]
                {
                    ${ComplexTypes}
                }
        }

$End
