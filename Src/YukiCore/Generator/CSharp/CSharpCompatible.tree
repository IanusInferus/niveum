$Comment
    ==========================================================================

      File:        CSharpCompatible.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C#通讯兼容模板
      Version:     2016.10.06.
      Copyright(C) F.R.C.

    ==========================================================================

#Option
    EnableEmbeddedExpr True

#Namespace Yuki.ObjectSchema.CSharpCompatible

#Import
    System
    System.Collections.Generic
    System.Linq
    Firefly

#Template EventPump ServerCommands:List<ServerCommandDef>
    $$
        var ServerCommandGroups = ServerCommands.GroupBy(sc => sc.Name).Where(g => g.Any(sc => sc.Version == "")).ToList();
    private class EventPump : IEventPump
    {
        $$
            foreach (var g in ServerCommandGroups)
            {
                var Name = g.Key;
                ##
                    public Action<[[${Name}Event]]> [[${Name}]] { get; set; }
            }
    }
    private IEventPump CreateEventPump(Func<String> GetVersion)
    {
        var ep = new EventPump();
        $$
            foreach (var g in ServerCommandGroups)
            {
                var Name = g.Key;
                var GroupCommands = g.ToList();
                if (GroupCommands.Count == 1)
                {
                    ##
                        [[ep.${Name}]] = e => { if ([[${Name}]] != null) { [[${Name}]](e); } };
                }
                else
                {
                    var SortedGroupCommands = GroupCommands.Where(sc => sc.Version != "").OrderByDescending(sc => new NumericString(sc.Version)).ToList();
                    ##
                        [[ep.${Name}]] = eHead =>
                        {
                            var Version = GetVersion();
                            if (Version == "")
                            {
                                if ([[${Name}]] != null) { [[${Name}]](eHead); }
                                return;
                            }
                            $$
                                foreach (var sc in SortedGroupCommands)
                                {
                                    var VersionedTypeFriendlyName = sc.TypeFriendlyName();
                                    ##
                                        if (Version == "${sc.Version}")
                                        {
                                            var e = [[${VersionedTypeFriendlyName}EventFromHead]](eHead);
                                            if ([[${VersionedTypeFriendlyName}]] != null) { [[${VersionedTypeFriendlyName}]](e); }
                                            return;
                                        }
                                }
                            throw new InvalidOperationException();
                        };
                }
            }
        return ep;
    }

#Template Translator_RecordFrom Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef> InitialHasError:Boolean
    $$
        var d = HeadFields.ToDictionary(f => f.Name);
        var HasError = InitialHasError || !Fields.All(f => IsNullType(f.Type) || (d.ContainsKey(f.Name) && (IsSameType(f.Type, d[f.Name].Type, false) || IsSameType(f.Type, d[f.Name].Type, true))));
        if (HasError)
        {
            ##
                //${Translator_RecordFrom(Name, VersionedName, Fields, HeadFields)}
        }
        else
        {
            ##
                ${Translator_RecordFrom(Name, VersionedName, Fields, HeadFields)}
        }

#Template Translator_RecordFrom Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef>
    public [[${VersionedName}]] [[${VersionedName}FromHead]]([[${Name}]] ho)
    {
        var o = new [[${VersionedName}]]();
        $$
            var d = HeadFields.ToDictionary(f => f.Name);
            foreach (var f in Fields)
            {
                if (IsNullType(f.Type))
                {
                    ##
                        o.[[${f.Name}]] = new Unit();
                    continue;
                }
                if (d.ContainsKey(f.Name))
                {
                    var fHead = d[f.Name];
                    if (IsSameType(f.Type, fHead.Type, false))
                    {
                        ##
                            o.[[${f.Name}]] = ho.[[${f.Name}]];
                        continue;
                    }
                    else if (IsSameType(f.Type, fHead.Type, true))
                    {
                        ##
                            o.[[${f.Name}]] = [[${f.Type.TypeFriendlyName()}FromHead]](ho.[[${f.Name}]]);
                        continue;
                    }
                }
                ##
                    o.[[${f.Name}]] = ho.[[${f.Name}]];
            }
        return o;
    }

#Template Translator_RecordTo Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef> InitialHasError:Boolean
    $$
        var d = Fields.ToDictionary(f => f.Name);
        var HasError = InitialHasError || !HeadFields.All(fHead => IsNullType(fHead.Type) || (d.ContainsKey(fHead.Name) && (IsSameType(d[fHead.Name].Type, fHead.Type, false) || IsSameType(d[fHead.Name].Type, fHead.Type, true))));
        if (HasError)
        {
            ##
                //${Translator_RecordTo(Name, VersionedName, Fields, HeadFields)}
        }
        else
        {
            ##
                ${Translator_RecordTo(Name, VersionedName, Fields, HeadFields)}
        }

#Template Translator_RecordTo Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef>
    public [[${Name}]] [[${VersionedName}ToHead]]([[${VersionedName}]] o)
    {
        var ho = new [[${Name}]]();
        $$
            var d = Fields.ToDictionary(f => f.Name);
            foreach (var fHead in HeadFields)
            {
                if (IsNullType(fHead.Type))
                {
                    ##
                        ho.[[${fHead.Name}]] = new Unit();
                    continue;
                }
                if (d.ContainsKey(fHead.Name))
                {
                    var f = d[fHead.Name];
                    if (IsSameType(f.Type, fHead.Type, false))
                    {
                        ##
                            ho.[[${f.Name}]] = o.[[${f.Name}]];
                        continue;
                    }
                    else if (IsSameType(f.Type, fHead.Type, true))
                    {
                        ##
                            ho.[[${f.Name}]] = [[${f.Type.TypeFriendlyName()}ToHead]](o.[[${f.Name}]]);
                        continue;
                    }
                }
                ##
                    ho.[[${fHead.Name}]] = o.[[${fHead.Name}]];
            }
        return ho;
    }

#Template Translator_TaggedUnionFrom VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef> InitialHasError:Boolean
    $$
        var d = Alternatives.ToDictionary(a => a.Name);
        var HasError = InitialHasError || !HeadAlternatives.All(aHead => d.ContainsKey(aHead.Name) && (IsNullType(d[aHead.Name].Type) || IsSameType(d[aHead.Name].Type, aHead.Type, false) || IsSameType(d[aHead.Name].Type, aHead.Type, true)));
        if (HasError)
        {
            ##
                //${Translator_TaggedUnionFrom(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }
        else
        {
            ##
                ${Translator_TaggedUnionFrom(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }

#Template Translator_TaggedUnionFrom VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef>
    public ${VersionedTypeString} [[${VersionedName}FromHead]](${TypeString} ho)
    {
        $$
            var d = Alternatives.ToDictionary(a => a.Name);
            foreach (var aHead in HeadAlternatives)
            {
                if (d.ContainsKey(aHead.Name))
                {
                    var a = d[aHead.Name];
                    if (IsNullType(a.Type))
                    {
                        ##
                            if (ho.[[On${a.Name}]])
                            {
                                return [[${VersionedTypeString}.Create${a.Name}]]();
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, false))
                    {
                        ##
                            if (ho.[[On${a.Name}]])
                            {
                                return [[${VersionedTypeString}.Create${a.Name}]](ho.[[${a.Name}]]);
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, true))
                    {
                        ##
                            if (ho.[[On${a.Name}]])
                            {
                                return [[${VersionedTypeString}.Create${a.Name}]]([[${a.Type.TypeFriendlyName()}FromHead]](ho.[[${a.Name}]]));
                            }
                        continue;
                    }
                }
                ##
                    if (ho.[[On${aHead.Name}]])
                    {
                        return [[${VersionedTypeString}.Create${aHead.Name}]](ho.[[${aHead.Name}]]);
                    }
            }
        throw new InvalidOperationException();
    }

#Template Translator_TaggedUnionTo VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef> InitialHasError:Boolean
    $$
        var d = Alternatives.ToDictionary(a => a.Name);
        var HasError = InitialHasError || !HeadAlternatives.All(aHead => d.ContainsKey(aHead.Name) && (IsNullType(d[aHead.Name].Type) || IsSameType(d[aHead.Name].Type, aHead.Type, false) || IsSameType(d[aHead.Name].Type, aHead.Type, true)));
        if (HasError)
        {
            ##
                //${Translator_TaggedUnionTo(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }
        else
        {
            ##
                ${Translator_TaggedUnionTo(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }

#Template Translator_TaggedUnionTo VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef>
    public ${TypeString} [[${VersionedName}ToHead]](${VersionedTypeString} o)
    {
        $$
            var d = Alternatives.ToDictionary(a => a.Name);
            foreach (var aHead in HeadAlternatives)
            {
                if (d.ContainsKey(aHead.Name))
                {
                    var a = d[aHead.Name];
                    if (IsNullType(a.Type))
                    {
                        ##
                            if (o.[[On${a.Name}]])
                            {
                                return [[${TypeString}.Create${a.Name}]]();
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, false))
                    {
                        ##
                            if (o.[[On${a.Name}]])
                            {
                                return [[${TypeString}.Create${a.Name}]](o.[[${a.Name}]]);
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, true))
                    {
                        ##
                            if (o.[[On${a.Name}]])
                            {
                                return [[${TypeString}.Create${a.Name}]]([[${a.Type.TypeFriendlyName()}ToHead]](o.[[${a.Name}]]));
                            }
                        continue;
                    }
                }
                ##
                    if (o.[[On${aHead.Name}]])
                    {
                        return [[${TypeString}.Create${aHead.Name}]](o.[[${aHead.Name}]]);
                    }
            }
        throw new InvalidOperationException();
    }

#Template Translator_EnumFrom Name:String VersionedName:String Literals:List<LiteralDef> HeadLiterals:List<LiteralDef>
    public [[${VersionedName}]] [[${VersionedName}FromHead]]([[${Name}]] ho)
    {
        $$
            foreach (var ltl in HeadLiterals)
            {
                ##
                    if (ho == [[${Name}.${ltl.Name}]])
                    {
                        return [[${VersionedName}.${ltl.Name}]];
                    }
            }
        throw new InvalidOperationException();
    }

#Template Translator_EnumTo Name:String VersionedName:String Literals:List<LiteralDef> HeadLiterals:List<LiteralDef>
    public [[${Name}]] [[${VersionedName}ToHead]]([[${VersionedName}]] o)
    {
        $$
            foreach (var ltl in Literals)
            {
                ##
                    if (o == [[${VersionedName}.${ltl.Name}]])
                    {
                        return [[${Name}.${ltl.Name}]];
                    }
            }
        throw new InvalidOperationException();
    }

#Template Translator_ClientCommand Name:String VersionedName:String
    public [[${VersionedName}Reply]] [[${VersionedName}]]([[${VersionedName}Request]] r)
    {
        var HeadRequest = [[${VersionedName}RequestToHead]](r);
        var HeadReply = [[${Name}]](HeadRequest);
        var Reply = [[${VersionedName}ReplyFromHead]](HeadReply);
        return Reply;
    }

#Template Translator_ClientCommandAsync Name:String VersionedName:String
    public void [[${VersionedName}]]([[${VersionedName}Request]] r, Action<[[${VersionedName}Reply]]> Callback, Action<Exception> OnFailure)
    {
        var HeadRequest = [[${VersionedName}RequestToHead]](r);
        [[${Name}]](HeadRequest, HeadReply => Callback([[${VersionedName}ReplyFromHead]](HeadReply)), OnFailure);
    }

#Template Translator_ServerCommand VersionedName:String
    public event Action<[[${VersionedName}Event]]> [[${VersionedName}]];

#Template Translator_TupleFrom VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec> InitialHasError:Boolean
    $$
        var HasError = InitialHasError || (Elements.Count != HeadElements.Count) || !Elements.Zip(HeadElements, (e, eHead) => IsNullType(e) || IsSameType(e, eHead, false) || IsSameType(e, eHead, true)).All(b => b);
        if (HasError)
        {
            ##
                //${Translator_TupleFrom(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }
        else
        {
            ##
                ${Translator_TupleFrom(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }

#Template Translator_TupleFrom VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec>
    public ${VersionedTypeString} [[${VersionedName}FromHead]](${TypeString} ho)
    {
        $$
            var k = 0;
            foreach (var e in Elements)
            {
                if (IsNullType(e))
                {
                    ##
                        var Item${k + 1} = new Unit();
                    k += 1;
                    continue;
                }
                if (k < HeadElements.Count)
                {
                    var eHead = HeadElements[k];
                    if (IsSameType(e, eHead, false))
                    {
                        ##
                            var Item${k + 1} = ho.Item${k + 1};
                        k += 1;
                        continue;
                    }
                    else if (IsSameType(e, eHead, true))
                    {
                        ##
                            var Item${k + 1} = [[${e.TypeFriendlyName()}FromHead]](ho.Item${k + 1});
                        k += 1;
                        continue;
                    }
                }
                ##
                    var Item${k + 1} = ho.Item${k + 1};
                k += 1;
            }
        return new ${VersionedTypeString}(${String.Join(", ", Enumerable.Range(0, Elements.Count).Select(i => "Item" + (i + 1).ToInvariantString()))});
    }

#Template Translator_TupleTo VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec> InitialHasError:Boolean
    $$
        var HasError = InitialHasError || (Elements.Count != HeadElements.Count) || !Elements.Zip(HeadElements, (e, eHead) => IsNullType(e) || IsSameType(e, eHead, false) || IsSameType(e, eHead, true)).All(b => b);
        if (HasError)
        {
            ##
                //${Translator_TupleTo(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }
        else
        {
            ##
                ${Translator_TupleTo(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }

#Template Translator_TupleTo VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec>
    public ${TypeString} [[${VersionedName}ToHead]](${VersionedTypeString} o)
    {
        $$
            var k = 0;
            foreach (var eHead in HeadElements)
            {
                if (IsNullType(eHead))
                {
                    ##
                        var Item${k + 1} = new Unit();
                    k += 1;
                    continue;
                }
                if (k < Elements.Count)
                {
                    var e = Elements[k];
                    if (IsSameType(e, eHead, false))
                    {
                        ##
                            var Item${k + 1} = o.Item${k + 1};
                        k += 1;
                        continue;
                    }
                    else if (IsSameType(e, eHead, true))
                    {
                        ##
                            var Item${k + 1} = [[${e.TypeFriendlyName()}ToHead]](o.Item${k + 1});
                        k += 1;
                        continue;
                    }
                }
                ##
                    var Item${k + 1} = o.Item${k + 1};
                k += 1;
            }
        return new ${TypeString}(${String.Join(", ", Enumerable.Range(0, Elements.Count).Select(i => "Item" + (i + 1).ToInvariantString()))});
    }

#Template Translator_ListFrom VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    public ${VersionedTypeString} [[${VersionedTypeFriendlyName}FromHead]](${TypeString} ho)
    {
        return ho.Select(he => [[${VersionedElementTypeFriendlyName}FromHead]](he)).ToList();
    }

#Template Translator_ListTo VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    public ${TypeString} [[${VersionedTypeFriendlyName}ToHead]](${VersionedTypeString} o)
    {
        return o.Select(e => [[${VersionedElementTypeFriendlyName}ToHead]](e)).ToList();
    }

#Template Translator_SetFrom VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    public ${VersionedTypeString} [[${VersionedTypeFriendlyName}FromHead]](${TypeString} ho)
    {
        return new ${VersionedTypeString}(ho.Select(he => [[${VersionedElementTypeFriendlyName}FromHead]](he)));
    }

#Template Translator_SetTo VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    public ${TypeString} [[${VersionedTypeFriendlyName}ToHead]](${VersionedTypeString} o)
    {
        return new ${TypeString}(o.Select(e => [[${VersionedElementTypeFriendlyName}ToHead]](e)));
    }

#Template Translator_MapFrom VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String KeyTypeSpec:TypeSpec HeadKeyTypeSpec:TypeSpec ValueTypeSpec:TypeSpec HeadValueTypeSpec:TypeSpec
    public ${VersionedTypeString} [[${VersionedTypeFriendlyName}FromHead]](${TypeString} ho)
    {
        var o = new ${VersionedTypeString}();
        foreach (var hp in ho)
        {
            $$
                if (IsSameType(KeyTypeSpec, HeadKeyTypeSpec, false))
                {
                    ##
                        var Key = hp.Key;
                }
                else
                {
                    ##
                        var Key = [[${KeyTypeSpec.TypeFriendlyName()}FromHead]](hp.Key);
                }
                if (IsSameType(ValueTypeSpec, HeadValueTypeSpec, false))
                {
                    ##
                        var Value = hp.Value;
                }
                else
                {
                    ##
                        var Value = [[${ValueTypeSpec.TypeFriendlyName()}FromHead]](hp.Value);
                }
            o.Add(Key, Value);
        }
        return o;
    }

#Template Translator_MapTo VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String KeyTypeSpec:TypeSpec HeadKeyTypeSpec:TypeSpec ValueTypeSpec:TypeSpec HeadValueTypeSpec:TypeSpec
    public ${TypeString} [[${VersionedTypeFriendlyName}ToHead]](${VersionedTypeString} o)
    {
        var ho = new ${TypeString}();
        foreach (var p in o)
        {
            $$
                if (IsSameType(KeyTypeSpec, HeadKeyTypeSpec, false))
                {
                    ##
                        var Key = p.Key;
                }
                else
                {
                    ##
                        var Key = [[${KeyTypeSpec.TypeFriendlyName()}ToHead]](p.Key);
                }
                if (IsSameType(ValueTypeSpec, HeadValueTypeSpec, false))
                {
                    ##
                        var Value = p.Value;
                }
                else
                {
                    ##
                        var Value = [[${ValueTypeSpec.TypeFriendlyName()}ToHead]](p.Value);
                }
            ho.Add(Key, Value);
        }
        return ho;
    }

#Template Main Schema:Schema NamespaceName:String ClassName:String
    //==========================================================================
    //
    //  Notice:      This file is automatically generated.
    //               Please don't modify this file.
    //
    //==========================================================================

    using System;
    using System.Collections.Generic;
    using System.Linq;
    using ${Schema.Imports};
    $$
        var Primitives = GetPrimitives(Schema);
    ${Primitives}

    $$
        var ComplexTypes = GetComplexTypes(Schema);
        if (NamespaceName == "")
        {
            ##
                public partial class [[${ClassName}]]
                {
                    ${ComplexTypes}
                }
        }
        else
        {
            ##
                namespace [[${NamespaceName}]]
                {
                    public partial class [[${ClassName}]]
                    {
                        ${ComplexTypes}
                    }
                }
        }

$End
