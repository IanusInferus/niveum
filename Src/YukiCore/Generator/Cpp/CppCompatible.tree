$Comment
    ==========================================================================

      File:        CppCompatible.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构C++通讯兼容模板
      Version:     2018.08.17.
      Copyright(C) F.R.C.

    ==========================================================================

#Option
    EnableEmbeddedExpr True

#Namespace Yuki.ObjectSchema.CppCompatible

#Import
    System
    System.Collections.Generic
    System.Linq
    Firefly

#Template EventPump ServerCommands:List<ServerCommandDef>
    $$
        var ServerCommandGroups = ServerCommands.GroupBy(sc => sc.Name).Where(g => g.Any(sc => sc.Version == "")).ToList();
    class EventPump : public IEventPump
    {
    };
    IEventPump CreateEventPump(std::function<std::wstring()> GetVersion)
    {
        auto ep = std::make_shared<EventPump>();
        $$
            foreach (var g in ServerCommandGroups)
            {
                var Name = g.Key;
                var GroupCommands = g.ToList();
                if (GroupCommands.Count == 1)
                {
                    ##
                        ep->[[${Name}]] = [](std::shared_ptr<class [[${Name}Event]]> e) { if ([[${Name}]] != nullptr) { [[${Name}]](e); } };
                }
                else
                {
                    var SortedGroupCommands = GroupCommands.Where(sc => sc.Version != "").OrderByDescending(sc => new NumericString(sc.Version)).ToList();
                    ##
                        ep->[[${Name}]] = [](std::shared_ptr<class [[${Name}Event]]> eHead)
                        {
                            auto Version = GetVersion();
                            if (Version == L"")
                            {
                                if ([[${Name}]] != nullptr) { [[${Name}]](eHead); }
                                return;
                            }
                            $$
                                foreach (var sc in SortedGroupCommands)
                                {
                                    var VersionedTypeFriendlyName = sc.TypeFriendlyName();
                                    ##
                                        if (Version == L"${sc.Version}")
                                        {
                                            auto e = [[${VersionedTypeFriendlyName}EventFromHead]](eHead);
                                            if ([[${VersionedTypeFriendlyName}]] != nullptr) { [[${VersionedTypeFriendlyName}]](e); }
                                            return;
                                        }
                                }
                            throw std::logic_error("InvalidOperation");
                        };
                }
            }
        return ep;
    }

#Template Translator_RecordFrom Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef> InitialHasError:Boolean
    $$
        var d = HeadFields.ToDictionary(f => f.Name);
        var HasError = InitialHasError || !Fields.All(f => IsNullType(f.Type) || (d.ContainsKey(f.Name) && (IsSameType(f.Type, d[f.Name].Type, false) || IsSameType(f.Type, d[f.Name].Type, true))));
        if (HasError)
        {
            ##
                //${Translator_RecordFrom(Name, VersionedName, Fields, HeadFields)}
        }
        else
        {
            ##
                ${Translator_RecordFrom(Name, VersionedName, Fields, HeadFields)}
        }

#Template Translator_RecordFrom Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef>
    std::shared_ptr<class [[${VersionedName}]]> [[${VersionedName}FromHead]](std::shared_ptr<class [[${Name}]]> ho)
    {
        auto o = std::make_shared<class [[${VersionedName}]]>();
        $$
            var d = HeadFields.ToDictionary(f => f.Name);
            foreach (var f in Fields)
            {
                if (IsNullType(f.Type))
                {
                    ##
                        o->[[${f.Name}]] = Unit();
                    continue;
                }
                if (d.ContainsKey(f.Name))
                {
                    var fHead = d[f.Name];
                    if (IsSameType(f.Type, fHead.Type, false))
                    {
                        ##
                            o->[[${f.Name}]] = ho->[[${f.Name}]];
                        continue;
                    }
                    else if (IsSameType(f.Type, fHead.Type, true))
                    {
                        ##
                            o->[[${f.Name}]] = [[${f.Type.TypeFriendlyName()}FromHead]](ho->[[${f.Name}]]);
                        continue;
                    }
                }
                ##
                    o.[[${f.Name}]] = ho.[[${f.Name}]];
            }
        return o;
    }

#Template Translator_RecordTo Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef> InitialHasError:Boolean
    $$
        var d = Fields.ToDictionary(f => f.Name);
        var HasError = InitialHasError || !HeadFields.All(fHead => IsNullType(fHead.Type) || (d.ContainsKey(fHead.Name) && (IsSameType(d[fHead.Name].Type, fHead.Type, false) || IsSameType(d[fHead.Name].Type, fHead.Type, true))));
        if (HasError)
        {
            ##
                //${Translator_RecordTo(Name, VersionedName, Fields, HeadFields)}
        }
        else
        {
            ##
                ${Translator_RecordTo(Name, VersionedName, Fields, HeadFields)}
        }

#Template Translator_RecordTo Name:String VersionedName:String Fields:List<VariableDef> HeadFields:List<VariableDef>
    std::shared_ptr<class [[${Name}]]> [[${VersionedName}ToHead]](std::shared_ptr<class [[${VersionedName}]]> o)
    {
        auto ho = std::make_shared<class [[${Name}]]>();
        $$
            var d = Fields.ToDictionary(f => f.Name);
            foreach (var fHead in HeadFields)
            {
                if (IsNullType(fHead.Type))
                {
                    ##
                        ho->[[${fHead.Name}]] = Unit();
                    continue;
                }
                if (d.ContainsKey(fHead.Name))
                {
                    var f = d[fHead.Name];
                    if (IsSameType(f.Type, fHead.Type, false))
                    {
                        ##
                            ho->[[${f.Name}]] = o->[[${f.Name}]];
                        continue;
                    }
                    else if (IsSameType(f.Type, fHead.Type, true))
                    {
                        ##
                            ho->[[${f.Name}]] = [[${f.Type.TypeFriendlyName()}ToHead]](o->[[${f.Name}]]);
                        continue;
                    }
                }
                ##
                    ho->[[${fHead.Name}]] = o->[[${fHead.Name}]];
            }
        return ho;
    }

#Template Translator_TaggedUnionFrom VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef> InitialHasError:Boolean
    $$
        var d = Alternatives.ToDictionary(a => a.Name);
        var HasError = InitialHasError || !HeadAlternatives.All(aHead => d.ContainsKey(aHead.Name) && (IsNullType(d[aHead.Name].Type) || IsSameType(d[aHead.Name].Type, aHead.Type, false) || IsSameType(d[aHead.Name].Type, aHead.Type, true)));
        if (HasError)
        {
            ##
                //${Translator_TaggedUnionFrom(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }
        else
        {
            ##
                ${Translator_TaggedUnionFrom(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }

#Template Translator_TaggedUnionFrom VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef>
    std::shared_ptr<class ${VersionedTypeString}> [[${VersionedName}FromHead]](std::shared_ptr<class ${TypeString}> ho)
    {
        $$
            var d = Alternatives.ToDictionary(a => a.Name);
            foreach (var aHead in HeadAlternatives)
            {
                if (d.ContainsKey(aHead.Name))
                {
                    var a = d[aHead.Name];
                    if (IsNullType(a.Type))
                    {
                        ##
                            if (ho->[[On${a.Name}]]())
                            {
                                return [[${VersionedTypeString}::Create${a.Name}]]();
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, false))
                    {
                        ##
                            if (ho->[[On${a.Name}]]())
                            {
                                return [[${VersionedTypeString}::Create${a.Name}]](ho->[[${a.Name}]]);
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, true))
                    {
                        ##
                            if (ho->[[On${a.Name}]]())
                            {
                                return [[${VersionedTypeString}::Create${a.Name}]]([[${a.Type.TypeFriendlyName()}FromHead]](ho->[[${a.Name}]]));
                            }
                        continue;
                    }
                }
                ##
                    if (ho->[[On${aHead.Name}]]())
                    {
                        return [[${VersionedTypeString}::Create${aHead.Name}]](ho->[[${aHead.Name}]]);
                    }
            }
        throw std::logic_error("InvalidOperation");
    }

#Template Translator_TaggedUnionTo VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef> InitialHasError:Boolean
    $$
        var d = Alternatives.ToDictionary(a => a.Name);
        var HasError = InitialHasError || !HeadAlternatives.All(aHead => d.ContainsKey(aHead.Name) && (IsNullType(aHead.Type) || IsSameType(d[aHead.Name].Type, aHead.Type, false) || IsSameType(d[aHead.Name].Type, aHead.Type, true)));
        if (HasError)
        {
            ##
                //${Translator_TaggedUnionTo(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }
        else
        {
            ##
                ${Translator_TaggedUnionTo(VersionedName, TypeString, VersionedTypeString, Alternatives, HeadAlternatives)}
        }

#Template Translator_TaggedUnionTo VersionedName:String TypeString:String VersionedTypeString:String Alternatives:List<VariableDef> HeadAlternatives:List<VariableDef>
    std::shared_ptr<class ${TypeString}> [[${VersionedName}ToHead]](std::shared_ptr<class ${VersionedTypeString}> o)
    {
        $$
            var d = Alternatives.ToDictionary(a => a.Name);
            foreach (var aHead in HeadAlternatives)
            {
                if (d.ContainsKey(aHead.Name))
                {
                    var a = d[aHead.Name];
                    if (IsNullType(aHead.Type))
                    {
                        ##
                            if (o->[[On${a.Name}]]())
                            {
                                return [[${TypeString}::Create${a.Name}]]();
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, false))
                    {
                        ##
                            if (o->[[On${a.Name}]]())
                            {
                                return [[${TypeString}::Create${a.Name}]](o->[[${a.Name}]]);
                            }
                        continue;
                    }
                    else if (IsSameType(a.Type, aHead.Type, true))
                    {
                        ##
                            if (o->[[On${a.Name}]]())
                            {
                                return [[${TypeString}::Create${a.Name}]]([[${a.Type.TypeFriendlyName()}ToHead]](o->[[${a.Name}]]));
                            }
                        continue;
                    }
                }
                ##
                    if (o->[[On${aHead.Name}]]())
                    {
                        return [[${TypeString}::Create${aHead.Name}]](o->[[${aHead.Name}]]);
                    }
            }
        throw std::logic_error("InvalidOperation");
    }

#Template Translator_EnumFrom Name:String VersionedName:String Literals:List<LiteralDef> HeadLiterals:List<LiteralDef>
    [[${VersionedName}]] [[${VersionedName}FromHead]]([[${Name}]] ho)
    {
        $$
            foreach (var ltl in HeadLiterals)
            {
                ##
                    if (ho == [[${Name}::${ltl.Name}]])
                    {
                        return [[${VersionedName}::${ltl.Name}]];
                    }
            }
        throw std::logic_error("InvalidOperation");
    }

#Template Translator_EnumTo Name:String VersionedName:String Literals:List<LiteralDef> HeadLiterals:List<LiteralDef>
    [[${Name}]] [[${VersionedName}ToHead]]([[${VersionedName}]] o)
    {
        $$
            foreach (var ltl in Literals)
            {
                ##
                    if (o == [[${VersionedName}::${ltl.Name}]])
                    {
                        return [[${Name}::${ltl.Name}]];
                    }
            }
        throw std::logic_error("InvalidOperation");
    }

#Template Translator_ClientCommand Name:String VersionedName:String
    std::shared_ptr<class [[${VersionedName}Reply]]> [[${VersionedName}]](std::shared_ptr<class [[${VersionedName}Request]]> r)
    {
        auto HeadRequest = [[${VersionedName}RequestToHead]](r);
        auto HeadReply = [[${Name}]](HeadRequest);
        auto Reply = [[${VersionedName}ReplyFromHead]](HeadReply);
        return Reply;
    }

#Template Translator_ClientCommandAsync Name:String VersionedName:String
    void std::shared_ptr<class [[${VersionedName}]]>(std::shared_ptr<class [[${VersionedName}Request]]> r, std::functional<void(std::shared_ptr<class [[${VersionedName}Reply]]>)> Callback, std::functional<void(std::wstring)> OnFailure)
    {
        auto HeadRequest = [[${VersionedName}RequestToHead]](r);
        [[${Name}]](HeadRequest, [](std::shared_ptr<class [[${VersionedName}Reply]]> HeadReply) { Callback([[${VersionedName}ReplyFromHead]](HeadReply)); }, OnFailure);
    }

#Template Translator_ServerCommand VersionedName:String
    std::function<void(std::shared_ptr<class [[${VersionedName}Event]]>)> [[${VersionedName}]];

#Template Translator_TupleFrom VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec> InitialHasError:Boolean
    $$
        var HasError = InitialHasError || (Elements.Count != HeadElements.Count) || !Elements.Zip(HeadElements, (e, eHead) => IsNullType(e) || IsSameType(e, eHead, false) || IsSameType(e, eHead, true)).All(b => b);
        if (HasError)
        {
            ##
                //${Translator_TupleFrom(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }
        else
        {
            ##
                ${Translator_TupleFrom(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }

#Template Translator_TupleFrom VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec>
    ${VersionedTypeString} [[${VersionedName}FromHead]](${TypeString} ho)
    {
        $$
            var k = 0;
            foreach (var e in Elements)
            {
                if (IsNullType(e))
                {
                    ##
                        auto Item${k + 1} = Unit();
                    k += 1;
                    continue;
                }
                if (k < HeadElements.Count)
                {
                    var eHead = HeadElements[k];
                    if (IsSameType(e, eHead, false))
                    {
                        ##
                            auto Item${k} = std::get<${k}>(ho);
                        k += 1;
                        continue;
                    }
                    else if (IsSameType(e, eHead, true))
                    {
                        ##
                            auto Item${k} = [[${e.TypeFriendlyName()}FromHead]](std::get<${k}>(ho));
                        k += 1;
                        continue;
                    }
                }
                ##
                    auto Item${k} = std::get<${k}>(ho);
                k += 1;
            }
        return std::make_tuple(${String.Join(", ", Enumerable.Range(0, Elements.Count).Select(i => "Item" + i.ToInvariantString()))});
    }

#Template Translator_TupleTo VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec> InitialHasError:Boolean
    $$
        var HasError = InitialHasError || (Elements.Count != HeadElements.Count) || !Elements.Zip(HeadElements, (e, eHead) => IsNullType(e) || IsSameType(e, eHead, false) || IsSameType(e, eHead, true)).All(b => b);
        if (HasError)
        {
            ##
                //${Translator_TupleTo(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }
        else
        {
            ##
                ${Translator_TupleTo(VersionedName, TypeString, VersionedTypeString, Elements, HeadElements)}
        }

#Template Translator_TupleTo VersionedName:String TypeString:String VersionedTypeString:String Elements:List<TypeSpec> HeadElements:List<TypeSpec>
    ${TypeString} [[${VersionedName}ToHead]](${VersionedTypeString} o)
    {
        $$
            var k = 0;
            foreach (var eHead in HeadElements)
            {
                if (IsNullType(eHead))
                {
                    ##
                        auto Item${k} = Unit();
                    k += 1;
                    continue;
                }
                if (k < Elements.Count)
                {
                    var e = Elements[k];
                    if (IsSameType(e, eHead, false))
                    {
                        ##
                            auto Item${k} = std::get<${k}>(o);
                        k += 1;
                        continue;
                    }
                    else if (IsSameType(e, eHead, true))
                    {
                        ##
                            auto Item${k} = [[${e.TypeFriendlyName()}ToHead]](std::get<${k}>(o));
                        k += 1;
                        continue;
                    }
                }
                ##
                    auto Item${k} = std::get<${k}>(o);
                k += 1;
            }
        return std::make_tuple(${String.Join(", ", Enumerable.Range(0, Elements.Count).Select(i => "Item" + i.ToInvariantString()))});
    }

#Template Translator_ListFrom VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    std::shared_ptr<class ${VersionedTypeString}> [[${VersionedTypeFriendlyName}FromHead]](std::shared_ptr<class ${TypeString}> ho)
    {
        auto l = std::make_shared<${VersionedTypeString}>();
        for (auto he : *ho)
        {
            l->push_back([[${VersionedElementTypeFriendlyName}FromHead]](he));
        }
        return l;
    }

#Template Translator_ListTo VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    std::shared_ptr<class ${TypeString}> [[${VersionedTypeFriendlyName}ToHead]](std::shared_ptr<class ${VersionedTypeString}> o)
    {
        auto l = std::make_shared<${TypeString}>();
        for (auto e : *o)
        {
            l->push_back([[${VersionedElementTypeFriendlyName}ToHead]](e));
        }
        return l;
    }

#Template Translator_SetFrom VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    std::shared_ptr<class ${VersionedTypeString}> [[${VersionedTypeFriendlyName}FromHead]](std::shared_ptr<class ${TypeString}> ho)
    {
        auto s = std::make_shared<${VersionedTypeString}>();
        for (auto he : *ho)
        {
            s->insert([[${VersionedElementTypeFriendlyName}FromHead]](he));
        }
        return s;
    }

#Template Translator_SetTo VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String VersionedElementTypeFriendlyName:String
    std::shared_ptr<class ${TypeString}> [[${VersionedTypeFriendlyName}ToHead]](std::shared_ptr<class ${VersionedTypeString}> o)
    {
        auto s = std::make_shared<${TypeString}>();
        for (auto e : *o)
        {
            s->insert([[${VersionedElementTypeFriendlyName}ToHead]](e));
        }
        return s;
    }

#Template Translator_MapFrom VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String KeyTypeSpec:TypeSpec HeadKeyTypeSpec:TypeSpec ValueTypeSpec:TypeSpec HeadValueTypeSpec:TypeSpec
    std::shared_ptr<class ${VersionedTypeString}> [[${VersionedTypeFriendlyName}FromHead]](std::shared_ptr<class ${TypeString}> ho)
    {
        auto o = std::make_shared<${VersionedTypeString}>();
        for (auto hp : *ho)
        {
            $$
                if (IsSameType(KeyTypeSpec, HeadKeyTypeSpec, false))
                {
                    ##
                        auto Key = std::get<0>(hp);
                }
                else
                {
                    ##
                        auto Key = [[${KeyTypeSpec.TypeFriendlyName()}FromHead]](std::get<0>(hp));
                }
                if (IsSameType(ValueTypeSpec, HeadValueTypeSpec, false))
                {
                    ##
                        auto Value = std::get<1>(hp);
                }
                else
                {
                    ##
                        auto Value = [[${ValueTypeSpec.TypeFriendlyName()}FromHead]](std::get<1>(hp));
                }
            (*o)[Key] = Value;
        }
        return o;
    }

#Template Translator_MapTo VersionedTypeFriendlyName:String TypeString:String VersionedTypeString:String KeyTypeSpec:TypeSpec HeadKeyTypeSpec:TypeSpec ValueTypeSpec:TypeSpec HeadValueTypeSpec:TypeSpec
    std::shared_ptr<class ${TypeString}> [[${VersionedTypeFriendlyName}ToHead]](std::shared_ptr<class ${VersionedTypeString}> o)
    {
        auto ho = std::make_shared<${TypeString}>();
        for (auto p : *o)
        {
            $$
                if (IsSameType(KeyTypeSpec, HeadKeyTypeSpec, false))
                {
                    ##
                        auto Key = std::get<0>(p);
                }
                else
                {
                    ##
                        auto Key = [[${KeyTypeSpec.TypeFriendlyName()}ToHead]](std::get<0>(p));
                }
                if (IsSameType(ValueTypeSpec, HeadValueTypeSpec, false))
                {
                    ##
                        auto Value = std::get<1>(p);
                }
                else
                {
                    ##
                        auto Value = [[${ValueTypeSpec.TypeFriendlyName()}ToHead]](std::get<1>(p));
                }
            (*ho)[Key] = Value;
        }
        return ho;
    }

#Template WrapNamespace NamespacePart:String Contents:IEnumerable<String>
    namespace [[${NamespacePart}]]
    {
        ${Contents}
    }

#Template WrapClass ClassName:String Contents:IEnumerable<String>
    /* partial */ class [[${ClassName}]]
    {
    public:
        ${Contents}
    };

#Template Main Schema:Schema NamespaceName:String ClassName:String
    //==========================================================================
    //
    //  Notice:      This file is automatically generated.
    //               Please don't modify this file.
    //
    //==========================================================================

    #pragma once

    #include <cstddef>
    #include <cstdint>
    #include <string>
    #include <vector>
    #include <unordered_set>
    #include <unordered_map>
    #include <tuple>
    #include <memory>
    #include <functional>
    #include <exception>
    #include <stdexcept>
    #include ${Schema.Imports.Where(i => IsInclude(i))}

    $$
        var Primitives = GetPrimitives(Schema);
        var ComplexTypes = GetComplexTypes(Schema);
    ${Primitives}
    ${WrapContents(NamespaceName, WrapClass(ClassName, ComplexTypes).ToList())}

$End
