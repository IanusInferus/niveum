$Comment
    ==========================================================================

      File:        Schema.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构ActionScript3.0二进制通讯模板数据
      Version:     2013.03.31.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name Main
            //Parameters: ${PackageName}, ${Imports}, ${Type}
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    package [[${PackageName}]]
                    {
                        import flash.errors.IllegalOperationError;
                        import flash.utils.Dictionary;
                        import flash.utils.IDataInput;
                        import flash.utils.IDataOutput;
                        import flash.utils.ByteArray;
                        import flash.utils.Endian;
                        import ${Imports};

                        ${Type}
                    }

                $End
        Template
            Name BinaryTranslator
            //Parameters: ${Serializers}
            Value
                $String
                    public class BinaryTranslator
                    {
                        public static function unitFromBinary(ba:IDataInput):Unit { return new Unit(); }
                        public static function unitToBinary(ba:IDataOutput, v:Unit):void { }

                        public static function booleanFromBinary(ba:IDataInput):Boolean { return uint8FromBinary(ba) != 0; }
                        public static function booleanToBinary(ba:IDataOutput, v:Boolean):void
                        {
                            if (v)
                            {
                                uint8ToBinary(ba, 0xFF);
                            }
                            else
                            {
                                uint8ToBinary(ba, 0);
                            }
                        }

                        public static function stringFromBinary(ba:IDataInput):String
                        {
                            var n:int = int32FromBinary(ba);
                            if ((n % 2) != 0) { throw new IllegalOperationError(); }
                            var l:Vector.<String> = new Vector.<String>();
                            for (var k:int = 0; k < n / 2; k += 1)
                            {
                                var lower:uint = uint8FromBinary(ba);
                                var upper:uint = uint8FromBinary(ba);
                                var c:uint = (upper << 8) | lower;
                                l.push(String.fromCharCode(c));
                            }
                            return l.join("");
                        }
                        public static function stringToBinary(ba:IDataOutput, v:String):void
                        {
                            int32ToBinary(ba, v.length * 2);
                            for (var k:int = 0; k < v.length; k += 1)
                            {
                                var c:uint = (uint)(v.charCodeAt(k));
                                uint8ToBinary(ba, c & 0xFF);
                                uint8ToBinary(ba, (c >> 8) & 0xFF);
                            }
                        }

                        public static function intFromBinary(ba:IDataInput):int { return int32FromBinary(ba); }
                        public static function intToBinary(ba:IDataOutput, v:int):void { int32ToBinary(ba, v); }

                        public static function realFromBinary(ba:IDataInput):Number { return float64FromBinary(ba); }
                        public static function realToBinary(ba:IDataOutput, v:Number):void { float64ToBinary(ba, v); }

                        public static function byteFromBinary(ba:IDataInput):uint { return uint8FromBinary(ba);  }
                        public static function byteToBinary(ba:IDataOutput, v:uint):void { uint8ToBinary(ba, v); }

                        public static function uint8FromBinary(ba:IDataInput):uint { return ba.readUnsignedByte();}
                        public static function uint8ToBinary(ba:IDataOutput, v:uint):void { ba.writeByte((int)(v)); }

                        public static function uint16FromBinary(ba:IDataInput):uint
                        {
                            var o:uint;
                            o = uint8FromBinary(ba);
                            o = (uint8FromBinary(ba) << 8) | o;
                            return o;
                        }
                        public static function uint16ToBinary(ba:IDataOutput, v:uint):void
                        {
                            uint8ToBinary(ba, v & 0xFF);
                            uint8ToBinary(ba, (v >> 8) & 0xFF);
                        }

                        public static function uint32FromBinary(ba:IDataInput):uint
                        {
                            var o:uint;
                            o = uint8FromBinary(ba);
                            o = (uint8FromBinary(ba) << 8) | o;
                            o = (uint8FromBinary(ba) << 16) | o;
                            o = (uint8FromBinary(ba) << 24) | o;
                            return o;
                        }
                        public static function uint32ToBinary(ba:IDataOutput, v:uint):void
                        {
                            uint8ToBinary(ba, v & 0xFF);
                            uint8ToBinary(ba, (v >> 8) & 0xFF);
                            uint8ToBinary(ba, (v >> 16) & 0xFF);
                            uint8ToBinary(ba, (v >> 24) & 0xFF);
                        }

                        public static function int8FromBinary(ba:IDataInput):int { return ba.readByte(); }
                        public static function int8ToBinary(ba:IDataOutput, v:int):void { ba.writeByte(v); }

                        public static function int16FromBinary(ba:IDataInput):int
                        {
                            var o:uint;
                            o = int8FromBinary(ba) & 0xFF;
                            o = ((int8FromBinary(ba) & 0xFF) << 8) | o;
                            return o;
                        }
                        public static function int16ToBinary(ba:IDataOutput, v:int):void
                        {
                            int8ToBinary(ba, v & 0xFF);
                            int8ToBinary(ba, (v >> 8) & 0xFF);
                        }

                        public static function int32FromBinary(ba:IDataInput):int
                        {
                            var o:int;
                            o = int8FromBinary(ba) & 0xFF;
                            o = ((int8FromBinary(ba) & 0xFF) << 8) | o;
                            o = ((int8FromBinary(ba) & 0xFF) << 16) | o;
                            o = ((int8FromBinary(ba) & 0xFF) << 24) | o;
                            return o;
                        }
                        public static function int32ToBinary(ba:IDataOutput, v:int):void
                        {
                            int8ToBinary(ba, v & 0xFF);
                            int8ToBinary(ba, (v >> 8) & 0xFF);
                            int8ToBinary(ba, (v >> 16) & 0xFF);
                            int8ToBinary(ba, (v >> 24) & 0xFF);
                        }

                        public static function float32FromBinary(ba:IDataInput):Number
                        {
                            var b:ByteArray = new ByteArray();
                            b.endian = Endian.LITTLE_ENDIAN;
                            ba.readBytes(b, 0, 4);
                            b.position = 0;
                            return b.readFloat();
                        }
                        public static function float32ToBinary(ba:IDataOutput, v:Number):void
                        {
                            var b:ByteArray = new ByteArray();
                            b.endian = Endian.LITTLE_ENDIAN;
                            b.writeFloat(v);
                            b.position = 0;
                            ba.writeBytes(b, 0, 4);
                        }

                        public static function float64FromBinary(ba:IDataInput):Number
                        {
                            var b:ByteArray = new ByteArray();
                            b.endian = Endian.LITTLE_ENDIAN;
                            ba.readBytes(b, 0, 8);
                            b.position = 0;
                            return b.readDouble();
                        }
                        public static function float64ToBinary(ba:IDataOutput, v:Number):void
                        {
                            var b:ByteArray = new ByteArray();
                            b.endian = Endian.LITTLE_ENDIAN;
                            b.writeDouble(v);
                            b.position = 0;
                            ba.writeBytes(b, 0, 8);
                        }

                        ${Serializers}
                    }
        Template
            Name BinaryTranslator_Record
            //Parameters: ${Name}, ${FieldFroms}, ${FieldTos}
            Value
                $String
                    public static function [[${name}FromBinary]](ba:IDataInput):[[${Name}]]
                    {
                        var o:[[${Name}]] = new [[${Name}]]();
                        ${FieldFroms}
                        return o;
                    }
                    public static function [[${name}ToBinary]](ba:IDataOutput, o:[[${Name}]]):void
                    {
                        ${FieldTos}
                    }
        Template
            Name BinaryTranslator_FieldFrom
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    o.[[${name}]] = BinaryTranslator.[[${typeFriendlyName}FromBinary]](ba);
        Template
            Name BinaryTranslator_FieldTo
            //Parameters: ${Name}, ${TypeFriendlyName}
            Value
                $String
                    BinaryTranslator.[[${typeFriendlyName}ToBinary]](ba, o.[[${name}]]);
        Template
            Name BinaryTranslator_TaggedUnion
            //Parameters: ${Name}, ${AlternativeFroms}, ${AlternativeTos}
            Value
                $String
                    public static function [[${name}FromBinary]](ba:IDataInput):[[${Name}]]
                    {
                        var o:[[${Name}]] = new [[${Name}]]();
                        o._tag = BinaryTranslator.[[${name}TagFromBinary]](ba);
                        ${AlternativeFroms}
                        throw new flash.errors.IllegalOperationError();
                    }
                    public static function [[${name}ToBinary]](ba:IDataOutput, o:[[${Name}]]):void
                    {
                        BinaryTranslator.[[${name}TagToBinary]](ba, o._tag);
                        ${AlternativeTos}
                        throw new flash.errors.IllegalOperationError();
                    }
        Template
            Name BinaryTranslator_AlternativeFrom
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o._tag == [[${TaggedUnionName}Tag.${NAME}]])
                    {
                        o.[[${name}]] = BinaryTranslator.[[${typeFriendlyName}FromBinary]](ba);
                        return o;
                    }
        Template
            Name BinaryTranslator_AlternativeTo
            //Parameters: ${TaggedUnionName}, ${Name}, ${TypeFriendlyName}
            Value
                $String
                    if (o._tag == [[${TaggedUnionName}Tag.${NAME}]])
                    {
                        BinaryTranslator.[[${typeFriendlyName}ToBinary]](ba, o.[[${name}]]);
                        return;
                    }
        Template
            Name BinaryTranslator_Enum
            //Parameters: ${Name}
            Value
                $String
                    public static function [[${name}FromBinary]](ba:IDataInput):int { return intFromBinary(ba); }
                    public static function [[${name}ToBinary]](ba:IDataOutput, v:int):void { intToBinary(ba, v); }
        Template
            Name BinaryTranslator_List
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${ElementTypeFriendlyName}
            Value
                $String
                    public static function [[${typeFriendlyName}FromBinary]](ba:IDataInput):[[${TypeString}]]
                    {
                        var c:[[${TypeString}]] = new [[${TypeString}]]();
                        var n:int = intFromBinary(ba);
                        for (var k:int = 0; k < n; k += 1)
                        {
                            c.push([[${elementTypeFriendlyName}FromBinary]](ba));
                        }
                        return c;
                    }
                    public static function [[${typeFriendlyName}ToBinary]](ba:IDataOutput, c:[[${TypeString}]]):void
                    {
                        BinaryTranslator.intToBinary(ba, c.length);
                        for (var k:int = 0; k < c.length; k += 1)
                        {
                            [[${elementTypeFriendlyName}ToBinary]](ba, c[k]);
                        }
                    }
        Template
            Name BinaryTranslator_Set
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${ElementTypeFriendlyName}
            Value
                $String
                    public static function [[${typeFriendlyName}FromBinary]](ba:IDataInput):[[${TypeString}]]
                    {
                        var c:[[${TypeString}]] = new [[${TypeString}]]();
                        var n:int = intFromBinary(ba);
                        for (var k:int = 0; k < n; k += 1)
                        {
                            c.push([[${elementTypeFriendlyName}FromBinary]](ba));
                        }
                        return c;
                    }
                    public static function [[${typeFriendlyName}ToBinary]](ba:IDataOutput, c:[[${TypeString}]]):void
                    {
                        BinaryTranslator.intToBinary(ba, c.length);
                        for (var k:int = 0; k < c.length; k += 1)
                        {
                            [[${elementTypeFriendlyName}ToBinary]](ba, c[k]);
                        }
                    }
        Template
            Name BinaryTranslator_Map
            //Parameters: ${TypeFriendlyName}, ${TypeString}, ${KeyTypeFriendlyName}, ${ValueTypeFriendlyName}
            Value
                $String
                    public static function [[${typeFriendlyName}FromBinary]](ba:IDataInput):[[${TypeString}]]
                    {
                        var c:[[${TypeString}]] = new [[${TypeString}]]();
                        var n:int = intFromBinary(ba);
                        for (var k:int = 0; k < n; k += 1)
                        {
                            var p:[[KeyValuePairOf${KeyTypeFriendlyName}And${ValueTypeFriendlyName}]] = new [[KeyValuePairOf${KeyTypeFriendlyName}And${ValueTypeFriendlyName}]]();
                            p.key = [[${keyTypeFriendlyName}FromBinary]](ba);
                            p.value = [[${valueTypeFriendlyName}FromBinary]](ba);
                            c.push(p);
                        }
                        return c;
                    }
                    public static function [[${typeFriendlyName}ToBinary]](ba:IDataOutput, c:[[${TypeString}]]):void
                    {
                        BinaryTranslator.intToBinary(ba, c.length);
                        for (var k:int = 0; k < c.length; k += 1)
                        {
                            var p:[[KeyValuePairOf${KeyTypeFriendlyName}And${ValueTypeFriendlyName}]] = c[k];
                            [[${keyTypeFriendlyName}ToBinary]](ba, p.key);
                            [[${valueTypeFriendlyName}ToBinary]](ba, p.value);
                        }
                    }
        Template
            Name IBinarySender
            Value
                $String
                    public interface IBinarySender
                    {
                        function send(commandName:String, commandHash:uint, parameters:ByteArray):void;
                    }
        Template
            Name BinarySerializationClient
            //Parameters: ${NumClientCommand}, ${Hash}, ${Client_ServerCommandHandles}, ${Client_ClientCommandHandles}, ${Client_ClientCommandDeques}, ${Client_Commands}
            Value
                $String
                    public final class BinarySerializationClient implements IApplicationClient
                    {
                        private var s:IBinarySender;
                        private var requests:Vector.<Vector.<Function>>;

                        public function BinarySerializationClient(s:IBinarySender)
                        {
                            this.s = s;
                            requests = new Vector.<Vector.<Function>>();
                            for (var k:int = 0; k < ${NumClientCommand}; k += 1)
                            {
                                requests.push(new Vector.<Function>());
                            }
                        }

                        public function get hash():String
                        {
                            return "${Hash}";
                        }

                        public function handleResult(commandName:String, commandHash:uint, parameters:ByteArray):void
                        {
                            switch (commandName)
                            {
                                ${Client_ServerCommandHandles}
                            }
                            var callback:Function = dequeueCallbackInner(commandName);
                            if (callback == null) { return; }
                            switch (commandName)
                            {
                                ${Client_ClientCommandHandles}
                            }
                            throw new IllegalOperationError(commandName);
                        }

                        private function dequeueCallbackInner(commandName:String):Function
                        {
                            switch (commandName)
                            {
                                ${Client_ClientCommandDeques}
                                default:
                                    throw new IllegalOperationError(commandName);
                            }
                        }

                        public function dequeueCallback(commandName:String):void
                        {
                            dequeueCallbackInner(commandName);
                        }

                        ${Client_Commands}
                    }
        Template
            Name BinarySerializationClient_ServerCommandHandle
            //Parameters: ${Name}, ${CommandHash}
            Value
                $String
                    case "${Name}":
                        if (commandHash == 0x${CommandHash})
                        {
                            if ([[${name}Handler]] != null)
                            {
                                [[${name}Handler]](BinaryTranslator.[[${name}EventFromBinary]](parameters));
                            }
                            return;
                        }
                        break;
        Template
            Name BinarySerializationClient_ClientCommandHandle
            //Parameters: ${Name}, ${CommandHash}
            Value
                $String
                    case "${Name}":
                        if (commandHash == 0x${CommandHash})
                        {
                            callback(BinaryTranslator.[[${name}ReplyFromBinary]](parameters));
                            return;
                        }
                        break;
        Template
            Name BinarySerializationClient_ClientCommandDeque
            //Parameters: ${Name}, ${ClientCommandIndex}
            Value
                $String
                    case "${Name}":
                        var [[r${ClientCommandIndex}]]:Vector.<Function> = requests[${ClientCommandIndex}];
                        return [[r${ClientCommandIndex}]].shift();
        Template
            Name BinarySerializationClient_ClientCommand
            //Parameters: ${Name}, ${CommandHash}, ${ClientCommandIndex}
            Value
                $String
                    public function [[${name}]](r:[[${Name}Request]], callback:Function):void
                    {
                        var ra:Vector.<Function> = requests[${ClientCommandIndex}];
                        var ba:ByteArray = new ByteArray();
                        BinaryTranslator.[[${name}RequestToBinary]](ba, r);
                        ba.position = 0;
                        s.send("${Name}", 0x${CommandHash}, ba);
                        ra.push(callback);
                    }
        Template
            Name BinarySerializationClient_ServerCommand
            //Parameters: ${Name}
            Value
                $String
                    private var [[${name}Handler]]:Function;
                    public function set [[${name}]](callback:Function):void { [[${name}Handler]] = callback; }
