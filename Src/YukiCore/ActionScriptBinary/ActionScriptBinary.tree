$Comment
    ==========================================================================

      File:        ActionScriptBinary.tree
      Location:    Yuki.Core <Tree>
      Description: 对象类型结构ActionScript3.0二进制通讯模板数据
      Version:     2012.04.23.
      Copyright(C) F.R.C.

    ==========================================================================

ObjectSchemaTemplate
    Keywords
    $End
    PrimitiveMappings
    $End
    Templates
        Template
            Name Main
            //Parameters: ${PackageName}, ${Imports}, ${Type}
            Value
                $String
                    //==========================================================================
                    //
                    //  Notice:      This file is automatically generated.
                    //               Please don't modify this file.
                    //
                    //==========================================================================

                    package [[${PackageName}]]
                    {
                        import flash.errors.IllegalOperationError;
                        import flash.utils.Dictionary;
                        import flash.utils.IDataInput;
                        import flash.utils.IDataOutput;
                        import flash.utils.ByteArray;
                        import flash.utils.Endian;
                        import ${Imports};

                        ${Type}
                    }

                $End
        Template
            Name IBinarySender
            Value
                $String
                    public interface IBinarySender
                    {
                        function send(commandName:String, commandHash:uint, parameters:ByteArray):void;
                    }
        Template
            Name BinaryClient
            //Parameters: ${NumClientCommand}, ${Hash}, ${Client_ServerCommandHandles}, ${Client_ClientCommandHandles}, ${Client_ClientCommandDeques}, ${Client_ClientCommands}
            Value
                $String
                    public class BinaryClient
                    {
                        private var s:IBinarySender;
                        private var ci:IClientImplementation;
                        private var requests:Vector.<Vector.<Function>>;

                        public function BinaryClient(s:IBinarySender, ci:IClientImplementation)
                        {
                            this.s = s;
                            this.ci = ci;
                            requests = new Vector.<Vector.<Function>>();
                            for (var k:int = 0; k < ${NumClientCommand}; k += 1)
                            {
                                requests.push(new Vector.<Function>());
                            }
                        }

                        public function get hash():String
                        {
                            return "${Hash}";
                        }

                        public function handleResult(commandName:String, commandHash:uint, parameters:ByteArray):void
                        {
                            switch (commandName)
                            {
                                ${Client_ServerCommandHandles}
                            }
                            var callback:Function = dequeueCallbackInner(commandName);
                            if (callback == null) { return; }
                            switch (commandName)
                            {
                                ${Client_ClientCommandHandles}
                            }
                            throw new IllegalOperationError(commandName);
                        }

                        private function dequeueCallbackInner(commandName:String):Function
                        {
                            switch (commandName)
                            {
                                ${Client_ClientCommandDeques}
                                default:
                                    throw new IllegalOperationError(commandName);
                            }
                        }

                        public function dequeueCallback(commandName:String):void
                        {
                            dequeueCallbackInner(commandName);
                        }

                        ${Client_ClientCommands}
                    }
        Template
            Name BinaryClient_ServerCommandHandle
            //Parameters: ${Name}, ${CommandHash}
            Value
                $String
                    case "${Name}":
                        if (commandHash == 0x${CommandHash})
                        {
                            ci.[[${name}]](BinaryTranslator.[[${name}EventFromBinary]](parameters));
                            return;
                        }
        Template
            Name BinaryClient_ClientCommandHandle
            //Parameters: ${Name}, ${CommandHash}
            Value
                $String
                    case "${Name}":
                        if (commandHash == 0x${CommandHash})
                        {
                            callback(BinaryTranslator.[[${name}ReplyFromBinary]](parameters));
                            return;
                        }
        Template
            Name BinaryClient_ClientCommandDeque
            //Parameters: ${Name}, ${ClientCommandIndex}
            Value
                $String
                    case "${Name}":
                        var [[r${ClientCommandIndex}]]:Vector.<Function> = requests[${ClientCommandIndex}];
                        return [[r${ClientCommandIndex}]].shift();
        Template
            Name BinaryClient_ClientCommand
            //Parameters: ${Name}, ${CommandHash}, ${ClientCommandIndex}, ${XmlComment}
            Value
                $String
                    ${XmlComment}
                    public function [[${name}]](r:[[${Name}Request]], callback:Function):void
                    {
                        var ra:Vector.<Function> = requests[${ClientCommandIndex}];
                        var ba:ByteArray = new ByteArray();
                        BinaryTranslator.[[${name}RequestToBinary]](ba, r);
                        ba.position = 0;
                        s.send("${Name}", 0x${CommandHash}, ba);
                        ra.push(callback);
                    }
